./ ADD NAME=$$$INDEX 0666-07209-07209-0913-00001-00001-00000-DIR2UPDT
rexx_$$$INDEX: /* We still need rexx in comment if read from SYSPROC */
  $$$index_version = "01.00"
/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

 Dataset:  REXX($$$INDEX)
 Author:   "Kenneth Tomiak"<CBT_Ken@KTomiak.biz>
 Overview: Some simple descriptions of the members.

=======================================================================

Miscelleaneous
-------- --------------------------------------------------------------
BATCHISP Launch ISPF and passed command

Edit macros
-------- --------------------------------------------------------------
AGE      Edit macro giving you chance to save that member as a new one
JOBCARD  Add a jobcard using an instream template.
JCLDSCB  Add DSCB information as comment lines in JCL

Information gathering
-------- --------------------------------------------------------------
ACEETRID Follow control blocks to ACEE and your terminal id
DDBYCBLK DDNAME by following control blocks
DDBYLSTA DDNAME by parsing LISTALC STATUS output
DDBYQLIB DDNAME by ISPF QBASELIB
DDBYTSTR DDNAME IVP using ddbycblk, ddbylsta, and ddtrap
DDTRAP   DDNAME by parsing LISTALC STATUS output, poorly written
RACFINFO List everything a user can access

Utilitarian commands
-------- --------------------------------------------------------------
HLQSPACE Sample of using ISPF 3.4 like facility
VIEWHELP Invoke help, capture output and view it
UPDREFDT Access datasets to update the last-reference date

How to samples
-------- --------------------------------------------------------------
BUBLSORT Sort by comparing two entries and swapping
IPCSIVP  An assortment of IPCS commands to demonstrate how to
REXXUSS  Rexx invoking Unix System Services functions
XYGRID   a real use of x,y grid using negative and positive values

Transporting data
-------- --------------------------------------------------------------
HEX2OBJ  Sample output from running OBJ2HEX
OBJ2HEX  Convert an object into a rexx program that converts it back
PDS2UPDT Use ISPF services to convert a PDS to an IEBUPDTE stream
PDS2XMIT Front-end to the TRANSMIT command to produce a sequential file
REXUPDTE Convert IEBUPDTE stream into PDS members with statistics
SDSFDISK Simple way to capture output to disk
TXT2STEM Convert a text string into stem variables
XMIT2PDS Front-end to the RECEIVE command to produce the original file

TCP/IP oriented
-------- --------------------------------------------------------------
URLCHECK Check if url has been updated since last run

=======================================================================

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */

  Return 0

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
__DATA__
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
./ ADD NAME=ACEETRID 0666-07208-07208-2244-00001-00001-00000-DIR2UPDT
rexx_aceetrid:    /* rexx */
  aceetrid_version = "01.00"
/* REXX */
ascb_ptr = c2x(storage(d2x(x2d("224")),4))
asxb_ptr = c2x(storage(d2x(x2d(ascb_ptr) + x2d("6c")),4))
acee_ptr = c2x(storage(d2x(x2d(asxb_ptr) + x2d("c8")),4))
acee_trid = storage(d2x(x2d(acee_ptr) + x2d("40")),8)
acee_len = c2d(storage(d2x(x2d(acee_ptr) + x2d("14")),1))
acee_uid = storage(d2x(x2d(acee_ptr) + x2d("15")),acee_len)
say "("acee_uid") ("acee_trid")"
exit 0
./ ADD NAME=AGE      0666-07210-07210-0903-00001-00001-00000-DIR2UPDT
rexx_AGE:         /*              REXX                      */
  Address IsrEdit "MACRO (newmbr)"
  rexxpgm_version = "02.00"
  Address IspExec "CONTROL ERRORS Return"
  Address IsrEdit "CAPS OFF"
  Address IsrEdit "(MEMBER) = MEMBER"
  Address IsrEdit "(MYDSN,yourdsn,libnum) = DATASET"
  Address IsrEdit "(MYvol1,myvolq) = VOLUME"
  Address ISPEXEC,
    "LMINIT DATAID(dataidv) DATASET('"mydsn"') ENQ(SHRW)",
    "VOLUME("myvol1")"
  ISP_RC = RC
  If (ISP_RC >< 0) then,        /* RETURN CODES                     */
                                /*  8 - Data set or file not        */
                                /*      allocated                   */
                                /*    - DDname not found            */
                                /*    - Data set or file            */
                                /*      organization not supported  */
                                /* 12 - Invalid parameter value     */
                                /* 16 - Truncation or translation   */
                                /*      error in accessing dialog   */
                                /*      variables                   */
                                /* 20 - Severe error                */
    Do
      ZERRHM = "*"
      ZERRALRM = "YES"
      ZERRSM = "LMINIT 1 ERROR ("isp_rc")"
      ZERRLM = "AN ISPF ERROR PREVENTED LMINIT from working."
      ADDRESS ISPEXEC "VPUT (ZERRSM ZERRLM ZERRHM ZERRALRM) SHARED"
      ADDRESS ISPEXEC "SETMSG MSG(ISRZ002)"
      exit isp_rc
    End
  Address ISPEXEC,
    "LMINIT DATAID(dataidu) DATASET('"mydsn"') ENQ(SHRW)",
    "VOLUME("myvol1")"
  ISP_RC = RC
  If (ISP_RC >< 0) then,        /* RETURN CODES                    */
    Do
      ZERRHM = "*"
      ZERRALRM = "YES"
      ZERRSM = "LMINIT 2 ERROR ("isp_rc")"
      ZERRLM = "AN ISPF ERROR PREVENTED LMINIT from working."
      ADDRESS ISPEXEC "VPUT (ZERRSM ZERRLM ZERRHM ZERRALRM) SHARED"
      ADDRESS ISPEXEC "SETMSG MSG(ISRZ002)"
      exit isp_rc
    End
  Address ISPEXEC,
    "LMCOPY FROMID("dataidv") FROMMEM("member")",
         "TODATAID("dataidu")   TOMEM("newmbr")",
         "REPLACE"
  ISP_RC = RC
  If (ISP_RC >< 0) then,        /* RETURN CODES                    */
                          /*  4 - Member not available: in an LMF  */
                          /*      controlled ISPF library and      */
                          /*      currently owned by another user  */
                          /*    - Member not available: in an LMF  */
                          /*      controlled ISPF library and user */
                          /*      is not a valid user as specified */
                          /*      by member access id              */
                          /*    - "From" data set is empty         */
                          /*    - No members match pattern         */
                          /*    - Tried to lock a member in an     */
                          /*      SCLM-controlled library          */
                          /*  8 - "From" member not found          */
                          /* 10 - No data set associated with the  */
                          /*      given data-id                    */
                          /* 12 - Invalid data set organization    */
                          /*    - Data set attribute invalid for   */
                          /*      packed data                      */
                          /*    - Member already exists in "to"    */
                          /*      data set and "REPLACE" was       */
                          /*      not specified                    */
                          /*    - Open error                       */
                          /* 16 - Truncation error                 */
                          /* 20 - Severe error                     */
    Do
      ZERRHM = "*"
      ZERRALRM = "YES"
      ZERRSM = "LMCOPY ERROR ("isp_rc")"
      ZERRLM = "AN ISPF ERROR PREVENTED LMCOPY from working."
      ADDRESS ISPEXEC "VPUT (ZERRSM ZERRLM ZERRHM ZERRALRM) SHARED"
      ADDRESS ISPEXEC "SETMSG MSG(ISRZ002)"
    End
    Address ISPEXEC,
      "LMFREE  DATAID("dataidv")"
    FREE_RC = RC
    If (FREE_RC >< 0) then,     /* RETURN CODES                    */
                                /*   8 - Free data set or file     */
                                /*       failed                    */
                                /*  10 - No data set or file       */
                                /*       associated with data-id   */
                                /*  20 - Severe error              */
    Do
      ZERRHM = "*"
      ZERRALRM = "YES"
      ZERRSM = "LMFREE ERROR ("isp_rc")"
      ZERRLM = "AN ISPF ERROR PREVENTED LMFREE from working."
      ADDRESS ISPEXEC "VPUT (ZERRSM ZERRLM ZERRHM ZERRALRM) SHARED"
      ADDRESS ISPEXEC "SETMSG MSG(ISRZ002)"
    End
    Address ISPEXEC,
      "LMFREE  DATAID("dataidu")"
    FREE_RC = RC
    If (FREE_RC >< 0) then,     /* RETURN CODES                    */
                                /*   8 - Free data set or file     */
                                /*       failed                    */
                                /*  10 - No data set or file       */
                                /*       associated with data-id   */
                                /*  20 - Severe error              */
    Do
      ZERRHM = "*"
      ZERRALRM = "YES"
      ZERRSM = "LMFREE ERROR ("isp_rc")"
      ZERRLM = "AN ISPF ERROR PREVENTED LMFREE from working."
      ADDRESS ISPEXEC "VPUT (ZERRSM ZERRLM ZERRHM ZERRALRM) SHARED"
      ADDRESS ISPEXEC "SETMSG MSG(ISRZ002)"
    End
  ZERRHM = "*"
  ZERRALRM = "YES"
  ZERRSM = "AGED to" newmbr"!"
  ZERRLM = "It worked. AGE copied" member "to" newmbr"."
  ADDRESS ISPEXEC "VPUT (ZERRSM ZERRLM ZERRHM ZERRALRM) SHARED"
  ADDRESS ISPEXEC "SETMSG MSG(ISRZ002)"
  exit 0
./ ADD NAME=BATCHISP 0666-07213-07213-1945-00001-00001-00000-DIR2UPDT
rexx_BATCHISP: /* We still need rexx in comment if read from SYSPROC */
  rexxpgm_version = "02.01"
/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

  Dataset: REXX(BATCHISP)
  Author:  "Kenneth Tomiak"<CBT_Ken@KTomiak.biz>
  Syntax:  BATCHISP {arguments ...}

=======================================================================

  History of Modifications
  ------------------------
  When     Who      What you did
  -------- -------- ---------------------------------------------------
  20070729 KTomiak  02.01 Standardizing Rexx_Initialize routine
  20070329 KTomiak  02.00 Formatted into new style
  20011119 KTomiak  01.00 Original code

=======================================================================

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */

  Parse Arg all_my_arguments
  Numeric Digits 12

rexx_Main_BATCHISP:
  return_code = rexx_Initialize()
  If (return_code = 0) then,
    Do
      return_code = rexx_Process()
      return_code = rexx_Termination()
    End
   Return 0

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
  In this routine we open any files and intialize any
  constants we might need.
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
rexx_Initialize:
  PARSE VERSION,
    version_rexx_name,
    version_rexx_version,
    version_rexx_date
  PARSE SOURCE,
    source_host_env,
    source_call_type,
    source_uc_exec_name,
    source_hostdd,
    source_hostdsn,
    source_nf_exec_name,
    source_initial_cmd_env,
    source_asid_name,
    source_char8_user_token,
    source_hostother
  Address_Environment = Address()
  job_specs = rexx_jobspecs()
  say ""
  say Copies("=",55)
  say left("=" source_uc_exec_name rexxpgm_version,53) "="
  say left("=" "executing under" source_host_env,53) "="
  say left("=" "as a" source_call_type,53) "="
  say left("=  on" date() "at" time()".",53) "="
  say Copies("=",55)
  say ""
  return_code = 0
  sysvar_sysuid=SYSVAR("SYSUID")

  If (source_host_env >< "TSO") Then,
    Do
      Say "Wrong host environment" source_host_env
      return_code = 16
    End

  Return return_code
  say "Attempting to execute command=" all_my_arguments
  Say ""
  say copies(" =",39)
  Signal OFF Error
  x=OutTrap("sysoutline.",1000)
  "ispstart cmd("all_my_arguments") BDISPMAX(250)"
  batchisp_rc = RC
  x=OutTrap("OFF")
  return_code = batchisp_rc
  If (return_code > 4096) then,
    Do
      old_code = return_code
      return_code = 4096
      say "Fixing return code("old_code") to rc("return_code")"
    End
  Return Return_code

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
  In this routine we close files and finish up.
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
rexx_Termination:
  If (sysoutline.0 > 0) Then,
    Do
      say ""
      say "Any output between lines is from called command."
      say ""
      say copies(" -",39)
      Do i = 1 to sysoutline.0
        say sysoutline.i
      End
      say copies(" -",39)
      say ""
    End
  say ""
  Say "Ending with return code=" return_code
  say ""
  say copies(" =",39)
  say ""
  Return Return_code

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
  Place any of your subroutines and procedures below this.
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
rexx_jobspecs:
  /*---------------------------------------------------------------*/
  /* ADDRESSABILITY TO CVT FROM PSA                                */
  /*---------------------------------------------------------------*/
  PTR2PSA = 0
  CVTPTR = STORAGE(D2X(PTR2PSA + 16),4)
  /*---------------------------------------------------------------*/
  /* ADDRESSABILITY TO SMCA, THEN GET SMF SYSTEM ID                */
  /*---------------------------------------------------------------*/
  CVTSMCA = STORAGE(D2X(C2D(CVTPTR)+197),3)
  SMFID = STORAGE(D2X(C2D(CVTSMCA)+16),4)
  /*---------------------------------------------------------------*/
  /* GET JOBNAME, STEP, AND PROCEDURE                              */
  /*---------------------------------------------------------------*/
  PSATOLD  = STORAGE(21C,4)                    /* POINTER TO TCB   */
  PTRTIOT  = STORAGE(D2X(C2D(PSATOLD)+12),4)   /* POINTER TO TIOT  */
  JOBNAME  = STORAGE(D2X(C2D(PTRTIOT)),8)
  STEPNAME = STORAGE(D2X(C2D(PTRTIOT)+8),8)
  PROCNAME = STORAGE(D2X(C2D(PTRTIOT)+16),8)
  Tcbjscbb = Storage(D2x(C2d(Psatold)+181),3)                /* jscb */
  jscbssib = STORAGE(D2X(C2D(tcbjscbb)+316),4)        /* Ptr to SSIB */
  ssibjbid = STORAGE(D2X(C2D(jscbssib)+12),8)      /* job identifier */
  Return JOBNAME SSIBJBID STEPNAME PROCNAME

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
__DATA__
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */

./ ADD NAME=BPXTREE  0666-07212-07212-2023-00001-00001-00000-DIR2UPDT
parse arg path
say ""
say "BPXTREE" DATE() TIME()
say ""
if path = "" then path = '/'
call rdir path
say ""
exit 0
rdir: procedure
   call syscalls on
   parse arg path
   say "Path:" path
   tabs = copies(" ",length(path))
   d.0=0
   address syscall 'readdir (path) d.'
   if d.0=0 then
      say 'ERROR>> Cannot read directory:' path
   else
   do i=1 to d.0
      dpath=path'/'d.i
/*    address syscall 'lstat (dpath)' st.     */
      rt = ketcall('lstat (dpath)' st.)
      if rt >< 0 then
        do
          say "rt" rt retval
          return 0
        end
      if st.st_type=s_isdir & d.i<>'.' & d.i<>'..' then
         call rdir dpath
      else,
      if d.i<>'.' & d.i<>'..' then
         say "File:" tabs"/"d.i
   end
   return

ketcall:
   parse arg xx
   address syscall xx
   krc = rc
   if krc < 0 then
     do
       say "Can this happen? rc("krc")"
     end
   if krc>=0 & retval<>-1 then
     do
       return 0              /* this is normally what happens */
     end
   parse var xx '(' nm ')'
   if nm<>'' then nm=value(nm)
   say "ADDRESS SYSCALL:" xx
   say 'Error codes:' krc retval errno errnojr
   "BPXMTEXT" errnojr
   return retval
./ ADD NAME=BUBLSORT 0666-07208-07208-2245-00001-00001-00000-DIR2UPDT
rexx_bublsort: /* rexx */
  bublsort_version = "01.00"
  stem.0 = 0
  some_var = "Tomiak, Kenneth"
  call stem_it
  some_var = "Else, Somebody"
  call stem_it
  some_var = "Body, Any"
  call stem_it
  /* show results                                               */
  say ""
  say "Original stem. order"
  do sx = 1 to stem.0
    say stem.sx
  end
  call stem_sort_asc
  /* show results                                               */
  say ""
  say "Sorted stem. ascending order"
  do sx = 1 to stem.0
    say stem.sx
  end
  call stem_sort_desc
  /* show results                                               */
  say ""
  say "Sorted stem. descending order"
  do sx = 1 to stem.0
    say stem.sx
  end
  return

stem_it:
  parse value     stem.0+1  some_var  ,
         with  1  x         stem.x    ,
               1  stem.0 .
  return

stem_sort_asc: Procedure Expose stem.
  count_of_elements = stem.0
  /* loop through the array (count_of_elements - 1) ** 2 times */
  do i = 1 to  (count_of_elements - 1)
    do j = 1 to (count_of_elements - 1)
      j_plus1 = j + 1
  /* if an element is greater than the next one higher then swap them */
      if stem.j > stem.j_plus1 then call swap_pair
    end j
  end i
  return

  /* reverse the order of the two elements */
swap_pair:
  temp = stem.j
  stem.j = stem.j_plus1
  stem.j_plus1 = temp
  return

stem_sort_desc: Procedure Expose stem.
  count_of_elements = stem.0
  /* loop through the array (count_of_elements - 1) ** 2 times */
  do i = 1 to  (count_of_elements - 1)
    do j = 1 to (count_of_elements - 1)
      j_plus1 = j + 1
  /* if an element is greater than the next one higher then swap them */
      if stem.j < stem.j_plus1 then call swap_pair
    end j
  end i
  return
./ ADD NAME=CONDCODE 0666-07213-07213-1939-00001-00001-00000-DIR2UPDT
rexx_CONDCODE: /* We still need rexx in comment if read from SYSPROC */
  rexxpgm_version = "01.15"
/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

  Dataset: REXX(CONDCODE)
  Author:  "Kenneth Tomiak"<CBT_Ken@KTomiak.biz>
  Syntax:  CONDCODE {}
  Purpose: Retrieve Condition Codes for each prior step.
           Follow MVS control blocks to the STEP CONTROL TABLE,
           then decipher status bytes to display what occurred
           for each of the prior steps.

=======================================================================

  History of Modifications
  ------------------------
  When     VV MM WHO and what you did
  -------- ----- ------------------------------------------------------
  20070801 01.15 Kenneth E Tomiak <KenTomiak@KTomiak.org>
                 Formatted in standard FILE760 format.

  20070320 01.14 Kenneth E Tomiak <KenTomiak@KTomiak.org>
                 >>>>> FORMAT CHANGES <<<<<
                 Replaced call to ptr in swareq procedure

  20040422 01.13 Lionel B. Dyck <lionel.b.dyck@kp.org>
                 Correction for high condition code testing/report.

  20030620 01.12 Kenneth E. Tomiak <CBT_Ken@KTomiak.biz>
                 >>>>> FORMAT CHANGES <<<<<
                 lengthened static 0's on Harry's "U" abend corrections
                 and converted not equal compares to ><.
                 Coded "S" indent in a different manner. Removed logic
                 inclusion of sctxabcc = '00' until I see it ever
                 occurs when sctabcnd = '04'. I did find assembler
                 invoked abends were not being handled properly so I
                 had to do some logic changes, too.

  20030419 01.11 Harry van Burik <h.vanburik@pinkroccade.com>
                 >>>>> FORMAT CHANGES <<<<<
                 Several minor corrections to formatting
                 Indent step level "S" abend.
                 Increase length of User abend to four digits.
                 Added a check of sctxabcc=00 under sctabcnd=04.

  20030326 01.10 Kenneth E. Tomiak <CBT_Ken@KTomiak.biz>
                 >>>>> FORMAT CHANGES <<<<<
                 Fixed compare of high_cond when using sctsexec and
                 removed "R" if no abend occurred.

  20030324 01.09 Lionel B. Dyck <lionel.b.dyck@kp.org>
                 >>>>> FORMAT CHANGES <<<<<
                 Split the JOB= line into two lines.
                 Set last_abend and high_cond to 0.

  20030318 01.08 Kenneth E. Tomiak <CBT_Ken@KTomiak.biz>
                 >>>>> FORMAT CHANGES <<<<<
                 Format Jctacode, show lastabend and highest condcode,
                 include SSIB jobid, and completed changes to swareq.

  20030317 01.07 Kenneth E. Tomiak <CBT_Ken@KTomiak.biz>
                 Correct sctsexec from 9,1 to 8,2,
                 replaced Foreground check with first step check.

  20030317 01.06 Lionel B. Dyck <lionel.b.dyck@kp.org>
                 Add test for Foreground environment.

  20030316 01.05 Lionel B. Dyck <lionel.b.dyck@kp.org>
                 >>>>> FORMAT CHANGES <<<<<
                 Nop other message for sctabcnd if not 04.

  20030314 01.04 Lionel B. Dyck <lionel.b.dyck@kp.org>
                 >>>>> FORMAT CHANGES <<<<<
                 Minor cleanup (comments and spacing),
                 Changed wording of the generated messages,
                 Changed for 4 bytes for Jctacode.

  20030314 01.03 Kenneth E. Tomiak <CBT_Ken@KTomiak.biz>
                 Added check for steps bypassed due to a RESTART= and
                 spruced up the comments, far more than any code I
                 usually write. Hopefully this will make it easy to
                 understand and maintain.

  20030313 01.02 Kenneth E. Tomiak <CBT_Ken@KTomiak.biz>
                 Inserted SWAREQ routine from code written by:
                 Gilbert Saint-flour <gsf@pobox.com>

  20030313 01.01 Kenneth E. Tomiak <CBT_Ken@KTomiak.biz>
                 Revamped code received from:
                   Lionel B. Dyck <Lionel.B.Dyck@KPM.org>

  ???????? 01.00 Barry Gilder <gilderb@anz.com>
                 Original code.

-----------------------------------------------------------------------

 Important Guidelines:
 This code was written as an information gathering sub-routine
 intended to be called and its results used as the invoker saw
 fit. It was intended to be a report generator. With that thought
 in mind, carefully consider whether your change affects how a
 parsing program will interpret the output. If a flaw in the
 original format is found, it will have to be corrected, and then
 any parsing invokers will have to verify they still work. Please
 make note of such activity so that the callers are forewarned.
 Use the line below to show you made format changes.
           >>>>> FORMAT CHANGES <<<<<

 Disclaimers:
 I have no special knowledge of the inner workings of the
 operating system. I attempted to return one value back to
 indicate the same value you would have received if you used
 NOTIFY= on the jobcard. I was working on using the highest
 numeric COND CODE, unless there was a SYSTEM abend, unless
 there was a USER abend. It then became desirable to show the
 outcome of all of the steps, just as most IEFACTRT exits show
 in your JESMSGLG. At that point I included LASTABEND= to show
 what the jct indicates and HIGHCOND= to show what may be
 considered the most severe error of the job using the COND CODE,
 SYSTEM, USER sequence described above.

 The original code was developed and tested using the DATA AREAS
 manuals and MACLIB entries from OS/390 2.10 and z/OS 1.2. My
 testing includes steps that are designed to fail. Not every
 system abend, user abend, nor return code value; but at least
 two of each.

 I support my code using a best-effort philosophy. As long as I
 have access to an image where I can test, I will maintain it as
 best as I can. If you find a flaw, please do let me know.

 The code released by Kenneth E. Tomiak does not alter anything.
 It follows control blocks that are outside of the IBM defined
 'Programming Interface'. BUYER BEWARE! Your decision to execute
 this code means you accept responsibility for the consequences.
 What could go wrong? If control blocks are changed or used in
 some way I did not anticipate you may find this loops wildly;
 tries to access storage it should not; or other yet to be
 conceived problems. BUYER BEWARE! Always test this in a sandbox
 MVS image if you have concerns.

 In no event will the author be liable to the user of this code
 for any damages. Including, but not limited to, any lost
 profits, lost savings or other incidental, consequential or
 special damages arising out of the operation of or inability to
 operate this code, even if the user has been advised of the
 possibility of such damages.

 With that stated, enjoy all this has to offer.

-----------------------------------------------------------------------

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */

Rexx_condcode:

  Parse Upper Arg Other_Junk         /* No parameters are used       */

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   MAIN procedure which invokes sub-functions.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
  Numeric Digits 12
  Call Init_condcode
  Call Main_condcode
  Call Term_condcode
  Exit Final_Rc

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   Initialize variables used by the code.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   Follow the control blocks to the Step Control Table.

   Psa                                 Prefix Save Area
   Psa@540                             Pointer of PSATOLD
   Psa@540=>tcb                        Task Control Block
   Psa@540=>tcb+181                    Pointer of TCBJSCBB
   Psa@540=>tcb+181=>jscb              JOBSTEP Control BLock
   Psa@540=>tcb+181=>jscb+261          Pointer to Job Control Table
   Psa@540=>tcb+181=>jscb+261=>jct     Job Control Table
   Psa@540=>tcb+181=>jscb+261=>jct+329 Pointer to Step Control Table
   Psa@540=>tcb+181=>jscb+261=>jct+329=>sct       Step Control Table

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
Init_condcode:
  PARSE VERSION,
    version_rexx_name,
    version_rexx_version,
    version_rexx_date
  PARSE SOURCE,
    source_host_env,
    source_call_type,
    source_uc_exec_name,
    source_hostdd,
    source_hostdsn,
    source_nf_exec_name,
    source_initial_cmd_env,
    source_asid_name,
    source_char8_user_token,
    source_hostother
  Address_Environment = Address()
/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  job_specs = rexx_jobspecs()
  say ""
  say Copies("=",55)
  say left("=" source_uc_exec_name rexxpgm_version,53) "="
  say left("=" "executing under" source_host_env,53) "="
  say left("=" "as a" source_call_type,53) "="
  say left("=  on" date() "at" time()".",53) "="
  say Copies("=",55)
  say ""
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
  return_code = 0
  sysvar_sysuid=SYSVAR("SYSUID")
  Psatold  = Storage(D2x(540),4)
  Tcbjscbb = Storage(D2x(C2d(Psatold)+181),3)
  Jscbjct  = Swareq(Storage(D2x(C2d(Tcbjscbb)+261),3))
  Currsct  = Swareq(Storage(D2x(C2d(Tcbjscbb)+329),3))
  Jscbstep = C2d(Storage(D2x(C2d(tcbjscbb)+228),1)) /* Step number   */
  jscbssib = STORAGE(D2X(C2D(tcbjscbb)+316),4)    /* Pointer to SSIB */
  ssibjbid = STORAGE(D2X(C2D(jscbssib)+12),8)     /* job identifier  */

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   Save A Few Fields From The Jct.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */

  Jctjstat =     Storage(D2x(Jscbjct +  5),1)       /* Job Status    */
  Jctjname =     Storage(D2x(Jscbjct +  8),8)       /* Job Name      */
  Jctjfail = C2x(Storage(D2x(Jscbjct + 52),1))      /* Job Failure   */
  Jctacode =     Storage(D2x(Jscbjct +168),4)       /* Job Abend     */

  Job_Stat = c2x(jctjstat)
  If (Bitand('20'x,jctjstat) = '20'x) Then,
    Do
      Job_Stat = job_stat "Cancelled By Condition Codes"
    End
  If (Bitand('08'x,jctjstat) = '08'x) Then,
    Do
      Job_Stat = job_stat "JCT ABend"
    End
  If (Bitand('04'x,jctjstat) = '04'x) Then,
    Do
      Job_Stat = job_stat "Job Failed"
    End
  If (Bitand('02'x,jctjstat) = '02'x) Then,
    Do
      Job_Stat = job_stat "Catalog Job"
    End

  select
    when (Left(C2x(Jctacode),2) = '40') |,
         (Left(C2x(Jctacode),2) = '80') |,
         (Left(C2x(Jctacode),2) = 'C0') Then,
      Do
        Last_Abend = "U"right("0000"c2d(Right(Jctacode,2)),4)
      End
    when (C2x(jctjstat) >< '00') Then,
      Do
        Last_Abend = "S"substr(C2x(Jctacode),3,3)
      End
    otherwise,
      Do
        Last_Abend = 0
      End
  End

  High_Cond = "R000"

  Final_Rc = 0
  Return

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   The meat and potatoes of the code.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   Loop through every SCT.
     Determine the status of the step.
   Jct+32=>1st Sct
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
Main_condcode:
  Thissct  = Swareq(Storage(D2x(Jscbjct+32),3)) /* status code table */
  Do until ((Thissct = '10'x) | (Thissct = Currsct))
    Sctsstat = C2x(Storage(D2x(thissct +4),1)) /* internal step stat */
    Sctsexec = C2d(Storage(D2x(thissct + 8),2))  /* step status code */
    Sctsclpc = Strip(Storage(D2x(thissct + 44),8)) /* step proc name */
    Sctsname = Strip(Storage(D2x(thissct + 52),8))      /* Step name */
    Sctssysc = c2x(Storage(D2x(thissct + 62),2)) /* Step SYStem Code */
    Sctxbttr = Swareq(Storage(D2x(thissct + 68),3))   /* ptr to scte */
    Sctpgmnm = Storage(D2x(thissct +108),8)          /* Program name */
    Sctabcnd = C2x(Storage(D2x(thissct +160),1))       /* Abend code */
    Sctstend = Storage(D2x(thissct +172),1) /* Start End status flag */
    Sctxabcc = Storage(D2x(Sctxbttr +112),4)    /* abend or condcode */

/*-------------------------------------------------------------------*/
/* Determine final status of step.                                   */
/*-------------------------------------------------------------------*/
    Select
      When (Jscbstep = 1) then,
        Do
          cond_code = "Active"
          Queue left(procstep,30) left(SCTpgmnm,9) Cond_Code
          Leave
        End
      When (Sctsstat = '01') Then,
        Do
          Cond_Code = "FLUSH - STEP WAS NOT EXECUTED"
        End
      When (Bitand('10'x,Sctstend) = '10'x) Then,
        Do
          Cond_Code = "FLUSH -",
            "STEP WAS NOT RUN BECAUSE OF CONDITION CODES," ,
            "STEP WAS NOT EXECUTED."
        End
      When (Sctabcnd = '04') Then,
        Do
          Sctxabcc = Storage(D2x(C2d(Sctxbttr)+112),4)
          Select
            When (Left(C2x(Sctxabcc),2) = '40') |,
                 (Left(C2x(Sctxabcc),2) = '80') |,
                 (Left(C2x(Sctxabcc),2) = 'C0') Then,
              Do
                Cond_Code = "U"right("0000"c2d(Right(Sctxabcc,3)),4)
                If (Cond_code > High_cond) then,
                  High_Cond = Cond_code
              End
            When (Left(C2x(Sctxabcc),2) = '00') |,
                 (Left(C2x(Sctxabcc),2) = '04') |,
                 (Left(C2x(Sctxabcc),2) = '84') Then,
              Do
                Cond_Code = "S"substr(C2x(Sctxabcc),3,3)
                If (Cond_code > High_cond) then,
                  High_Cond = Cond_code
              End
            Otherwise
              nop
          End
        End
      When (Bitand('C0'x,Sctstend) = 'C0'x) Then,
        Do
          Cond_Code = Right("     "sctsexec,5)
          sctsexec = right(sctsexec+100000,4)
          If ("R"sctsexec > High_cond) then,
            High_Cond = "R"sctsexec
        End
      When (Bitand('40'x,Sctstend) = '40'x) Then,
        Do
          Cond_Code = "BYPASSED DUE TO RESTART - STEP WAS NOT EXECUTED"
        End
      Otherwise,
        Cond_Code = "Help me!",
          sctsstat'-'sctsexec'-'sctssysc'-'sctabcnd'-'c2x(sctstend)
    End
    If (Sctsclpc >< " ") Then,      /* procstep.stepname combination */
      Procstep = Left(Sctsclpc"."Sctsname,17)
    Else,
      Procstep = Left(Sctsname,17)
    If (left(cond_code,1) = "S") then,
      Do
        Queue left(procstep,30) left(SCTpgmnm,9) " "||Cond_Code
      End
    Else,
      Do
        Queue left(procstep,30) left(SCTpgmnm,9) Cond_Code
      End

/*-------------------------------------------------------------------*/
/* sct+20=>nextsct or '00000010'x.                                   */
/*-------------------------------------------------------------------*/
    Thissct = Swareq(Storage(D2x(thissct+20),3))
  End
  Return

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
/* Post processing cleanup, if necessary. None required this time.   */
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
Term_condcode:
  High_Cond = Strip(Strip(High_Cond,"L"," "),"L","R")
  Say "JOB="jctjname"("ssibjbid") JCTACODE="c2x(Jctacode),
    "FAIL="jctjfail "STAT="Job_Stat
  Say left(" ",22) "LASTABEND="Last_Abend,
    "HIGHESTCOND="High_cond
  Say left("Step.ProcStep",30) left("Program",9) " Code"
  Do while Queued() > 0
    parse pull stepline
    say stepline
  end
  Return

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
  Place any of your subroutines and procedures below this.
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
rexx_jobspecs:
  /*---------------------------------------------------------------*/
  /* ADDRESSABILITY TO CVT FROM PSA                                */
  /*---------------------------------------------------------------*/
  PTR2PSA = 0
  CVTPTR = STORAGE(D2X(PTR2PSA + 16),4)
  /*---------------------------------------------------------------*/
  /* ADDRESSABILITY TO SMCA, THEN GET SMF SYSTEM ID                */
  /*---------------------------------------------------------------*/
  CVTSMCA = STORAGE(D2X(C2D(CVTPTR)+197),3)
  SMFID = STORAGE(D2X(C2D(CVTSMCA)+16),4)
  /*---------------------------------------------------------------*/
  /* GET JOBNAME, STEP, AND PROCEDURE                              */
  /*---------------------------------------------------------------*/
  PSATOLD  = STORAGE(21C,4)                    /* POINTER TO TCB   */
  PTRTIOT  = STORAGE(D2X(C2D(PSATOLD)+12),4)   /* POINTER TO TIOT  */
  JOBNAME  = STORAGE(D2X(C2D(PTRTIOT)),8)
  STEPNAME = STORAGE(D2X(C2D(PTRTIOT)+8),8)
  PROCNAME = STORAGE(D2X(C2D(PTRTIOT)+16),8)
  Tcbjscbb = Storage(D2x(C2d(Psatold)+181),3)                /* jscb */
  jscbssib = STORAGE(D2X(C2D(tcbjscbb)+316),4)        /* Ptr to SSIB */
  ssibjbid = STORAGE(D2X(C2D(jscbssib)+12),8)      /* job identifier */
  Return JOBNAME SSIBJBID STEPNAME PROCNAME

/*===================================================================*/
/* Other called routines                                             */
/*===================================================================*/

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   SWAREQ - AUTHOR   = Gilbert Saint-flour <gsf@pobox.com>
     Ken says - If argument is below (not sure what that means),
                add 16. Otherwise, access the QMPL and add QMATs.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
SwaReq:  Procedure
  If (Right(C2x(Arg(1)),1) >< 'F') Then,  /* Swa=Below ?             */
    Do
      Result = C2d(Arg(1))+16          /* Yes, Return Arg(1)+16      */
      Return Result
    End
  sva = c2d(Arg(1))                            /* Convert to decimal */
  tcb = c2d(storage(d2x(540),4))                 /* Return a pointer */
  jscb = c2d(storage(d2x((tcb+180)),4))          /* Return a pointer */
  qmpl = c2d(storage(d2x((jscb+244)),4))         /* Return a pointer */
  qmat = c2d(storage(d2x((qmpl+24)),4))          /* Return a pointer */
  Do While sva > 65536
    qmat = c2d(storage(d2x((qmat+12)),4))        /* Return a pointer */
    sva = sva - 65536                          /* 010006F -> 000006F */
  End
  Return c2d(storage(d2x(qmat+sva+1),4))+16      /* Return a pointer */

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
__DATA__
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
./ ADD NAME=DDBYCBLK 0666-07208-07208-2246-00001-00001-00000-DIR2UPDT
rexx_ddbycblk:   /*   REXX */
  ddbycblk_version = "01.00"
  arg match_dd .
  Numeric Digits 12
  sp8 = Copies(" ",8)
  ds8 = Copies("-",8)
  erc = 0
  /*
  parse value SYSVAR("SYSCPU") SYSVAR("SYSSRV") with b_cpu b_srv
  */
  grc = get_alc()    /* Run through control blocks */
  grc = dsp_alc()
  /*
  parse value SYSVAR("SYSCPU") SYSVAR("SYSSRV") with e_cpu e_srv
  SAY "AFTER  SELECT" right(sp8||e_cpu,8) right(sp8||e_srv,8)
  SAY "BEFORE SELECT" right(sp8||b_cpu,8) right(sp8||b_srv,8)
  SAY "             " right(ds8,8) right(ds8,8)
  SAY "BEFORE SELECT" right(sp8||(e_cpu-b_cpu),8),
    right(sp8||(e_srv-b_srv),8)
  */
  return erc

dsp_alc:
  select
    when ((match_dd >< "") & (match_dd >< "*")) then,
      do
        dd# = dd_nnbr.match_dd
        dn= dd_name.dd#
        say "DDNAME(" dn ")"
        nd =    dsname.dd#.0
        do ds# = 1 to nd
          say copies(" ",8) dsname.dd#.ds#
        end
        erc = nd
      end
    when (match_dd = "*") then,
      do
        say "All ddnames allocated"
        do dd# = 1 to dd_names
          dn= dd_name.dd#
          say "DDNAME(" dn ")"
          nd =    dsname.dd#.0
          do ds# = 1 to nd
            if ((dn = match_DD) | (match_dd = "*")) then,
              say copies(" ",8) dsname.dd#.ds#
          end
        end
        erc = dd_names
      end
    otherwise
      erc = dd_names
      do dd# = 1 to dd_names
        dn= dd_name.dd#
        nd =    dsname.dd#.0
        erc = erc";"dd#";"dn";"nd
        do ds# = 1 to nd
          erc = erc";"ds#";"dsname.dd#.ds#
        end
      end
  end
  return erc

get_alc:
  PSATOLD  = STORAGE(21C,4)                      /* POINTER TO TCB  */
  PTRTIOT  = STORAGE(D2X(C2D(PSATOLD)+12),4)     /* POINTER TO TIOT */
  tiotptr  = D2C(C2D(PTRTIOT)+24)                /* TIOT pointer    */
  tiotelen = c2d(STORAGE(D2X(C2D(tiotptr)+0),1))
  dd_names = 0
  do while tiotelen > 0
    tiotflag = c2d(STORAGE(D2X(C2D(tiotptr)+1),1))
    tiotddnm = STORAGE(D2X(C2D(tiotptr)+4),8)
    IF BITAND(tiotflag,'80'X) = '80'X THEN,      /* active ddname  */
      do
        if tiotddnm = copies("00"x,8) then,
          do
            Leave
          end
        if tiotddnm >< "        " then,
          do
            dd_name = strip(tiotddnm,"B"," ")
            dd_names = dd_names + 1
            dd_name.dd_names = dd_name
            dd_nnbr.tiotddnm = dd_names
            dsname.dd_names.0 = 0
          end
          tioejfcb = storage(d2x(c2d(tiotptr)+12),3)
          jfcb = swareq(tioejfcb)
          TIOESTTC = storage(d2x(c2d(tiotptr)+15),1)
          TIOESTTB = storage(d2x(c2d(tiotptr)+16),1)
          TIOEFSRT = storage(d2x(c2d(tiotptr)+17),3) /* ucb addr */
          JFCBDSN   = strip(storage(d2x(jfcb+000),44),"B"," ")
/*        say jfcbdsn c2x(storage(c2x(tioefsrt),16))             */
          JFCBELNM  = strip(storage(d2x(jfcb+044),8),"B"," ")
          if jfcbelnm >< "" then,
            fullname = jfcbdsn"("jfcbelnm")"
          else,
            fullname = jfcbdsn
          ds_temp = dsname.dd_names.0 + 1
          dsname.dd_names.0 = ds_temp
          dsname.dd_names.ds_temp = fullname
      end
    tiotptr = D2C(C2D(tiotptr)+tiotelen)
    tiotelen = c2d(STORAGE(D2X(C2D(tiotptr)+0),1))
  end
  return dd_names

/*-------------------------------------------------------------------*/
swareq:   Procedure
  If right(c2x(Arg(1)),1) >< 'F' Then  /* Swa=Below ?                */
    Return c2d(Arg(1))+16              /* Yes, return sva+16         */
  sva = c2d(Arg(1))                    /* Convert to decimal         */
  tcb = ptr(540)                       /* Tcb psatold                */
  jscb = ptr(tcb+180)                  /* Jscb tcbjscb               */
  qmpl = ptr(jscb+244)                 /* Qmpl jscbqmpi              */
  qmat = ptr(qmpl+24)                  /* Qmat qmadd                 */
  Do While sva>65536
    qmat = ptr(qmat+12)                /* Next qmat qmat+12          */
    sva=sva-65536                      /* 010006F -> 000006F         */
  End
  Return ptr(qmat+sva+1)+16

/*-------------------------------------------------------------------*/
ptr:
  Return c2d(storage(d2x(Arg(1)),4))     /* Return a pointer         */
./ ADD NAME=DDBYLSTA 0666-07208-07208-2246-00001-00001-00000-DIR2UPDT
rexx_ddbylsta:   /*   REXX */
  ddbylsta_version = "01.00"
  arg match_dd .
  Numeric Digits 12
  sp8 = Copies(" ",8)
  ds8 = Copies("-",8)
  erc = 0
  /*
  parse value SYSVAR("SYSCPU") SYSVAR("SYSSRV") with b_cpu b_srv
  */
  grc = get_alc()    /* Run through control blocks */
  grc = dsp_alc()
  /*
  parse value SYSVAR("SYSCPU") SYSVAR("SYSSRV") with e_cpu e_srv
  SAY "AFTER  SELECT" right(sp8||e_cpu,8) right(sp8||e_srv,8)
  SAY "BEFORE SELECT" right(sp8||b_cpu,8) right(sp8||b_srv,8)
  SAY "             " right(ds8,8) right(ds8,8)
  SAY "BEFORE SELECT" right(sp8||(e_cpu-b_cpu),8),
    right(sp8||(e_srv-b_srv),8)
  */
  return erc

dsp_alc:
  select
    when ((match_dd >< "") & (match_dd >< "*")) then,
      do
        dd# = dd_nnbr.match_dd
        dn= dd_name.dd#
        say "DDNAME(" dn ")"
        nd =    dsname.dd#.0
        do ds# = 1 to nd
          say copies(" ",8) dsname.dd#.ds#
        end
        erc = nd
      end
    when (match_dd = "*") then,
      do
        say "All ddnames allocated"
        do dd# = 1 to dd_names
          dn= dd_name.dd#
          say "DDNAME(" dn ")"
          nd =    dsname.dd#.0
          do ds# = 1 to nd
            if ((dn = match_DD) | (match_dd = "*")) then,
              say copies(" ",8) dsname.dd#.ds#
          end
        end
        erc = dd_names
      end
    otherwise
      erc = dd_names
      do dd# = 1 to dd_names
        dn= dd_name.dd#
        nd =    dsname.dd#.0
        erc = erc";"dd#";"dn";"nd
        do ds# = 1 to nd
          erc = erc";"ds#";"dsname.dd#.ds#
        end
      end
  end
  return erc

get_alc:
  rc = Outtrap("ln.")                 /* open trap                  */
  "LISTALC STATUS"
  rc = Outtrap("OFF")                 /* close trap                 */
  dd_names = 0

/*    Sample output from listalc status

--DDNAME---DISP--
SYS1.HELP
  SYSHELP  KEEP
SYS1.BRODCAST
  SYSLBC   KEEP
TERMFILE  SYSTERM
KET2812.IDAT.ISPF.ISPPROF
  ISPPROF  KEEP
KET2812.ISPLLIB
  ISPLLIB  KEEP
SYS1.DGTLLIB
           KEEP
SYS1.SCBDHENU
           KEEP
KET2812.ISPMLIB
  ISPMLIB  KEEP
SYS1.ISP.SISPMENU
           KEEP
SYS1.ISF.SISFMLIB
           KEEP
SYS1.DGTMLIB
           KEEP

trace ?irs
*/
  do trapx = 2 to ln.0                  /* skip heading         */
    ln.trapx = space(ln.trapx)
    parse var ln.trapx tempname tempddnm
    select
      When (tempddnm >< " ") then,
        do
          parse var ln.trapx fullname tiotddnm
          dd_names = dd_names + 1       /* DDName index         */
          dd_name.dd_names = tiotddnm
          dd_nnbr.tiotddnm = dd_names
          dsname.dd_names.0 = 0
          ds_temp = dsname.dd_names.0 + 1
          dsname.dd_names.0 = ds_temp
          dsname.dd_names.ds_temp = fullname
        end
      When ((left(ln.trapx,3) >< " ") &,
            (Words(ln.trapx) = 1)) then,
        do
          parse var ln.trapx fullname .
          trapx = trapx + 1
          ln.trapx = space(ln.trapx)
          parse var ln.trapx tempddnm " " final_disp " " .
          if ((tempddnm >< " ") &,
              (final_disp >< " ")) then
            do
              tiotddnm = tempddnm
              dd_names = dd_names + 1   /* DDName index         */
              dd_name.dd_names = tiotddnm
              dd_nnbr.tiotddnm = dd_names
              dsname.dd_names.0 = 0
            end
          ds_temp = dsname.dd_names.0 + 1
          dsname.dd_names.0 = ds_temp
          dsname.dd_names.ds_temp = fullname
        end
      Otherwise
        say "*ERR*" ln.trapx
    end
  end                                 /* trapx                      */
  return dd_names
./ ADD NAME=DDBYQLIB 0666-07208-07208-2246-00001-00001-00000-DIR2UPDT
rexx_ddbyqlib: /* rexx */
  ddbyqlib_version = "01.00"
  parse arg ddname .
  If (ddname = "") Then ddname = "SYSPROC"
  parse source . . . me .
  say me "starting..."
  Address ISPexec "CONTROL ERRORS RETURN"
  Address ISPexec,
    "QBASELIB" ddname "ID(IDVAR)"
  q_rc = rc
  If (q_rc >< 0) Then,  /* Return codes                               */
                        /*  4  - Specified dd-name is not defined     */
                        /*                                            */
                        /* 16  - Dialog variable translation or       */
                        /*       truncation error.                    */
                        /* 20 -  Severe error.                        */
    Do
      say "Nope, RC("q_rc")."
    End
  Else,
    Do
      Do while IDVAR >< ""
        parse var IDVAR dsn "," IDVAR
        say dsn
      End
    End
  say "Ending" me"..."
  exit 0
./ ADD NAME=DDBYTSTR 0666-07208-07208-2247-00001-00001-00000-DIR2UPDT
rexx_ddbytstr: /* rexx */
  ddbytstr_version = "01.00"
  parse arg ddname type
  allcblk = ddbycblk()
  alllsta = ddbylsta()
  alltrap = ddtrap("*" "DSN")
  select
    when ((alltrap == allcblk) & (allcblk == alllsta)) then
      do
        say "Wow, can you imagine that!"
      end
    when ((alltrap == allcblk) & (allcblk >< alllsta)) then
      do
        say "DDTRAP == DDBYCBLK >< DDBYLSTA"
        say copies("-",79)
        say Left(copies("-allcblk-",20),79)
        say copies("-",79)
        say allcblk
        say copies("-",79)
        say Left(copies("-alllsta-",20),79)
        say copies("-",79)
        say alllsta
        say copies("-",79)
      end
    when ((alltrap >< allcblk) & (allcblk == alllsta)) then
      do
        say "DDTRAP >< DDBYCBLK == DDBYLSTA"
        say "I am not surprised, DDTRAP was poorly written!"
        say "It only finds DDNAMEs with datasets allocated to it."
        say copies("-",79)
        say Left(copies("-alltrap-",20),79)
        say copies("-",79)
        say alltrap
        say copies("-",79)
        say Left(copies("-allcblk-",20),79)
        say copies("-",79)
        say allcblk
        say copies("-",79)
      end
    Otherwise
      say "This is the worst choice!"
      say "DDTRAP >< DDBYCBLK >< DDBYLSTA"
      say "Check the results carefully, you likely had"
      say "some temporary DDNAME allocated in between runs."
      say copies("-",79)
      say Left(copies("-alltrap-",20),79)
      say copies("-",79)
      say alltrap
      say copies("-",79)
      say Left(copies("-allcblk-",20),79)
      say copies("-",79)
      say allcblk
      say copies("-",79)
      say Left(copies("-alllsta-",20),79)
      say copies("-",79)
      say alllsta
      say copies("-",79)
  end
  allofit = allcblk
  call de_parse
  find_dd = "SYSEXEC"
  netrc_dd = tiotddnm.find_dd
  if (netrc_dd >< "") then,
    do
      say "NETRC("netrc_dd")"
      netrc_dsns = dd_dsname.netrc_dd.0
      do ds_x = 1 to netrc_dsns
        say "  DSN="dd_dsname.netrc_dd.ds_x
      end

    end
  else,
    say "//NETRC is not allocated"
  return 0
  call show_it

show_it:
  say ""
  say copies("=",79)
  say "D D T R A P"
  allofit = alltrap
  do while allofit >< ""
    parse var allofit someofit ";" allofit
    say someofit
  end

  say ""
  say copies("=",79)
  say "D D B Y C B L K"
  allofit = allcblk
  do while allofit >< ""
    parse var allofit someofit ";" allofit
    say someofit
  end

  say ""
  say copies("=",79)
  say "D D B Y L S T A"
  allofit = alllsta
  do while allofit >< ""
    parse var allofit someofit ";" allofit
    say someofit
  end
  return

/* #dds;dd#;ddname;#dsn;dsn#;dsname;...                        */
de_parse:
  tiotddnm. = ""
  tiotddnm.0 = 0
  parse var allofit nbr_dds ";" allofit
  do dd_x = 1 to nbr_dds
    parse var allofit dd_nbr ";" dd_name ";" nbr_dsns ";" allofit
    tiotddnm.dd_name = dd_x
    dd_dsname.dd_x. = ""
    do ds_x = 1 to nbr_dsns
      parse var allofit ds_nbr ";" ds_name ";" allofit
      dd_dsname.dd_x.ds_x = ds_name
    end
    dd_dsname.dd_x.0 = ds_x - 1
  end
  tiotddnm.0 = dd_x - 1
  return
./ ADD NAME=DDTRAP   0666-07208-07208-2221-00001-00001-00000-DIR2UPDT
ddtrap: /* rexx */
/*
 DISCLAIMER: I found this code on the internet. It is poorly
 written. It shows the pitfall of using code you find. Know
 your source. Test. Confirm it functions as it ought to.

 I found this is only useful for finding ddnames with data sets
 allocated to it. That leaves a bunch of DDnames unaccounted for.
 Like DD DUMMY!

It is included only for the method they tried to use. Go check
ddbylsta for a complete capture and then go check out ddbycblk
for the quicker version.

*/

  parse arg find_dd JCLorDSN .
  rc = Outtrap("ln.")                 /* open trap                  */
  "LISTALC STATUS"
  rc = Outtrap("OFF")                 /* close trap                 */
  ddn# = 0

/* Build DDName stack                          */
  do trapx = 1 to ln.0                /* for each trapped line      */
    if Left(ln.trapx,1) <> "" then,   /* DSName                     */
      iterate                         /* pick it up later           */
    if Substr(ln.trapx,3,1) <> " " then,   /* new DDName            */
      do
        ddn#       = ddn# + 1         /* DDName index               */
        actual_ddn = Word(ln.trapx,1) /* save DDName                */
        ddn.ddn#   = actual_ddn
        ddname.actual_ddn = ddn#
        ddnnbr.ddn#  = trapx
        start.ddn# = trapx - 1        /* 1st dsn on previous line   */
        end.ddn#   = trapx - 1        /* ...maybe the last one, too */
      end
    else if Left(ln.trapx,1) = " " then,     /* concatenated DSName */
      end.ddn#     = trapx - 1        /* new end-point              */
  end                                 /* trapx                      */

  erc = ddn#
  select
    when ((JCLorDSN = "DSN") &,
          (datatype(ddname.find_dd) = "NUM")) then,
      do
        ddnx = ddname.find_dd
        totdsnx =  ((end.ddnx - start.ddnx) / 2) + 1
        erc = erc";"totdsnx
        do dsnx = start.ddnx to end.ddnx by 2
          erc = erc";"ln.dsnx
        end
      end

    when ((JCLorDSN = "ALC") &,
          (datatype(ddname.find_dd) = "NUM")) then,
      do
        ddnx = ddname.find_dd
        totdsnx =  ((end.ddnx - start.ddnx) / 2) + 1
        erc = erc";"totdsnx
      end

    when ((JCLorDSN = "JCL") &,
          (datatype(ddname.find_dd) = "NUM")) then,
      do
        ddnx = ddname.find_dd
        totdsnx =  ((end.ddnx - start.ddnx) / 2) + 1
        erc = erc";"totdsnx
        do dsnx = start.ddnx to end.ddnx by 2
          if (dsnx = start.ddnx) then,
            do
              xdsn = 1
              erc = erc";"||,
                "//"left(find_dd,8) "DD  DISP=SHR,DSN="ln.dsnx,
                 "   " ddnx"."xdsn
            end
          else,
            do
              xdsn = xdsn + 1
              erc = erc";"||,
                "//"copies(" ",8) "DD  DISP=SHR,DSN="ln.dsnx,
                 "   " ddnx"."xdsn
            end
        end
      end

    when ((JCLorDSN = "DSN") &,
          (find_dd = "*")) then,
      do
        erc = ddn#
        do ddnx = 1 to ddn#
          find_dd = ddn.ddnx
          ddnx = ddname.find_dd
          erc = erc";"ddnx";"find_dd
          totdsnx =  ((end.ddnx - start.ddnx) / 2) + 1
          erc = erc";"totdsnx
          thisdsn = 0
          do dsnx = start.ddnx to end.ddnx by 2
            thisdsn = thisdsn + 1
            erc = erc";"thisdsn";"ln.dsnx
          end
        end
      end

    when ((JCLorDSN = "JCL") &,
          (find_dd = "*")) then,
      do
        erc = ddn#
        do ddnx = 1 to ddn#
          find_dd = ddn.ddnx
          ddnx = ddname.find_dd
          erc = erc";"find_dd
          totdsnx =  ((end.ddnx - start.ddnx) / 2) + 1
          erc = erc";"totdsnx
          do dsnx = start.ddnx to end.ddnx by 2
            if (dsnx = start.ddnx) then,
              do
                xdsn = 1
                erc = erc";"||,
                  "//"left(find_dd,8) "DD  DISP=SHR,DSN="ln.dsnx,
                   "   " ddnx"."xdsn
              end
            else,
              do
                xdsn = xdsn + 1
                erc = erc";"||,
                  "//"copies(" ",8) "DD  DISP=SHR,DSN="ln.dsnx,
                   "   " ddnx"."xdsn
              end
          end
        end
      end
    otherwise
      erc = erc";0;**ERROR"
  end
  return erc
./ ADD NAME=FTPCANCL 0666-07213-07213-1930-00001-00001-00000-DIR2UPDT
rexx_FTPCANCL: /* We still need rexx in comment if read from SYSPROC */
  rexxpgm_version = "01.01"
/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

  Dataset: REXX(FTPCANCL)
  Author:  "Kenneth Tomiak"<CBT_Ken@KTomiak.biz>
  Syntax:  BATCHISP {arguments ...}

=======================================================================

  History of Modifications
  ------------------------
  When     Who      What you did
  -------- -------- ---------------------------------------------------
  20070729 KTomiak  01.01 Standardizing FILE760 format.
  20011119 KTomiak  01.00 Original code

=======================================================================

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */

  Parse Arg all_my_arguments
  Numeric Digits 12

rexx_Main_BATCHISP:
  return_code = rexx_Initialize()
  If (return_code = 0) then,
    Do
      return_code = rexx_Process()
      return_code = rexx_Termination()
    End
   Return 0

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
  In this routine we open any files and intialize any
  constants we might need.
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
rexx_Initialize:
  PARSE VERSION,
    version_rexx_name,
    version_rexx_version,
    version_rexx_date
  PARSE SOURCE,
    source_host_env,
    source_call_type,
    source_uc_exec_name,
    source_hostdd,
    source_hostdsn,
    source_nf_exec_name,
    source_initial_cmd_env,
    source_asid_name,
    source_char8_user_token,
    source_hostother
  Address_Environment = Address()
  job_specs = rexx_jobspecs()
  say ""
  say Copies("=",55)
  say left("=" source_uc_exec_name rexxpgm_version,53) "="
  say left("=" "executing under" source_host_env,53) "="
  say left("=" "as a" source_call_type,53) "="
  say left("=  on" date() "at" time()".",53) "="
  say Copies("=",55)
  say ""
  return_code = 0
  sysvar_sysuid=SYSVAR("SYSUID")

  If (source_host_env >< "TSO") Then,
    Do
      Say "Wrong host environment" source_host_env
      return_code = 16
    End

  Return return_code

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
  In this routine we do our processing.
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
rexx_Process:
  parse arg site password
  sys_sysuid = SYSVAR("SYSUID")
  "NEWSTACK"
  queue sys_sysuid
  queue password
  queue "QUOTE SITE FILETYPE=JES"
  queue "put ZOSCNTL(CANCELME)"
  queue "quit"
  quiet = Outtrap("HLP.")
  "ftp" site
  return_code = RC
  quiet = Outtrap("OFF")
  ftpin = Queued()
  do ix = 1 to ftpin
    parse pull dline
    say dline
  end
  do ix = 1 to hlp.0
    say hlp.ix
  end
  "DELSTACK"
  Return return_code

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
  In this routine we close files and finish up.
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
rexx_Termination:
  say ""
  Say "Ending with return code=" return_code
  say ""
  say copies(" =",39)
  say ""
  Return Return_code

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
  Place any of your subroutines and procedures below this.
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
rexx_jobspecs:
  /*---------------------------------------------------------------*/
  /* ADDRESSABILITY TO CVT FROM PSA                                */
  /*---------------------------------------------------------------*/
  PTR2PSA = 0
  CVTPTR = STORAGE(D2X(PTR2PSA + 16),4)
  /*---------------------------------------------------------------*/
  /* ADDRESSABILITY TO SMCA, THEN GET SMF SYSTEM ID                */
  /*---------------------------------------------------------------*/
  CVTSMCA = STORAGE(D2X(C2D(CVTPTR)+197),3)
  SMFID = STORAGE(D2X(C2D(CVTSMCA)+16),4)
  /*---------------------------------------------------------------*/
  /* GET JOBNAME, STEP, AND PROCEDURE                              */
  /*---------------------------------------------------------------*/
  PSATOLD  = STORAGE(21C,4)                    /* POINTER TO TCB   */
  PTRTIOT  = STORAGE(D2X(C2D(PSATOLD)+12),4)   /* POINTER TO TIOT  */
  JOBNAME  = STORAGE(D2X(C2D(PTRTIOT)),8)
  STEPNAME = STORAGE(D2X(C2D(PTRTIOT)+8),8)
  PROCNAME = STORAGE(D2X(C2D(PTRTIOT)+16),8)
  Tcbjscbb = Storage(D2x(C2d(Psatold)+181),3)                /* jscb */
  jscbssib = STORAGE(D2X(C2D(tcbjscbb)+316),4)        /* Ptr to SSIB */
  ssibjbid = STORAGE(D2X(C2D(jscbssib)+12),8)      /* job identifier */
  Return JOBNAME SSIBJBID STEPNAME PROCNAME

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
__DATA__
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
./ ADD NAME=FTPSYNC  0666-07213-07213-1944-00001-00001-00000-DIR2UPDT
rexx_FTPSYNC:  /* We still need rexx in comment if read from SYSPROC */
  rexxpgm_version = "01.00"
/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

  Dataset: REXX(FTPSYNC)
  Author:  KTomiak
  Contact: "Kenneth Tomiak"<KenTomiak@KTomiak.org>
  Syntax:  FTPSYNC {arguments ...}

=======================================================================

  History of Modifications
  ------------------------
  When     Who      VV Mm What you did
  -------- -------- ----- ---------------------------------------------
  20070330 KTomiak  01.00 Original code


=======================================================================

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */

  Parse Arg all_my_arguments
  Numeric Digits 18

rexx_Main_FTPSYNC:
  return_code = rexx_Initialize()
  If (return_code = 0) then,
    Do
      return_code = rexx_Process()
      return_code = rexx_Termination()
    End
   Return 0

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
  In this routine we open any files and intialize any
  constants we might need.
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
rexx_Initialize:
  PARSE VERSION,
    version_rexx_name,
    version_rexx_version,
    version_rexx_date
  PARSE SOURCE,
    source_host_env,
    source_call_type,
    source_uc_exec_name,
    source_hostdd,
    source_hostdsn,
    source_nf_exec_name,
    source_initial_cmd_env,
    source_asid_name,
    source_char8_user_token,
    source_hostother
  Address_Environment = Address()
  job_specs = rexx_jobspecs()
  say ""
  say Copies("=",55)
  say left("=" source_uc_exec_name rexxpgm_version,53) "="
  say left("=" "executing under" source_host_env,53) "="
  say left("=" "as a" source_call_type,53) "="
  say left("=  on" date() "at" time()".",53) "="
  say Copies("=",55)
  say ""
  return_code = 0
  sysvar_sysuid = SYSVAR("SYSUID")
  mvs_sysname   = MVSVAR("SYSNAME")
  mvs_opsys     = MVSVAR("SYSOPSYS")
  mvs_sysname   = MVSVAR("SYSNAME")
  Address ISPEXEC "VGET (ZPREFIX)"
  old_trap = OutTrap("RACF.")
  "listuser" sys_sysuid
  new_trap = OutTrap("OFF")
  sys_username = sys_sysuid"@"mvs_sysname
  if (racf.0 > 0) then,
    do ix = 4 to racf.0
      if (pos("INSTALLATION-DATA",racf.ix) > 0) then,
        do
          parse var racf.ix . "=" sys_username
          sys_username = strip(sys_username)
          leave
        end
    end
  msg1 = sys_username
  say ""
  say Copies("=",55)
  say left("=" source_uc_exec_name,
    "executing under" source_host_env,
    "as a" source_call_type,53) "="
  say left("=  on" date() "at" time()".",53) "="
  say Copies("=",55)
  trace o
  signal on halt
  signal on syntax
  call init_workareas
  call parse_parameters
  Return 0

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
  In this routine we do our processing.
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
rexx_Process:
  Address IspExec "CONTROL ERRORS RETURN"
  call ftp_sync_main
  Return 0

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
  In this routine we close files and finish up.
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
rexx_Termination:
  Return 0

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
  Place any of your subroutines and procedures below this.
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
parse_parameters:
  if (pos("=",all_my_arguments) > 0) then,
    parse var all_my_arguments .,
      "DSNL=" locfile " ",
      0 .,
      "DSNR=" rmtfile " ",
      0 .,
      "SITE=" server " ",
      0 .,
      "WHEN=" topswd " ",
      0 .,
      "USER=" touser " ",
      0 .,
      "QUIET=" quiet_option " ",
      0 .,
      "DEBUG=" debug_option " ",
      0 .,
      "TRACE=" trcopts " ",
      0 .
  else,
    parse var all_my_arguments,
      locfile " ",
      rmtfile " ",
      server " ",
      touser " ",
      topswd " ",
      quiet_option " ",
      debug_option " ",
      trcopts
  if (trcopts >< "") then,
    do
      interpret "trace" trcopts
    end
  if (debug_option >< "") then,
    do
      say "SITE:" server"."
      say "USER:" touser":"topswd"."
      say "Local DSN" locfile"."
      say "Remote DSN" rmtfile"."
    end
  if (locfile >< "") then,
    do
      ck_loc = check_file("L" locfile)
      if (word(ck_loc,1) >< "0") then,
        do
          msg1 = "LOCFILE("locfile") not valid," word(ck_loc,1)
          signal ftp_sync_main
        end
      locfile = word(ck_loc,2)
    end
  if (rmtfile = "") then,
    do
      rmtfile = locfile
    end
  return

ftp_sync_main:
  if (trcopts >< "") then,
    do
      interpret "trace" trcopts
    end
  ck_loc = check_file("L" locfile)
  if (word(ck_loc,1) >< "0") then,
    do
      msg1 = "LOCFILE("locfile") not valid," word(ck_loc,1)
      signal ftp_sync_main
    end
  locfile = word(ck_loc,2)
  call alloc_report
  call get_local
  if (mycc >< 0) then
    do
      say zerrlm
    end
  call get_remote_listing
  call free_report
  return

check_file: Procedure
  parse arg myargs
  parse var myargs loc myfile
  myfile = strip(myfile,"B","'")
  X = LISTDSI("'"myfile"'" DIRECTORY)
  return x myfile

alloc_report:
  do rpt_ix = 0 to 99
    rpt_dd = "RPTS"RIGHT("0000"rpt_ix,4)
    Address ISPexec,
      "QBASELIB" ddname "ID(IDVAR)"
    q_rc = rc
    If (q_rc = 4) Then,   /* Return codes                             */
                          /* 4 - Specified dd-name is not defined     */
                          /*                                          */
                          /* 16 - Dialog variable translation or      */
                          /*     truncation error.                    */
                          /* 20 - Severe error.                       */
      Do
        "ALLOC NEW DEL F("rpt_dd") DSO(PS) SP(3,3) TRACK",
          "REUSE RECFM(V B A) BLKSIZE(0) LRECL(137) UNIT(SYSDA)"
        rpt.0 = 0
        rpt.0 = add_rpt("1  "date() Time() "-" source_uc_exec_name)
        rpt.0 = add_rpt(" ")
        rpt.0 = add_rpt(" "left("LOCAL:"mvs_sysname,50),
        left("REMOTE:" server,50))
        rpt.0 = add_rpt(" "left(locfile,50) left(rmtfile,50))
        rpt.0 = add_rpt(" "left(copies('-',44),50),
                           left(copies('-',44),50))
        rpt.0 = add_rpt(" "left("MEMBER   CHG-DATE   TIME ",50),
                            left("MEMBER   CHG-DATE   TIME ",50))
        rpt.0 = add_rpt(" "left("-------- ---------- -----",50),
                            left("-------- ---------- -----",50))
        return
      End
  end
  say "Yikes, 100 reports already in use?"
  return

add_rpt:
  parse arg rptargs
  rpt_ix = rpt.0 + 1
  rpt.rpt_ix = rptargs
  return rpt_ix

add_loc_mbr:
  parse arg mbrname mbrdate mbrtime mbrnorc .
  if (mbrtime >< "") then,
    do
      loc_base = base(mbrtime":00" mbrdate)
      parse var loc_base loc_days loc_seconds loc_stmp
    end
  else,
    loc_stmp = "0"
  loc_ix = loc_mbr.0 + 1
  loc_mbr.loc_ix = left(mbrname,8) mbrdate mbrtime mbrnorc loc_stmp
  return loc_ix

add_rmt_mbr:
  parse arg mbrname mbrdate mbrtime mbrnorc .
  if (mbrtime >< "") then,
    do
      rmt_base = base(mbrtime":00" mbrdate)
      parse var rmt_base rmt_days rmt_seconds rmt_stmp
    end
  else,
    rmt_stmp = "0"
  rmt_ix = rmt_mbr.0 + 1
  rmt_mbr.rmt_ix = left(mbrname,8) mbrdate mbrtime mbrnorc rmt_stmp
  return rmt_ix

free_report:
  if (quiet_option = "QUIET") then,
    do rpt_x = 1 to rpt.0
      say rpt.rpt_x
    End
  else
    do
      "EXECIO" rpt.0 "DISKW" rpt_dd "(FINIS STEM RPT."
      "ISPEXEC LMINIT DATAID(RPTAID) DDNAME("rpt_dd")"
      "ISPEXEC BROWSE DATAID("RPTAID")"
      "ISPEXEC LMCLOSE DATAID("RPTAID")"
      "ISPEXEC LMFREE DATAID("RPTAID")"
    END
  "FREE FILE("rpt_dd")"
  return

get_local:
  MYCTR = 0
  MYCC = RC
  IF (MYCC >< 0) THEN ,
    DO
      ZERRSM = "FILE IN USE"
      ZERRLM = "THE FILE" locfile "IS IN USE"
      ADDRESS ISPEXEC "SETMSG MSG(ISRZ002)"
      return
    END
  ADDRESS ISPEXEC "LMINIT DATAID(PDSMEMID)",
     "DATASET('"locfile"') ENQ(SHR)"
  ADDRESS ISPEXEC "LMOPEN DATAID("PDSMEMID")",
    "OPTION(INPUT)"
  MYCC = RC
  IF (MYCC > 0) THEN ,
    DO
      ZERRSM = "FILE FAILED TO OPEN"
      ZERRLM = "THE FILE" locfile "FAILED TO OPEN RC="MYCC
      ADDRESS ISPEXEC "SETMSG MSG(ISRZ002)"
      return
    END
  PDSMBR = ""
  mycc = 0
  do until mycc >< 0
    ADDRESS ISPEXEC "LMMLIST DATAID("PDSMEMID")",
      "OPTION(LIST) MEMBER(PDSMBR) STATS(YES)"
    MYCC = RC
    IF (MYCC > 0) THEN ,
      DO
        leave
      END
    MYCTR = MYCTR + 1
    loc_mbr.0 = add_loc_mbr(LEFT(PDSMBR,8) ZLM4DATE ZLMTIME ZLCNORC)
  end
  mycc = 0
  zerrlm = ""
  ADDRESS ISPEXEC "LMMLIST DATAID("PDSMEMID") OPTION(FREE)"
  ADDRESS ISPEXEC "LMCLOSE DATAID("PDSMEMID")"
  ADDRESS ISPEXEC "LMFREE DATAID("PDSMEMID")"
  Return

ftp_sync_pds:
  NEWSTACK
  if (touser >< "") then,
    queue touser
  if (topswd >< "") then,
    queue topswd
  queue "type E"
  queue "mode B"
  queue "QUOTE SITE ISPFSTATS"
  queue "lcd '"locfile"'"
  queue "cd '"rmtfile"'"
  do ftp_ix = 1 to ftp_cmd.0
    queue ftp_cmd.ftp_ix
  end
  queue "dir"
  queue "quit"
  ftp_out_dd = "FTPO"RIGHT("0000"RANDOM(99999),4)
  ftp_out_dd = "OUTPUT"
  "ALLOC FILE("ftp_out_dd") SPACE(5 5) RECFM(F B)",
    "BLKSIZE(0) LRECL(80) DSORG(PS) NEW DELETE",
    "UNIT(SYSALLDA) DIR(0)"
  quietly = Outtrap("FTP.")
  "ftp" towhere
  quietly = Outtrap("OFF")
  ftpin = Queued()
  do ix = 1 to ftpin
    parse pull dline
    say " *****ERROR*****" dline
  end
  DELSTACK
  "EXECIO * DISKR OUTPUT (FINIS STEM FTPO."
  "Free file(OUTPUT)"
  if (quiet_option >< "QUIET") then
  do ix = 1 to ftpo.0
    if (left(ftpo.ix,3) = "EZA") then iterate
    rpt.0 = add_rpt(" "ftpo.ix)
  end
  Return

get_remote_listing:
  NEWSTACK
  if (touser >< "") then,
    queue touser
  if (topswd >< "") then,
    queue topswd
  queue "cd '"rmtfile"'"
  queue "dir"
  queue "quit"
  towhere = server
  if (uc(server) = "IPCO") then towhere = "172.23.22.20"
  if (uc(server) = "IDAT") then towhere = "172.23.22.21"
  if (uc(server) = "ISYS") then towhere = "172.23.22.22"
  if (uc(server) = "IDEV") then towhere = "172.23.22.23"
  ftp_out_dd = "FTPO"RIGHT("0000"RANDOM(99999),4)
  ftp_out_dd = "OUTPUT"
  "ALLOC FILE("ftp_out_dd") SPACE(5 5) RECFM(F B)",
    "BLKSIZE(0) LRECL(80) DSORG(PS) NEW DELETE",
    "UNIT(SYSALLDA) DIR(0)"
  quietly = Outtrap("FTP.")
  my_time_now = Time() date("S")
  "ftp" towhere
  quietly = Outtrap("OFF")
  parse var my_time_now,
    now_hh ":",
    now_mm ":",
    now_ss " ",
    .      +1,
    now_yr +4,
    now_mo +2,
    now_dy +2,
    .
  my_time = now_hh":"now_mm":"now_ss
  my_date = now_yr"/"now_mo"/"now_dy
  host_base = Base(my_time my_date)
  parse var host_base host_base_days host_base_seconds host_timestamp
  ftpin = Queued()
  do ix = 1 to ftpin
    parse pull dline
    rpt.0 = add_rpt(" *****ERROR*****" dline)
  end
  DELSTACK
  "EXECIO * DISKR OUTPUT (FINIS STEM FTPO."
  "Free file(OUTPUT)"
  do ix = 1 to ftpo.0
    if (left(ftpo.ix,4) = "220-") then call get_site_adjustment
    if (left(ftpo.ix,8) >< "EZA2284I") then iterate
    parse var ftpo.ix,
      eza_msgid membr vermod credt chgdt chgtm chgnorc .
    if (left(membr,8) left(chgdt,10) chgtm =,
      "Name     Changed    Size") then iterate
    rmt_mbr.0 = add_rmt_mbr(LEFT(membr,8) chgdt chgtm chgnorc)
  end
  /*
  */
  if (loc_mbr.0 > rmt_mbr.0) then
    bx = loc_mbr.0 + 1
  else
    bx = rmt_mbr.0 + 1
  lx = 1
  rx = 1
  ftp_cmd.0 = 0
  parse var loc_mbr.lx lmem ldte ltme lnorc lstmp
  parse var rmt_mbr.rx rmem rdte rtme rnorc rstmp
  do Loop_ux = 1 to bx
    do while ((lx < bx) & (rx < bx))
      call compare_stem
    end
  end
  if (ftp_ix > 0) then
    call ftp_sync_pds
  return

compare_stem:
  if ((lmem = "") & (lmem = rmem)) then
    do
      rpt.0 = add_rpt(" " lmem "><" rmem)
      say "Horrible looping about to occur!"
      exit 24
    end
  select
    when (lmem = rmem) then call mbr_equal
    when ((lmem >< "") & (rmem = "")) then call loc_lower
    when ((rmem >< "") & (lmem = "")) then call rmt_lower
    when (lmem < rmem) then call loc_lower
    when (lmem > rmem) then call rmt_lower
    otherwise
      if ((lx > bx) & (rx > bx)) then
        do
          rpt.0 = add_rpt(" " lmem "><" rmem)
          say "Horrible looping about to occur!"
          exit 24
        end
  end
  return

rmt_lower:
  if (rnorc = 0) then,
    do
      rpt.0 = add_rpt("Okay to delete remote "copies(" ",44) " na ",
        left(rmt_mbr.rx,50))
      ftp_ix = ftp_cmd.0 + 1
      ftp_cmd.0 = ftp_ix
      ftp_cmd.ftp_ix = "dele" rmem
    end
  else,
    do
      rpt.0 = add_rpt(" "copies(" ",44) "<GET",
        left(rmt_mbr.rx,50))
      ftp_ix = ftp_cmd.0 + 1
      ftp_cmd.0 = ftp_ix
      ftp_cmd.ftp_ix = "get" rmem
    end
  rx = rx + 1
  parse var rmt_mbr.rx rmem rdte rtme rnorc rstmp
  return

loc_lower:
  if (lnorc = 0) then,
    do
      rpt.0 = add_rpt(" "left(loc_mbr.lx,44) " NA ",
        left("Okay to delete locally ",50))
      call Ispf_lmmdel
    end
  else,
    do
      rpt.0 = add_rpt(" "left(loc_mbr.lx,44) "PUT>",
        copies(" ",50))
      ftp_ix = ftp_cmd.0 + 1
      ftp_cmd.0 = ftp_ix
      ftp_cmd.ftp_ix = "put" lmem
    end
  lx = lx + 1
  parse var loc_mbr.lx lmem ldte ltme lnorc lstmp
  return

mbr_equal:
  select
    when ((lstmp = "") & (rstmp = "")) then,
      do
        rpt.0 = add_rpt(" "left(loc_mbr.lx,44) " ns ",
          left(rmt_mbr.rx,50))
      end
    when (lstmp = rstmp) then,
      do
        rpt.0 = add_rpt(" "left(loc_mbr.lx,44) " == ",
          left(rmt_mbr.rx,50))
      end
    when (rnorc = 0) then,
      do
        rpt.0 = add_rpt(" "left(loc_mbr.lx,44) "Drmt",
          left(rmt_mbr.rx,50))
        ftp_ix = ftp_cmd.0 + 1
        ftp_cmd.0 = ftp_ix
        ftp_cmd.ftp_ix = "dele" lmem
      end
    when (lnorc = 0) then,
      do
        rpt.0 = add_rpt(" "left(loc_mbr.lx,44) "Locd",
          left(rmt_mbr.rx,50))
        rpt.0 = add_rpt("delete '"locfile"("lmem")'")
        call Ispf_lmmdel
      end
    when ((lstmp = "") & (rstmp >< "")) then,
      do
        rpt.0 = add_rpt(" "left(loc_mbr.lx,44) " get",
          left(rmt_mbr.rx,50))
        ftp_ix = ftp_cmd.0 + 1
        ftp_cmd.0 = ftp_ix
        ftp_cmd.ftp_ix = "get" lmem
      end
    when ((rstmp = "") & (lstmp >< "")) then,
      do
        rpt.0 = add_rpt(" "left(loc_mbr.lx,44) " put",
          left(rmt_mbr.rx,50))
        ftp_ix = ftp_cmd.0 + 1
        ftp_cmd.0 = ftp_ix
        ftp_cmd.ftp_ix = "put" lmem
      end
    when (lstmp > rstmp) then,
      do
        rpt.0 = add_rpt(" "left(loc_mbr.lx,44) " >> ",
          left(rmt_mbr.rx,50))
        ftp_ix = ftp_cmd.0 + 1
        ftp_cmd.0 = ftp_ix
        ftp_cmd.ftp_ix = "put" lmem
      end
    when (lstmp < rstmp) then,
      do
        rpt.0 = add_rpt(" "left(loc_mbr.lx,44) " << ",
          left(rmt_mbr.rx,50))
        ftp_ix = ftp_cmd.0 + 1
        ftp_cmd.0 = ftp_ix
        ftp_cmd.ftp_ix = "get" lmem "(REPLACE"
      end
    otherwise
      rpt.0 = add_rpt(" "left(loc_mbr.lx,44) " ?? ",
        left(rmt_mbr.rx,50))
  end
  lx = lx + 1
  parse var loc_mbr.lx lmem ldte ltme lnorc lstmp
  rx = rx + 1
  parse var rmt_mbr.rx rmem rdte rtme rnorc rstmp
  return

ispf_lmmdel:
  return
  Address IspExec,
    "LMINIT DATAID(DELID)",
    "DATASET('"locfile"')",
    "ENQ(SHRW)"
                            /* Return codes                     */
                            /*  8 - Data set or file not        */
                            /*      allocated                   */
                            /*    - DDname not found            */
                            /*    - Data set or file            */
                            /*      organization not supported  */
                            /* 12 - Invalid parameter value     */
                            /* 16 - Truncation or translation   */
                            /*      error in accessing dialog   */
                            /*      variables                   */
                            /* 20 - Severe error                */
  lminit_rc = rc
  if (lminit_rc >< 0) then,
    do
      say "LMINIT RC("lminit_rc") on file("locfile")"
      return
    end
  Address IspExec,
    "LMOPEN DATAID("delid") OPTION(OUTPUT)"
                                /* Return codes                      */
                                /*  8 - Open failed                  */
                                /*    - Data set record format not   */
                                /*      supported by ISPF            */
                                /* 10 - No data set associated with  */
                                /*      the data-id                  */
                                /* 12 - Invalid parameter value      */
                                /*    - Data set is already open     */
                                /*    - Cannot open data set         */
                                /*      allocated "SHR" for output   */
                                /* 16 - Truncation or translation    */
                                /*      error in storing defined     */
                                /*      variables                    */
                                /* 20 - Severe error                 */
  lmOPEN_rc = rc
  if (lmOPEN_rc >< 0) then,
    do
      say "LMOPEN RC("lmOPEN_rc") on file("locfile")"
      return
    end
  Address IspExec,
    "LMMDEL DATAID("DELID")",
    "MEMBER("lmem") NOENQ"
                           /* Return codes                       */
                           /*  4 - Member deleted, maclib/txtlib */
                           /*      erased if it is empty after   */
                           /*      the deletion  (CMS only)      */
                           /*  8 - Member not found              */
                           /* 10 - No data set or data file      */
                           /*      associated with the given     */
                           /*      data-id                       */
                           /* 12 - Data set or data file not     */
                           /*      open or not open for output   */
                           /*    - Invalid parameter value       */
                           /*    - Invalid data set or data file */
                           /*      organization                  */
                           /* 20 - Severe error                  */
  lmmdel_rc = rc
  if (lmmdel_rc >< 0) then,
    do
      say "LMMDEL RC("lmmdel_rc") on member("lmem")"
    end
  Address IspExec,
    "LMCLOSE DATAID("delid")"
                                /* Return codes                     */
                                /*  8  - Data set is not open       */
                                /* 10  - No data set associated     */
                                /*       with the given data id     */
                                /* 20  - Severe error               */
  lmclose_rc = rc
  if (lmclose_rc >< 0) then,
    do
      say "LMCLOSE RC("lmclose_rc") on file("locfile")"
      return
    end
  Address IspExec,
    "LMFREE DATAID("DELID")"
  lmfree_rc = rc
  if (lmfree_rc >< 0) then,
    do
      say "LMFREE RC("lmfree_rc") on file("locfile")"
      return
    end
  return

uc: Procedure
  parse upper arg string
  return string

lc: Procedure
  parse arg string
  string = translate(string,
    "abcdefghijklmnopqrstuvwxyz",
    "ABCDEFGHIJKLMNOPQRSTUVWXYZ")
  return string

an: Procedure expose alpha_numeric all_ebcdic
  parse arg string
  string = translate(string,alpha_numeric,all_ebcdic)
  return string

init_workareas:
  loc_mbr.  = ""
  loc_mbr.0 = 0
  rmt_mbr.  = ""
  rmt_mbr.0 = 0
  all_ebcdic = xrange(x2c("00"),x2c("FF"))
  alpha_numeric = ,
    copies(" ",x2d("6B")-x2d("00"))||,
    "," ||,
    copies(" ",x2d("C1")-x2d("6C"))||,
    "ABCDEFGHI" ||,
    copies(" ",x2d("D1")-x2d("CA"))||,
    "JKLMNOPQR" ||,
    copies(" ",x2d("E2")-x2d("DA"))||,
    "STUVWXYZ" ||,
    copies(" ",x2d("F0")-x2d("EA"))||,
    "0123456789" ||,
    copies(" ",x2d("0100")-x2d("FA"))
  return

Base: Procedure
  parse arg,
    base_hh ":",
    base_mm ":",
    base_ss " ",
    .      +1,
    base_yr "/",
    base_mo "/",
    base_dy "/",
    .
  if (base_yr||base_mo||base_dy = "") then return 0 0 0
  base_days = Date("B",base_yr||base_mo||base_dy,"S")
  base_seconds = (((base_hh * 60) + base_mm) * 60) + base_ss
  base_timestamp = (base_days * 86400) + base_seconds
  return base_days base_seconds base_timestamp

chg_adjust:
  parse arg,
    adjust_timestamp
  return adjust_timestamp + diff_base_seconds

show_adjustment_direction:
  diff_base_seconds = host_base_seconds - site_base_seconds
  select
    when (diff_base_seconds < 0) then,
      do
        diff_direction = "Ahead"
      end
    when (diff_base_seconds > 0) then,
      do
        diff_direction = "Behind"
      end
    otherwise
      diff_direction = "None"
  end
  return

diff_in_segments:
  diff_plus_seconds = diff_base_seconds * Sign(diff_base_seconds)
  diff_plus_days = diff_plus_seconds % 86400
  if (debug_option >< "") then,
    do
  if (diff_plus_days > 0) then say diff_plus_days "Day(s)."
    end
  diff_plus_seconds = diff_plus_seconds - (diff_plus_days * 86400)
  diff_plus_hours = diff_plus_seconds % 3600
  if (debug_option >< "") then,
    do
  if (diff_plus_hours > 0) then say diff_plus_hours "Hours(s)."
    end
  diff_plus_seconds = diff_plus_seconds - (diff_plus_hours * 3600)
  diff_plus_minutes = diff_plus_seconds % 60
  if (debug_option >< "") then,
    do
  if (diff_plus_minutes > 0) then say diff_plus_minutes "Minutes(s)."
    end
  diff_plus_seconds = diff_plus_seconds - (diff_plus_minutes * 60)
  if (debug_option >< "") then,
    do
  if (diff_plus_seconds > 0) then say diff_plus_seconds "Seconds(s)."
    end
  diff_plus_adjust = 0
  diff_text = "."
  if (diff_plus_minutes > 15) then,
    do
      diff_plus_adjust = diff_plus_adjust + (diff_plus_minutes * 60)
      diff_text = diff_plus_minutes "Minute(s)" diff_text
    end
  if (diff_plus_hours > 0) then,
    do
      diff_plus_adjust = diff_plus_adjust + (diff_plus_hours * 3600)
      diff_text = diff_plus_hours "Hours(s)" diff_text
    end
  if (diff_plus_days > 0) then,
    do
      diff_plus_adjust = diff_plus_adjust + (diff_plus_days * 86400)
      diff_text = diff_plus_days "Days(s)" diff_text
    end
  return

get_site_adjustment:
  /* 220-FTPD1 IBM FTP CS V1R7 at IP6JES2, 14:01:37 on 2007-01-05. */
  parse var ftpo.ix . ", ",
    ftp_hh ":",
    ftp_mm ":",
    ftp_ss " on ",
    ftp_yr "-",
    ftp_mo "-",
    ftp_dy ".",
    . " " .
  site_base = Base(ftp_hh":"ftp_mm":"ftp_ss ftp_yr"/"ftp_mo"/"ftp_dy)
  parse var site_base site_base_days site_base_seconds site_timestamp

  call show_adjustment_direction
  call diff_in_segments
  return

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
  Place any of your subroutines and procedures below this.
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
rexx_jobspecs:
  /*---------------------------------------------------------------*/
  /* ADDRESSABILITY TO CVT FROM PSA                                */
  /*---------------------------------------------------------------*/
  PTR2PSA = 0
  CVTPTR = STORAGE(D2X(PTR2PSA + 16),4)
  /*---------------------------------------------------------------*/
  /* ADDRESSABILITY TO SMCA, THEN GET SMF SYSTEM ID                */
  /*---------------------------------------------------------------*/
  CVTSMCA = STORAGE(D2X(C2D(CVTPTR)+197),3)
  SMFID = STORAGE(D2X(C2D(CVTSMCA)+16),4)
  /*---------------------------------------------------------------*/
  /* GET JOBNAME, STEP, AND PROCEDURE                              */
  /*---------------------------------------------------------------*/
  PSATOLD  = STORAGE(21C,4)                    /* POINTER TO TCB   */
  PTRTIOT  = STORAGE(D2X(C2D(PSATOLD)+12),4)   /* POINTER TO TIOT  */
  JOBNAME  = STORAGE(D2X(C2D(PTRTIOT)),8)
  STEPNAME = STORAGE(D2X(C2D(PTRTIOT)+8),8)
  PROCNAME = STORAGE(D2X(C2D(PTRTIOT)+16),8)
  Tcbjscbb = Storage(D2x(C2d(Psatold)+181),3)                /* jscb */
  jscbssib = STORAGE(D2X(C2D(tcbjscbb)+316),4)        /* Ptr to SSIB */
  ssibjbid = STORAGE(D2X(C2D(jscbssib)+12),8)      /* job identifier */
  Return JOBNAME SSIBJBID STEPNAME PROCNAME

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
__DATA__
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */

./ ADD NAME=FTPVARS  0666-07213-07213-1934-00001-00001-00000-DIR2UPDT
AR_LOAD_REASONS:

  reason.    = "??"
  reason.000 = "FTP subcommand contains an incorrect parameter"
  reason.110 = "Restart marker reply"
  reason.120 = "Service ready in nnn minutes"
  reason.125 = "Data connection already open; transfer starting"
  reason.150 = "File status okay; about to open data connection"
  reason.200 = "Command okay"
  reason.202 = "Command not implemented; not used on this host"
  reason.208 = "Unable to delete data set because expiration date",
               "has not passed"
  reason.211 = "System status, or system help reply"
  reason.212 = "Directory status"
  reason.213 = "File status "
  reason.214 = "Help message"
  reason.215 = "MVS is the operating system of this server"
  reason.220 = "Service ready for new user"
  reason.221 = "QUIT command received"
  reason.226 = "Closing data connection; requested file action",
               "successful "
  reason.230 = "User logged on; proceed"
  reason.250 = "Requested file action okay, completed"
  reason.257 = "PATH NAME created"
  reason.331 = "Send password please"
  reason.332 = "Supply minidisk password using account"
  reason.421 = "Service not available"
  reason.425 = "Cannot open data connection"
  reason.426 = "Connection closed; transfer ended abnormally"
  reason.450 = "Requested file action not taken; file busy"
  reason.451 = "Requested action abended; local error in processing"
  reason.452 = "Requested action not taken; insufficient storage",
               "space in system"
  reason.500 = "Syntax error; command unrecognized"
  reason.501 = "Syntax error in parameters or arguments"
  reason.502 = "Command not implemented"
  reason.503 = "Bad sequence of commands"
  reason.504 = "Command not implemented for that parameter"
  reason.530 = "Not logged on"
  reason.532 = "Need account for storing files"
  reason.550 = "Requested action not taken; file not found or no",
               "access "
  reason.551 = "Requested action abended; page type unknown"
  reason.552 = "Requested file action ended abnormally; exceeded",
               "storage allocation"
  reason.553 = "Requested action not taken; file name not allowed"
  reason.554 = "Transfer aborted; unsupported SQL statement"

  return

AS_LOAD_SUBCMDS:

  subcmd.    = "Invalid"
  subcmd.1   = "AMBIGUOUS"
  subcmd.2   = "?"
  subcmd.3   = "ACCOUNT"
  subcmd.4   = "APPEND"
  subcmd.5   = "ASCII"
  subcmd.6   = "BINARY"
  subcmd.7   = "CD"
  subcmd.8   = "CLOSE"
  subcmd.9   = "TSO"
  subcmd.10  = "OPEN"
  subcmd.11  = "DEBUG"
  subcmd.12  = "DELIMIT"
  subcmd.13  = "DELETE"
  subcmd.14  = "DIR"
  subcmd.15  = "EBCDIC"
  subcmd.16  = "GET"
  subcmd.17  = "HELP"
  subcmd.18  = "LOCSTAT"
  subcmd.19  = "USER"
  subcmd.20  = "LS"
  subcmd.21  = "MDELETE"
  subcmd.22  = "MGET"
  subcmd.23  = "MODE"
  subcmd.24  = "MPUT"
  subcmd.25  = "NOOP"
  subcmd.26  = "PASS"
  subcmd.27  = "PUT"
  subcmd.28  = "PWD"
  subcmd.29  = "QUIT"
  subcmd.30  = "QUOTE"
  subcmd.31  = "RENAME"
  subcmd.32  = "SENDPORT"
  subcmd.33  = "SENDSITE"
  subcmd.34  = "SITE"
  subcmd.35  = "STATUS"
  subcmd.36  = "STRUCT"
  subcmd.37  = "SUNIQUE"
  subcmd.38  = "SYSTEM"
  subcmd.39  = "TRACE"
  subcmd.40  = "TYPE"
  subcmd.41  = "LCD"
  subcmd.42  = "LOCSITE"
  subcmd.43  = "LPWD"
  subcmd.44  = "MKDIR"
  subcmd.45  = "LMKDIR"
  subcmd.46  = "EUCKANJI"
  subcmd.47  = "IBMKANJI"
  subcmd.48  = "JIS78KJ"
  subcmd.49  = "JIS83KJ"
  subcmd.50  = "SJISKANJI"
  subcmd.51  = "CDUP"
  subcmd.52  = "RMDIR"
  subcmd.53  = "HANGEUL"
  subcmd.54  = "KSC5601"
  subcmd.55  = "TCHINESE"
  subcmd.56  = "RESTART"
  subcmd.99  = "UNKNOWN"

  return
./ ADD NAME=HEX2OBJ  0666-07210-07210-0756-00001-00001-00000-DIR2UPDT
rexx_HEX2OBJ:  /* We still need rexx in comment if read from SYSPROC */
/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

  Dataset:  REXX(HEX2OBJ)
  Author:   "Kenneth Tomiak"<KenTomiak@KTomiak.biz>
  Syntax:   HEX2OBJ
  Overview: Reconstructs a member that was save in hexadecimal
            format.

=======================================================================

 History of Modifications
 ------------------------
  When     Who      What you did
  -------- -------- ---------------------------------------------------
  20070528 KTOMIAK  Original code.

=======================================================================

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */

  Parse Arg all_my_arguments
  Numeric Digits 12

rexx_Main_HEX2OBJ:
  return_code = rexx_Initialize()
  If (return_code = 0) then,
    Do
      return_code = rexx_Process()
      return_code = rexx_Termination()
    End
  Return 0

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
 In this routine we open any files and initialize any
 constants we might need.
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
rexx_Initialize:
  PARSE VERSION,
    version_rexx_name,
    version_rexx_version,
    version_rexx_date
  PARSE SOURCE,
    source_host_env,
    source_call_type,
    source_uc_exec_name,
    source_hostdd,
    source_hostdsn,
    source_nf_exec_name,
    source_initial_cmd_env,
    source_asid_name,
    source_char8_user_token,
    source_hostother
  job_specs = rexx_jobspecs()
  sysvar_sysuid = SYSVAR("SYSUID")
  sysvar_sysenv = SYSVAR("SYSENV")
  say ""
  say Copies("=",55)
  say left("=" job_specs,53) "="
  say left("=" source_uc_exec_name,
    "executing under" source_host_env,
    "as a" source_call_type,53) "="
  say left("=  on" date() "at" time()".",53) "="
  say Copies("=",55)
  say ""
  return_code = 0

  If (source_host_env >< "TSO") Then,
    Do
      Say "Wrong host environment" source_host_env
      return_code = 16
    End

  Parse var all_my_arguments dd_ot .
  if (datatype(dd_ot) = "NUM") then,
    do
      dd_ot = "OBJOT"
    end
  if (dd_ot = "") then,
    do
      dd_ot = "OBJOT"
    end

  text_out.0 = 0

  text_in.0 = 0
  call add_rexx_code
  say "Read" text_in.0 "records."

  Return return_code

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
 In this routine we do our processing.
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
rexx_Process:
  if (text_in.0 = 0) then,
    do
      say source_uc_exec_name "is missing the data."
      return_code = 4
      return 4
    end
  do text_ix = 1 to text_in.0 by 2
    line_1 = ""
    text_1 = text_in.text_ix
    next_ix = text_ix + 1
    text_2 = text_in.next_ix
    do char_ix = 1 to length(text_1)
      char_1 = substr(text_1,char_ix,1)
      char_2 = substr(text_2,char_ix,1)
      line_1 = line_1||char_1||char_2
    end
    text_out.0 = out_text(x2c(line_1))
  end
  Return return_code

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
 In this routine we close files and finish up.
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
rexx_Termination:
  "EXECIO * DISKW" dd_ot "(FINIS STEM TEXT_OUT.)"
  write_rc = RC
  if (write_rc >< 0) then,
    Do
      say "Encountered problems writing //DD:"dd_ot"."
      say "RC("write_rc") >< 0"
      return_code = write_rc
    end
  say "Wrote" text_out.0 "records."
  Return return_code

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
 Place any of your subroutines and procedures below this.
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
rexx_jobspecs:
  /*---------------------------------------------------------------*/
  /* ADDRESSABILITY TO CVT FROM PSA                                */
  /*---------------------------------------------------------------*/
  PTR2PSA = 0
  CVTPTR = STORAGE(D2X(PTR2PSA + 16),4)
  /*---------------------------------------------------------------*/
  /* ADDRESSABILITY TO SMCA, THEN GET SMF SYSTEM ID                */
  /*---------------------------------------------------------------*/
  CVTSMCA = STORAGE(D2X(C2D(CVTPTR)+197),3)
  SMFID = STORAGE(D2X(C2D(CVTSMCA)+16),4)
  /*---------------------------------------------------------------*/
  /* GET JOBNAME, STEP, AND PROCEDURE                              */
  /*---------------------------------------------------------------*/
  PSATOLD  = STORAGE(21C,4)                    /* POINTER TO TCB   */
  PTRTIOT  = STORAGE(D2X(C2D(PSATOLD)+12),4)   /* POINTER TO TIOT  */
  JOBNAME  = STORAGE(D2X(C2D(PTRTIOT)),8)
  STEPNAME = STORAGE(D2X(C2D(PTRTIOT)+8),8)
  PROCNAME = STORAGE(D2X(C2D(PTRTIOT)+16),8)
  Tcbjscbb = Storage(D2x(C2d(Psatold)+181),3)              /* jscb */
  jscbssib = STORAGE(D2X(C2D(tcbjscbb)+316),4)      /* Ptr to SSIB */
  ssibjbid = STORAGE(D2X(C2D(jscbssib)+12),8)    /* job identifier */
  Return JOBNAME SSIBJBID STEPNAME PROCNAME

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
 Adds text to a stem variable
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
in_text:
  parse arg text_line
  text_next = text_in.0 + 1
  text_in.text_next = text_line
  return text_next

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
 Adds text to a stem variable
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
out_text:
  parse arg text_line
  text_next = text_out.0 + 1
  text_out.text_next = text_line
  return text_next

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
 Adds the rexx code to convert the member back.
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
add_rexx_code:
  sigl_record = sigl + 25
  rexx_code = "YES"
  process_data = "NO"
  DO WHILE rexx_code = "YES"
    SIGL_RECORD=SIGL_RECORD+1
    MY_DATA=SOURCELINE(SIGL_RECORD)
    IF (MY_DATA="ENDDATA*/") THEN,
      DO
        rexx_code="NO"
        LEAVE
      END
    IF (MY_DATA="/*BEGINDATA") THEN,
      DO
        PROCESS_DATA="YES"
        ITERATE
      END
    IF (PROCESS_DATA="YES") THEN,
      DO
        text_in.0 = in_text(my_data)
      END
  END
  return

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
__DATA__
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
/*BEGINDATA
4DCDCDD44DCCD6DCDE54444444444444444444444444444444444444444444444444444444444444
03571940D9569B9553DB000000000000000000000000000000000000000000000000000000000000
55CCDC000002000DC737D20C000460234EC87C304AE2964116CF61880183010CF7CD000980158C10
BB7943010003002000E8289C02C0333002A852A65BECB9BD8920B0C6DD15F09207006C3927659200
4169BE0455400AC8F3640E1CFF500900CDCB2DB0E69BF455C83997052715103702B3A689AD4D4087
0EE343FA8C363010C00FB0328802103064D2E223AE3C2A62901A013FDA090632ECC1FE4AEAE64101
405D2C00AF7BE0081DAE8F314A01B5E1013A5D49061DA5EE8377322050BE6BFB2056470B2F324E99
03A3066E44010D38A6A925709D311F0A705D535408A84D649CD26683775642020DBF2AF822769761
4B05602A4964206150CC37509EE39DD1F08A04D5C601B1C19B44515E1D8A350D86B1210D3A40D600
003737D513F0008A74A8638D52E833B7061EEC9C150A55A7592FA5F0A06B326B260BBE000D260337
45735CFC3FF8A2055CCCC3066E41660132CA8DE792E1B14011100A960307D0606B0C30A080FB06AB
02A8DE69D71868392AAB04C00ACC0D609E535CF448B29F06125087760002A00154051601B1F12E34
4E08714428118A6B1B400FC2EACE0C284CB839C4A1D4BC0E87020471EE3153286714019CA1B01C4B
002C32426E026CA801F0BD3CE3602D0835AFB41928D70062120416B0EAE2356835FA0D18EF06A41B
4AFA49928D7108A1B0805CB01036030BD06B6C9F5C60800F78771A0240412D770952B74705E164DA
08C1A4A1D03808709A043B30809D0002A027F0410B8108F208F4D705242ED07C08328DA80FE980B0
4FB04D21F68CEC568010A38F7499384CB0881C851D006B0A6842ED0E008550773C307CC2DC6EA2B0
0181C4201E3E502810203D7FE4D48835AF406247083D3AF6B4412D750C75C8F5C612D5A858FC3A98
48A416178AD23380060C580D24388C96C932679B4CB6E7E6F951F4A14B9C02DD5043BA0460234EC8
09C08B3D6C60458ED2338106045B82887007ED292BDBBEAD70EB3FD73F4536A9168152C0333002A8
414F044F9FE78CD36AABF0A11F4D1144444444444444444444444444444444444444444444444444
030AECF8700D72A471B02F7EE9AE6600000000000000000000000000000000000000000000000000
ENDDATA*/

./ ADD NAME=HLQSPACE 0666-07208-07208-2247-00001-00001-00000-DIR2UPDT
rexx_hlqspace:                                                            arg
  hlqspace_version = "01.00"
  arg hlq vol options
  if (pos("TRACE",hlq vol options) > 0) then
    trace ?ilrs
  used_debug = ""
  if (pos("DEBUG",hlq vol options) > 0) then used_debug = "SOME"
  used_report = ""
  if (pos("REPORT",hlq vol options) > 0) then used_report = "YES"
  hlqverb = ""
  volverb = ""
  if (hlq >< "") then hlqverb = "LEVEL("hlq")"
  if (hlq = "*") then hlqverb = ""
  if (vol >< "") then volverb = "VOLUME("vol")"
  if (vol = "*") then volverb = ""
  if (hlqverb volverb = "") then
    do
      hlq = space(sysvar("SYSUID"))
      if (hlq >< "") then hlqverb = "LEVEL("hlq")"
    end

  say Date() Date("W") TIME() "HLQSPACE"
  say "TOTAL TRACKS FOR:" hlqverb volverb

  max_alc = 0
  max_use = 0
  max_dsn = 0

  Address ISPEXEC "CONTROL ERRORS RETURN"
  Address ISPEXEC,
    "LMDINIT LISTID(DSNLIST)",
    hlqverb volverb
                              /* Return codes                     */
                              /*  8 - Listid not created          */
                              /* 12 - Invalid parameter value     */
                              /* 16 - Truncation or translation   */
                              /*      error in accessing dialog   */
                              /*      variables                   */
                              /* 20 - Severe error                */
  RCSAVE = RC
  IF (RCSAVE >< 0) THEN,
    do
      say "Does" hlq "exist?"
      exit 4
    end
  DSNVAR = ''
  rclist = 0
  if (used_report = "YES") then,
    do
      say left("Dataset",44) left("SPACE UNIT",10),
        left("Tracks",6) left("USE",3)"%" left("Blksz",5)
      say copies("-",44) copies("-",10),
        copies("-",6) copies("-",4) copies("-",5)
    end
  DO while rclist = 0
    Address ISPEXEC,
      "LMDLIST LISTID("DSNLIST")",
                    "OPTION(LIST)",
                    "DATASET(DSNVAR)",
                    "STATS(YES)"
    RCLIST = RC
                 /* Return codes                           */
                 /*  4 - No data sets matched specified    */
                 /*      search criteria (the values for   */
                 /*      keywords LEVEL and VOLUME on the  */
                 /*      LMDINIT service).                 */
                 /*  8 - No more data sets names in list   */
                 /*      (option LIST)                     */
                 /*    - No data set list exists for this  */
                 /*      dslist-id (option FREE)           */
                 /*    - Data set lists already exists and */
                 /*      must be freed before using SAVE   */
                 /*      option (option SAVE)              */
                 /* 10 - Data set listid not created by    */
                 /*      lmdinit                           */
                 /* 12 - Invalid parameter value           */
                 /* 16 - Truncation or translation error   */
                 /*      in accessing dialog variables     */
                 /* 20 - Severe error                      */
    if (RCLIST > 0) then leave
    max_dsn = max_dsn + 1
    if (used_debug = "SOME") then,
      do
        say "DSNVAR C(44) Val("DSNVAR")"
          /* Data set name.             */
          /******************************/
        say "  ZDLBLKSZ C(5) Val("ZDLBLKSZ")"
          /* Block size.                */
          /******************************/
        say "  ZDLCDATE C(10) Val("ZDLCDATE")"
          /* Creation date.             */
          /******************************/
        say "  ZDLDEV C(8) Val("ZDLDEV")"
          /* Device type.               */
          /******************************/
        say "  ZDLDSNTP C(8) Val("ZDLDSNTP")"
          /* DS name type ('PDS',       */
          /* 'LIBRARY', or ' ').        */
          /******************************/
        say "  ZDLDSORG C(4) Val("ZDLDSORG")"
          /* Data set organization.     */
          /******************************/
        say "  ZDLEDATE C(10) Val("ZDLEDATE")"
          /* Expiration date.           */
          /******************************/
        say "  ZDLEXT C(3) Val("ZDLEXT")"
          /* Number of extents used.    */
          /******************************/
        say "  ZDLLRECL C(5) Val("ZDLLRECL")"
          /* Number of extents used.    */
          /******************************/
        say "  ZDLMIGR C(3) Val("ZDLMIGR")"
          /* Whether the data set is    */
          /* migrated ('YES' or 'NO').  */
          /******************************/
        say "  ZDLRDATE C(10) Val("ZDLRDATE")"
          /* Date last referenced.      */
          /******************************/
        say "  ZDLRECFM C(5) Val("ZDLRECFM")"
          /* Record format.             */
          /******************************/
        say "  ZDLSIZE C(6) Val("ZDLSIZE")"
          /* Data  set size in tracks.  */
          /******************************/
        say "  ZDLSPACU C(10) Val("ZDLSPACU")"
          /******************************/
          /* Space units, one of the    */
          /* following: CYLINDERS,      */
          /* MEGABYTES, KILOBYTES,      */
          /* BYTES, BLOCKS or TRACKS.   */
        say "  ZDLUSED C(3) Val("ZDLUSED")"
          /* Percentage of used tracks  */
          /* or 4K pages (PDSE).        */
          /******************************/
        say "  ZDLVOL C(6) Val("ZDLVOL")"
          /* Volume serial.             */
          /******************************/
        say ""
      end
    if (datatype(zdlsize) = "NUM") then
      do
        if (used_report = "YES") then,
          say left(DSNVAR,44) left(zdlspacu,10),
            left(zdlsize,6) left(zdlused,3)"%" left(ZDLBLKSZ,5)
        max_alc = max_alc + zdlsize
        if (datatype(zdlused) = "NUM") then
          max_use = max_use + (zdlsize * zdlused / 100)
        else,
          max_use = max_use + zdlsize
      end
    else
      do
        if (used_report = "YES") then,
          say left(DSNVAR,44) left(zdlspacu,10)
      end
  end
  select
    when (RCLIST = 4) then,
      do
        say "Problem listing the HLQ("hlq")"
      end
    when (RCLIST = 8) then,
      do
        nop
      end
    otherwise
      nop
  end
  Address ISPEXEC,
     "LMDLIST LISTID("DSNLIST") OPTION(FREE)"
  Address ISPEXEC,
    "LMDFREE DATAID("DSNLIST")"
  if (used_report = "YES") then,
    say copies("-",44) copies("-",10),
      copies("-",6) copies("-",4) copies("-",5)
  say "TOTAL ENTRIES LISTED  :" max_dsn
  say "TOTAL ALLOCATED TRACKS:" max_alc
  say "TOTAL    USED   TRACKS:" max_use
  exit
./ ADD NAME=IPCSIVP  0666-07210-07210-0826-00001-00001-00000-DIR2UPDT
Rexx_IPCSIVP:
  rexxpgm_version = "01.08"

  Parse Arg parameters_are_not_used

/*===================================================================*
 *                                                                   *
 *  Name:       IPCSIVP                                              *
 *  Type:       IPCS Rexx exec                                       *
 *                                                                   *
 *  Purpose:    Provide hints and tips while using real data.        *
 *  Abstract:   Using an actual IPCS session, build a file of hints  *
 *              and tips to aid the casual user have a productive    *
 *              debugging session. Based on the actual source, go    *
 *              ahead and execute those commands that will work.     *
 *                                                                   *
 *  Syntax:     IPCSIVP                                              *
 *                                                                   *
 *  Example:    ip IPCSIVP                                           *
 *                                                                   *
 *  Author:     "Kenneth E Tomiak"<CBT_Ken@KTomiak.biz>              *
 *  Date:       2003-03-18  2003.077                                 *
 *                                                                   *
 *  Disclaimers:                                                     *
 *  I support my code using a best-effort philosophy. As long as I   *
 *  have access to an image where I can test, I will maintain it as  *
 *  best as I can. If you find a flaw, please do let me know.        *
 *                                                                   *
 *  The code released by Kenneth E. Tomiak may change your IPCS      *
 *  default settings. You can use IPCS option 0 to tailor them back  *
 *  to what you want. An attempt is made to reset your values if you *
 *  do not HALT processing.                                          *
 *                                                                   *
 *  BUYER BEWARE!                                                    *
 *                                                                   *
 *  What could go wrong? If I knew that I would have coded something *
 *  different. I do not expect anything to go wrong. I am going to   *
 *  be adding symbols and stack pointers so your DDIR is going to    *
 *  be updated. Is it big enough? You use DropDump to remove dumps   *
 *  you ar eno longer working with, right?                           *
 *                                                                   *
 *  BUYER BEWARE!                                                    *
 *                                                                   *
 *  In no event will the author be liable to the user of this code   *
 *  for any damages. Including, but not limited to, any lost         *
 *  profits, lost savings or other incidental, consequential or      *
 *  special damages arising out of the operation of or inability to  *
 *  operate this code, even if the user has been advised of the      *
 *  possibility of such damages.                                     *
 *                                                                   *
 *  With that stated, enjoy all this has to offer.                   *
 *                                                                   *
 *===================================================================*
 *===================================================================*
 *                                                                   *
 * History of changes (top entry is the most recent change)          *
 * ----------------------------------------------------------------- *
 *                                                                   *
 * 2007-07-19 KTomiak <CBT_Ken@KTomiak.biz>                          *
 *                    Added FINDUCB.                                 *
 *                                                                   *
 * 2003-04-17 KTomiak <CBT_Ken@KTomiak.biz>                          *
 *                    Added list of bls* members.                    *
 *                                                                   *
 * 2003-04-16 KTomiak <CBT_Ken@KTomiak.biz>                          *
 *                    Added retrieval of VERIFY setting, warning     *
 *                    about CONFIRM needing extra <ENTER>.           *
 *                                                                   *
 * 2003-04-07 KTomiak <CBT_Ken@KTomiak.biz>                          *
 *                    Added list of *ipcs* members from DDNAMEs      *
 *                    SYSPROC and SYSEXEC.                           *
 *                    If SOURCE(NODSNAME) then default to ACTIVE.    *
 *                    SHOW MVS commands for displaying DUMP options. *
 *                                                                   *
 * 2003-04-04 KTomiak <CBT_Ken@KTomiak.biz>                          *
 *                    Added more hints&tips and included showing     *
 *                    real data from the source, when appropriate.   *
 *                    Source can be a dump, VSAM, or memory.         *
 *                                                                   *
 * 2003-04-03 KTomiak <CBT_Ken@KTomiak.biz>                          *
 *                    Added hints&tips from scattered notes.         *
 *                                                                   *
 * 2003-04-02 KTomiak <CBT_Ken@KTomiak.biz>                          *
 *                    If SOURCE(NODSNAME) then default to            *
 *                    using ACTIVE.                                  *
 *                    Add a few more entries to the stack.           *
 *                                                                   *
 * 2003-03-11 KTomiak <CBT_Ken@KTomiak.biz>                          *
 *                    Original concept design, code                  *
 *                    cloned from BLSXWHER, then modified.           *
 *                                                                   *
 * ----------------------------------------------------------------- *
 *                                                                   *
 *===================================================================*/

  Address IPCS
  trace off
  opsys = MVSVAR("SYSOPSYS")
  sysname = MVSVAR("SYSNAME")
  parse upper var opsys rootsys rootlvl rootfmid
  parse var rootlvl rootver "." rootrel "." rootmod
  rootver = rootver + 0
  rootrel = rootrel + 0
  rootmod = rootmod + 0
  CVT  = C2d(Storage(10,4))                  /* point to CVT         */
  ECVT   = C2d(Storage(D2x(CVT + 140),4))    /* point to CVTECVT     */
  ipaarchl = 1
  if (Substr(rootfmid,4,4) >= 6602) then,
    do
      ECVTIPA = C2d(Storage(D2x(ECVT + 392),4)) /* point to IPA      */
      If Substr(rootfmid,4,4) > 6609 then ,  /* OS/390 R10 or above  */
        IPAARCHL = Storage(D2x(ECVTIPA + 2143),1) /* ARCHLVL (1 or 2) */
    end
  current_address = Address()

  Call OUTTRAP "lines."     /* Suppress CBFormat output when
                               not in the IPCS dialog environment.   */
/*-------------------------------------------------------------------*
 * VERSION=>version_rexx_name,version_rexx_version,version_rexx_date *
 *-------------------------------------------------------------------*/
  Parse Version,
    version_rexx_name,
    version_rexx_version,
    version_rexx_date

/*-------------------------------------------------------------------*
 * SOURCE==>    (A set of platform dependent values)                 *
 *-------------------------------------------------------------------*/
  Parse SOURCE,
    source_host_env,
    source_call_type,
    source_uc_exec_name,
    source_hostdd,
    source_hostdsn,
    source_nf_exec_name,
    source_initial_cmd_env,
    source_asid_name,
    source_char8_user_token,
    source_hostother
  Address_Environment = Address()

/*-------------------------------------------------------------------*
 * Now make sure IPCS is actively working.                           *
 *-------------------------------------------------------------------*/

  Signal ON HALT

/* --------------------------------------------------------- */
/* Save the current default environment.  Although all of    */
/* the defaults saved are not changed in this exec, saving   */
/* them ensures they will be returned to their initial value */
/* if in the future they are changed in this exec.           */
/* --------------------------------------------------------- */

  "EVALDEF REXX(CONFIRM(con) PRINT(prt) SOURCE(src)",
      "TERMINAL(trm) FLAG(flg) DISPLAY(dsp) VERIFY(vfy))"
  Retc = rc
  If (Retc > 12) | (retc < 0) then,
    do
      say left("Hey, you need to be in IPCS!",76)
      signal No_restore_exit    /* Error exit                    */
    end
  If (src = "NODSNAME") then,
    do
      "SETDEF LOCAL ACTIVE"
      Retc = rc
      "EVALDEF REXX(CONFIRM(ktcon) PRINT(ktprt) SOURCE(ktsrc)",
        "TERMINAL(kettrm) FLAG(ketflg) DISPLAY(ketdsp) VERIFY(ketvfy))"
      If (Retc > 12) | (retc < 0) then,
        do
          msgtext = left("Hey, you need to open something!",76)
          Call Put
          signal No_restore_exit    /* Error exit           */
        end
      src = ktsrc
      call putitout ,
       Left("** Using NODSNAME would only show help",
        "so I changed to ACTIVE",103) "**"
      dispsrc = "SOURCE("src")"
    end

  MsgText = " "
  Call Put
  MsgText = Copies("=",79)
  Call Put
  Call Put
  MsgText = "Continue to scroll down as I execute some of these"
  Call Put
  MsgText = "commands for you. PF3(END) ay anytime to HALT execution."
  Call Put
  MsgText = "Some commands are tailored to the SOURCE you are using."
  Call Put
  showitall = "n"
  if (left(src,3) = "DSN") then showitall = "?"
  select
    when (src = "NODSNAME") then,
      do
        call putitout ,
         Left("** Using NODSNAME will only show help",103) "**"
        dispsrc = "SOURCE("src")"
      end
    when (showitall = "n") then,
      do
        dispsrc = "SOURCE("src")"
        call putitout ,
         Left("** Using" dispsrc "will not show",
           "all that DSNAME() would.",103) "**"
      end
    otherwise,
    do
      parse var src . "'" namesrc "'" .
      parse var namesrc srcdsn "(" srcext ")" .
      lrc = Listdsi("'"srcdsn"'")
      if (srcext >< "") then,
        do
          dispsrc = "SOURCE("srcdsn"("srcext"))"
        end
      else,
        do
          dispsrc = "SOURCE("srcdsn")"
        end
      call putitout Left("**" srcdsn "DSORG("sysdsorg")",103) "**"
      if (sysdsorg >< "VS") then showitall = "y"
    end
  end
  MsgText = Copies("=",79)
  Call Put
  Call Put
  MsgText = " "
  Call Put

/*-------------------------------------------------------------------*
 * Display Ken's standard header.                                    *
 *-------------------------------------------------------------------*/
  call putitout ""
  call putitout Copies("=",55)
  call putitout Left("=" source_uc_exec_name rexxpgm_version,53) "="
  call putitout Left("= Executing under" source_host_env,53) "="
  call putitout Left("=" "as a" source_call_type,53) "="
  call putitout Left("= with Address("Address_Environment")",53) "="
  call putitout Left("= On" date() "at" time()".",53) "="
  call putitout Left("= Language:" version_rexx_name,53) "="
  call putitout Left("= Level:" version_rexx_version,53) "="
  call putitout Left("= Date:" version_rexx_date,53) "="
  call putitout Copies("=",55)
  call putitout " "
  call putitout "This IPCS Reference provided by Kenneth E. Tomiak",
    "(SaAI)."
  call putitout "Much of this information comes from Jerry Ng (IBM)."
  call putitout " "
  call putitout "Your current IPCS settings:"
  call putitout "---------------------------"
  call putitout "  CONFIRM ="con"."
  if (con = "CONFIRM") then,
    do
      call putitout "      IF AFTER PRESSING <DOWN>"
      call putitout "      IT LOOKS LIKE NOTHING IS HAPPENING,"
      call putitout "      KEEP PRESSING ENTER."
      call putitout "      You can change this under settings by"
      call putitout "      using NOCONFIRM."
      call putitout "      "
    end
  call putitout "  VERIFY  ="vfy"."
  call putitout "  PRINT   ="prt"."
  call putitout "  TERMINAL="trm"."
  call putitout "  FLAG    ="flg"."
  call putitout "  DISPLAY ="dsp"."
  call putitout " "
  call putitout " "
  call putitout "Open something:"
  call putitout "---------------"
  call putitout "Under your defaults you can use:"
  call putitout "  ACTIVE, MAIN, or STORAGE."
  call putitout "  DSNAME(''some.dump.dsname''),"
  call putitout "  or DSNAME(''some.vsam.cluster.dsname''),"
  call putitout "  or DSNAME(''some.vsam.cluster.dsname(DATA)'')!"
  call putitout "From the IPCS 3.4 screen use the line command:"
  call putitout "  setdef dsname(/)"
  call putitout ,
   Left("** You are using" dispsrc".",103) "**"
  call putitout " "
  call putitout "To find how" sysname "processes dumps, issue MVS",
    "commands:"
  call putitout "D D,O        - Display Dump options"
  call putitout "               Shows what gets dumped."
  call putitout "D D,S        - Display Dump Status allocation defaults"
  call putitout "               Shows where it gets dumped to."
  call putitout " "
  call putitout "Remember to DropDump once in awhile when using"
  call putitout "SOURCE(dsname). I like to delete my dump directory"
  call putitout "every now and then. TSO DEL DDIR does it."
  call putitout " "
  call putitout Copies("-",78)
  call putitout "Jerry Ng (IBM) says:"
  call putitout " "
  call putitout "There are four types of dumps in two major categories:"
  call putitout "  Synchronous"
  call putitout "  Asynchronous"
  call putitout "    SLIP"
  call putitout "    Console initiated dump"
  call putitout "    Disabled/SRB"
  call putitout "To determine the type, look at the DUMP TITLE."
  if (showitall = "y") then,
    do
      msgtext = ,
        "EVALUATE 58. LENGTH(100) REXX(STORAGE(dtitle)) BLOCK(0) CHAR"
      Call Put
      msgtext
      "EQUATE DMPTITLE 58. LENGTH(100) BLOCK(0) CHAR",
        "REMARK(''Kens - DUMP Title'')"
      "STACK DMPTITLE"      /* Add it to the pointer list     */
      call putitout left("** The dump title is:",103) "**"
      call putitout Copies("*",106)
      call putitout left("**" dtitle,103) "**"
      call putitout Copies("*",106)
    end
  call putitout "  Issue ''IPCS STATUS SYSTEM''."
  call putitout "  Look at ''Program Requesting Dump''."
  call putitout "    an SVCDUMP is Synchronous,"
  call putitout "    an IEAVTSDT is Asynchronous."
  call putitout Copies("-",78)
  if (showitall = "y") then,
    do
      "EVALUATE 40. LENGTH(8) REXX(STORAGE(reqpgm)) BLOCK(0) CHAR"
      "EVALUATE CC. LENGTH(8) REXX(STORAGE(failsys)) BLOCK(0) CHAR"
      "EVALUATE 1BC. LENGTH(44) REXX(STORAGE(dmpdsn)) BLOCK(0) CHAR"
      dmpdsn = strip(dmpdsn,"B"," ")
      call putitout Copies("*",106)
      call putitout ,
        Left("** The requesting program is" reqpgm".",103) "**"
      call putitout ,
      left("** The dump was taken on system:" failsys".",103),
        "**"
      call putitout ,
      left("** You are viewing it on system:" sysname".",103),
        "**"
      call putitout Copies("*",106)
    end
  call putitout " "
  call putitout "While examining anything:"
  call putitout "-------------------------"
  call putitout "Use ''%'' for 24 bit addresses,"
  call putitout "Use ''?'' for 31 bit addresses,"
  call putitout "Use ''!'' for 64 bit addresses."
  call putitout "Your Architecture Level is" ipaarchl"."
  select
    when (ipaarchl = 1) then,
      do
        call putitout "  You are not 64 bit enabled."
      end
    when (ipaarchl = 2) then,
      do
        call putitout "  64 bit is enabled."
        call putitout "    Recognize a 64 bit address:",
          "01_80203040 is one example."
      end
    otherwise,
      do
        call putitout "  Neither 64 bit nor not 64 bit, how odd!"
      end
  end
  call putitout "Use ''L'' to add a 24 bit address to the stack."
  call putitout "Use ''H'' to add a 31 bit address to the stack."
  call putitout " "
  call putitout ,
    "Casual use of the FINDUCB subcommand is not recommended because"
  call putitout ,
    "FINDUCB s processing requires a great deal of time."
  msgtext = ,
      "FiNDUCB 0A80"
  Call Put
  msgtext
  call putitout "Toggle between Ebcdic or Ascii."
  call putitout " "
  call putitout "Use ''CBF addr. str(cbfname)'' to format a CB."
  call putitout "Use ''LIST PRIVATE'' and ''LIST PRIVATEX''."
  call putitout "Use ''LISTSYM *'' to list defined symbols."
  call putitout "Use F t''literal'' NOB to find without breaking."
  call putitout "Use F x''hex-lit'' mask(x''0000FFFF'') BDY(4)   "
  call putitout "  would compare the right half-word on word boundries."
  call putitout "Using ''IPCS OPCODE xxxxxxxx'' will describe the  "
  call putitout "  opcode instruction. Make sure you pass the entire"
  call putitout "  length''s data. From 2 to 12 bytes."
  "OPCODE 849C7BBA REXX(MNEMONIC(opins))"
  retc = rc
  call putitout "OPCODE 849C7BBA should show BRXH, it shows:" opins
  call putitout " "
  call putitout "You can ''PATCH'' data if you need to fix a corrupted"
  call putitout "control block."
  call putitout "  PATCH LIST            - shows what is patched."
  call putitout "  DROPMAP               - clears any patched del."
  call putitout "  PATCH DEL ..."
  call putitout "  PATCH ADD x''C1E2C3C2'' ADDR(F49880.) - adds ASCB."
  call putitout " "
  call putitout "CBF addr. STR(todclock) - CONVERTS TO DATE AND TIME"
  if (showitall = "y") then,
    do
      "EVALUATE 48. L(8) REXX(STORAGE(dmpclk)) BLOCK(0)"
      call putitout Copies("*",106)
      call putitout ,
       Left("** This dump was taken:",103)
      call putitout ,
        Left("** CBF 48. str(TODCLOCK) BLOCK(0)",103) "**"
      "CBF 48. str(TODCLOCK) BLOCK(0)"
      call putitout Copies("*",106)
  end
  call putitout " "
  call putitout " "
  call putitout "While examining a dump (not ACTIVE):"
  call putitout "------------------------------------"
  call putitout "Look at ''Program Requesting Dump''."
  call putitout "  DFHKETCB is CICS  (so says Ken)"
  if (showitall = "y") then,
    do
      call putitout Copies("*",106)
      call putitout ,
        Left("** The requesting program of dump" ,
        dmpdsn "is:" reqpgm".",103),
        "**"
      call putitout Copies("*",106)
    end
  call putitout "IPCS SUMM FORMAT     - for a quick look."
  call putitout "IPCS EVAL PSW        - Locate PSW."
  if (showitall = "y") then,
    do
      call putitout ,
        "EVAL PSW     - let IBM find it."
      call putitout Copies("*",106)
      "EVAL PSW"
      call putitout Copies("*",106)
      call putitout ,
        "EQUATE PSW X",
          "REMARK(''IBMs - Program Status Word'') STR(PSW)"
      call putitout Copies("*",106)
      "EQUATE PSW X",
        "REMARK('IBMs - Program Status Word') STR(PSW)"
      call putitout Copies("*",106)
      call putitout ,
        "STACK PSW"           /* Add it to the pointer list     */
      call putitout Copies("*",106)
      "STACK PSW"           /* Add it to the pointer list     */
      call putitout Copies("*",106)
      call putitout ,
        "L PSW"
      call putitout Copies("*",106)
      "L PSW"
      call putitout Copies("*",106)
    end
  call putitout "L 13R?               - Current save area in reg 13"
  call putitout " "
  call putitout "Use ''WHERE addr.'' to have IPCS find where it is."
  if (showitall = "y") then,
    do
      call putitout ,
        "Where PSW      - find out which ASID or area the PSW is in."
      call putitout Copies("*",106)
      "Where PSW"
      call putitout Copies("*",106)
    end
  call putitout " "
  call putitout "L dumptimestamp      - shows when dump was taken."
  call putitout "  or ip status worksheet or ip status system."
  call putitout " "
  call putitout "LIST E0. BLOCK(0) LENGTH(16) AREA - shows sdrsn"
  call putitout "  This will indicate if it is a partial dump."
  call putitout "  The fourth word is SDRSN from IEA611I or IEA911E."
  call putitout " "
  call putitout "CBF RTCT - shows which address spaces were dumped."
  call putitout "CBF RTCT+9C? STR(SDUMP) VIEW(FLAGS) - what areas."
  call putitout " "
  call putitout "You are running on" rootsys rootver"."rootrel"."
  call putitout " "
  call putitout "z/OS 1.2+ enhancements:"
  call putitout "  SORTBY   - with OA02037"
  call putitout "  verbx blsaispt    - shows how long IPL routines take"
  call putitout "                      until you get to z/OS 1.3, then"
  call putitout "                      you should use IPLDATA."
  call putitout "    (from SYS1.MIGLIB)"
  call putitout " "
  call putitout "z/OS 1.3+ enhancements:"
  call putitout "IPLDATA INFORMATION - shows ''D IPLINFO'' data."
  call putitout "IPLDATA STATUS      - shows how long IPL routines take"
  call putitout " "
  call putitout "z/OS 1.4+ enhancements:"
  call putitout "Ltod 8hex-digits            - converts to todclock."
  call putitout "Ltod 32hex-digits Extended  - converts to todclock."
  call putitout " "
  call putitout " "
  call putitout "You can use ASID() or BLOCK()."
  call putitout "  ASID() lets IPCS work some magic"
  call putitout "  BLOCK() gives you raw access"
  call putitout "    IP L 58. BLOCK(0) L(100) CHAR - shows the title."
  call putitout " "
  call putitout " "
  call putitout "use these commands if you dumped these:"
  call putitout "---------------------------------------"
  call putitout "IPCS VERBX MTRACE    - master console output"
  call putitout "IPCS VERBX LOGDATA   - logrec output"
  call putitout "IPCS systrace        - system trace"
  call putitout "IPCS lpamap          - print lpa module''s addresses"
  call putitout " "
  call putitout "Other fun things to look at:"
  call putitout "----------------------------"
  call putitout "Issue ''IPCS STATUS FAILDATA'' to find failure data."
  call putitout "Issue ''IPCS STATUS REGISTERS'' to find registers."
  if (showitall = "y") then,
    do
      call putitout Copies("*",106)
      call putitout "**",
      "ST registers"        /* show register 13 savearea chaining */
      "ST registers"        /* show register 13 savearea chaining */
      call putitout Copies("*",106)
    end
  call putitout " "
  call putitout "Things to watch out for:"
  call putitout "------------------------"
  call putitout "Correct ''ASID(x''0000'')'' if not your data."
  call putitout "XMD under ASID(0002) is not normally available."
  call putitout " "
  call putitout "If you dumped ASID(0002):"
  call putitout "-------------------------"
  call putitout "Run the chain to find lost ASIDs"
  call putitout "  Enter the next two lines as one command."
  call putitout "   runc addr(cvt+364%+138?) link(x''88'') +"
  call putitout "   exec((l x+48?+1c len(8) asid(2) char)) nodisplay"
  call putitout " "
  call putitout "When analyzing a CICS dump:"
  call putitout "---------------------------"
  call putitout "May need to allocate SDFHPARM to //IPCSPARM DD."
  call putitout "May need to allocate SDFHLINK as a TSOLIB or LNKLST."
  call putitout "May need to allocate DFHSNAP to eliminate messages."
  call putitout "SUMMARY DATA should not be used for CICS because"
  call putitout "  it uses three keys."
  call putitout "Change options(NOMACHINE) to (MACHINE)"
  if (showitall = "y") &,
     (reqpgm = "DFHKETCB") then,
    do
      call putitout Copies("*",106)
      call putitout ,
        Left("** This is a CICS dump so I''ll switch it for you",103),
        "**"
      call putitout Copies("*",106)
      parse var dsp mch other
      if (mch >< "MACHINE") then,
        do
      call putitout Copies("*",106)
          "SETDEF DISPLAY(MACHINE" other")"
          set_rc = rc
      call putitout Copies("*",106)
        end
    end
  call putitout "VERBX DFHPDxxx uses the continuing vrm for CICS TS."
  call putitout "           510 was CICS TS 1.0"
  call putitout " "
  call putitout "When analyzing an IMS dump:"
  call putitout "---------------------------"
  call putitout "You will need DFSOFMD0 from //IPCSPARM DD."
  call putitout "   I copied BLSCECTX from PARMLIB and added:"
  call putitout ,
    "    EXIT EP(DFSOFMD0) VERB(IMSDUMP) ABSTRACT(''IMS ANALYSIS'') +"
  call putitout ,
    "        PARM(''PDBCTL'')"
  call putitout "   and make sure you have IRLM support if you need it:"
  call putitout ,
    "EXIT EP(DXRRLM50) VERB(IRLM) AMASK(X''00FFFFFF'') ABSTRACT(+"
  call putitout ,
    "    ''IMS RESOURCE LOCK MANAGER ANALYSIS'')"
  call putitout "Allocate //DFSFRMAT to a pds member with this in it:"
  call putitout "FMTIMS(AUTO)"
  call putitout "Allocate DFSCLST  to //SYSPROC  DD."
  call putitout "Allocate RESLIB   to //ISPLLIB  DD."
  call putitout "Allocate DFSMLIB  to //ISPMLIB  DD."
  call putitout "Allocate DFSPLIB  to //ISPPLIB  DD."
  call putitout "Allocate DFSSLIB  to //ISPSLIB  DD."
  call putitout " "
  call putitout "When analyzing a JES2 dump:"
  call putitout "---------------------------"
  call putitout "VERBX HASMFMTM - to get LE control blocks."
  call putitout "SYS1.*.SHASMIG contains verbexit code."
  call putitout "SYS1.*.SHASPNL0 contains panels for JES2 analysis."
  call putitout " "
  call putitout "When analyzing a JES3 dump:"
  call putitout "---------------------------"
  call putitout "SYS1.*.SIATTBL0 contains members required by"
  call putitout "  IATIJPCS. May need to allocate //IATTABL DD."
  call putitout " "
  call putitout "When analyzing a Language Environment (LE) dump:"
  call putitout "------------------------------------------------"
  call putitout "VERBX LEDATA  - to get LE control blocks."
  call putitout "CEEIPCSP needs to be in PARMLIB or //IPCSPARM DD."
  call putitout "May need to allocate MIGLIB as a TSOLIB or LNKLST."
  call putitout "May need to allocate SCEESAMP to //IPCSPARM DD."
  call putitout " "
  call putitout "When analyzing a Communication Server (VTAM/IP) dump:"
  call putitout "-----------------------------------------------------"
  call putitout "May need to allocate SISTCLS1 to //SYSPROC  DD."
  call putitout "May need to allocate SEZAINST to //SYSEXEC  DD "
  call putitout "        and allocate SEZAINST to //SYSPROC  DD."
  call putitout "May need to allocate SEZAHELP to //SYSHELP  DD "
  call putitout "May need to allocate SEZAMIG as a TSOLIB or LNKLST "
  call putitout "        and allocate SEZAMIG  to //ISPLLIB  DD."
  call putitout "May need to allocate SEZAMENU to //ISPMLIB  DD "
  call putitout "May need to allocate SEZAPENU to //ISPPLIB  DD "
  call putitout "May need to allocate SBLSPNL0 to //ISPTLIB  DD "
  call putitout "VERBX VTAMMAP - to get VTAM mapping."
  call putitout " "
  call putitout "When analyzing a STAND-ALONE dump:"
  call putitout "----------------------------------"
  call putitout "COPYCAPD     - copy a captured and yet unwritten dump."

/* --------------------------------------------------------- */
/* Use SETDEF and EVALDEF to normalize the ASID since it     */
/* will be used for comparison with the normalized form      */
/* further down.                                             */
/*                                                           */
/* Initially, ASID(x'0001') *MASTER* is used.                */
/* --------------------------------------------------------- */

      call putitout Copies("*",106)
  ASID = "ASID(x'0001')"
  "SETDEF LOCAL" asid
  Retc = rc
  If (Retc >< 0) Then
    Do
      MsgText = "Invalid ASID" asid
      Call Put            /* Transmit message              */
      Retc = 16
      Signal Exit
    End

  "EVALDEF LOCAL REXX(QUALIFICATION(qual))" /* qual may be null */
  Qual_Retc = rc

  If (qual = "") & (Length(asid) = 0) Then
    Do
      MsgText = "No ASID is available" /*                  @P1C*/
      Call Put                /* Transmit message              */
      MsgText = "A proper ASID must be provided" /*        @P1C*/
      Call Put                /* Transmit message              */
      Retc = 16
      Signal Exit
    End

/* --------------------------------------------------------- */
/* Determine the ASID number.                                */
/* --------------------------------------------------------- */

  If substr(asid,1,3) = 'CPU' Then,
    Do
      "SETDEF LOCAL NOCPU"
      "EVALDEF REXX(QUALIFICATION(asid))" /*               @P1C*/
      asid_number = substr(asid,14,4)
    End
  Else,
  If substr(asid,1,5) = 'NOCPU' Then,
    asid_number = substr(asid,14,4)
  Else
    parse var asid . "'" asid_number "'" .

  msgtext = ,
  "EVALUATE 10. LENGTH(4) REXX(STORAGE($CVTADDR))"
  Call Put
  msgtext
  call putitout "The CVT address is:" $CVTADDR

  $cvtaddr = c2x(d2c(c2d(x2c($cvtaddr)) + 0))
  msgtext = ,
  "EQUATE CVT" $cvtaddr". POSITION(X''-28'')",
    "REMARK(''Kens - Communication Vector Table'') STR(CVT)"
  Call Put
  "EQUATE CVT" $cvtaddr". POSITION(X'-28')",
    "REMARK('Kens - Communication Vector Table') STR(CVT)"
  equ_rc = rc
  if (equ_rc = 0) then,
    do
      call putitout "An EQUATE for symbol CVT has been defined as",
        "a structure."
      "STACK CVT"           /* Add it to the pointer list     */
      equ_rc = rc
      if (equ_rc = 0) then,
        do
          call putitout "  The CVT has been added to the STACK"
          call putitout "    The ''S'' line command will show storage."
          call putitout "    The ''F'' line command will format",
            "the control block."
        end
    end
  else,
    do
      MsgText = "EQUate CVT failed, rc="equ_rc
      Call Put
    end
  call putitout " "

  "EVALUATE "$cvtaddr".+8C LENGTH(4) REXX(STORAGE(ECVTADDR))"
  "EQUATE ECVT" ECVTaddr".",
    "REMARK('Kens - Extended CVT') STR(ECVT)"
  equ_rc = rc
  if (equ_rc = 0) then,
    do
      "STACK ECVT"          /* Add it to the pointer list     */
    end
  else,
    do
      MsgText = "EQUate ECVT failed, rc="equ_rc
      Call Put
    end

  "EVALUATE "$cvtaddr".+64 LENGTH(4) REXX(STORAGE(CUCBADDR))"
  "EQUATE CUCB" CUCBaddr".",
    "REMARK('Kens - C U C B') STR(CUCB)"
  equ_rc = rc
  if (equ_rc = 0) then,
    do
      "STACK CUCB"          /* Add it to the pointer list     */
    end
  else,
    do
      MsgText = "EQUate CUCB failed, rc="equ_rc
      Call Put
    end

  "EVALUATE "$cvtaddr".+128 LENGTH(4) REXX(STORAGE(JESCTADDR))"
  "EQUATE JESCT" JESCTaddr".",
    "REMARK('Kens - JES Control Task') STR(JESCT)"
  equ_rc = rc
  if (equ_rc = 0) then,
    do
      "STACK JESCT"         /* Add it to the pointer list     */
    end
  else,
    do
      MsgText = "EQUate JESCT failed, rc="equ_rc
      Call Put
    end

  "EVALUATE "$cvtaddr".+364 LENGTH(4) REXX(STORAGE(SVTADDR))"
  "EQUATE SVT" svtaddr".",
    "REMARK('Kens - Subsystem Vector Table') STR(SVT)"
  equ_rc = rc
  if (equ_rc = 0) then,
    do
      "STACK SVT"           /* Add it to the pointer list     */
    end
  else,
    do
      MsgText = "EQUate SVT failed, rc="equ_rc
      Call Put
    end

  "EVALUATE "svtaddr".+94 LENGTH(4) REXX(STORAGE(xmdADDR)) ASID(0002)"
  "EQUATE XMD" xmdaddr". ASID(0002)",
    "REMARK('Kens - Cross Memory Descriptor') STR(XMD)"
  equ_rc = rc
  if (equ_rc = 0) then,
    do
      "STACK XMD"           /* Add it to the pointer list     */
    end
  else,
    do
      MsgText = "EQUate XMD failed, rc="equ_rc
      Call Put
    end

  if (showitall = "y") then,
    do
      "EQUATE DUMPTIME 48. BLOCK(0) LENGTH(16) AREA",
        "REMARK('Time dump was taken.')"
      equ_rc = rc
      if (equ_rc = 0) then,
        do
          "STACK DUMPTIME" /* Add it to the pointer list     */
        end
      else,
        do
          MsgText = "EQUate dumptime failed, rc="equ_rc
          Call Put
        end
    end

  Call OUTTRAP "OFF"         /* Turn suppression off           */

/* --------------------------------------------------------- */
/* Use SETDEF to indicate that IPCS should suppress IPCS     */
/* messages that are not terminating.  Note that IPCS will   */
/* not suppress all IPCS informational, warning, error, and  */
/* severe messages.  See the IPCS documentation for details  */
/* on using SETDEF to suppress IPCS messages.                */
/* --------------------------------------------------------- */

  "SETDEF FLAG(TERMINATING)" /* Only display terminating
                                messages                       */

  signal exit

/* --------------------------------------------------------- */
/*   Let ISPF do the hard work.                              */
/* --------------------------------------------------------- */

Show_IPCS_members:
  ADDRESS ISPEXEC "CONTROL ERRORS RETURN"
  Numeric Digits 12
  MsgText = " "
  Call Put
  MsgText = " "
  Call Put
  MsgText = "Other members in SYSPROC and SYSEXEC with *IPCS*:"
  Call Put
  MsgText = "-------------------------------------------------"
  Call Put

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*
 * MAIN procedure which invokes sub-functions.                       *
 *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
  pattern_mask = "*IPCS*"
  ddname = "SYSPROC"
  MsgText = "SYSPROC:"
  Call Put
  MsgText = "--------"
  Call Put
  Call Init_MemList
  Call Main_MemList
  Call Term_MemList
  ddname = "SYSEXEC"
  MsgText = " "
  Call Put
  MsgText = "SYSEXEC:"
  Call Put
  MsgText = "--------"
  Call Put
  Call Init_MemList
  Call Main_MemList
  Call Term_MemList
  call putitout " "
  pattern_mask = "BLS*"
  ddname = "SYSPROC"
  MsgText = "SYSPROC:"
  Call Put
  MsgText = "--------"
  Call Put
  Call Init_MemList
  Call Main_MemList
  Call Term_MemList
  ddname = "SYSEXEC"
  MsgText = " "
  Call Put
  MsgText = "SYSEXEC:"
  Call Put
  MsgText = "--------"
  Call Put
  Call Init_MemList
  Call Main_MemList
  Call Term_MemList
  call putitout " "
  call putitout Copies("*",106)
  call putitout " "
  call putitout "CBF RTCT - shows which address spaces were dumped."
  "CBF RTCT"
  call putitout " "
  call putitout Copies("*",106)
  call putitout " "
  call putitout "CBF RTCT+9C? STR(SDUMP) VIEW(FLAGS) - what areas."
  "CBF RTCT+9C? STR(SDUMP) VIEW(FLAGS)"
  call putitout " "
  call putitout Copies("*",106)
  MsgText = "This is all of the help" source_uc_exec_name,
    "is designed to give."
  Call Put

  call putitout " "
  Call Putitout Copies("=",79)
  Call Putitout " "
  msgtext = " End of" strip(source_uc_exec_name)"."
  call put
  Call Putitout " "
  return


/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*
 * Initialize variables used by the code.                            *
 *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
Init_MemList:
  call fetch_dsnames
  Return


/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*
 * The meat and potatoes of the code.                                *
 *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
Main_MemList:
    ZERRALRM = "NO"
    ZERRHM = "*"
    ADDRESS ISPEXEC "LMINIT DATAID(PDSID)",
      "DDNAME("ddname") ENQ(SHR)"
    IF (RC >< 0) THEN,
      DO
        ZERRSM = "FILE IN USE"
        ZERRLM = "THE FILE "ddname" IS IN USE"
        ADDRESS ISPEXEC "SETMSG MSG(ISRZ002)"
        SIGNAL ABNEXIT
      END
    ADDRESS ISPEXEC "LMOPEN DATAID("PDSID")",
      "OPTION(INPUT)"
    MYCC = RC
    IF (MYCC >< 0) THEN,
      DO
        ZERRSM = "FILE FAILED TO OPEN"
        ZERRLM = "THE FILE "ddname" FAILED TO"
        ZERRLM = ZERRLM "OPEN RC=MYCC"
        ADDRESS ISPEXEC "SETMSG MSG(ISRZ002)"
        SIGNAL ABNEXIT
      END
    PDSMBR = ""
  here = 0
Read_MemList:
    ADDRESS ISPEXEC "LMMLIST DATAID("PDSID")",
      "OPTION(LIST) MEMBER(PDSMBR) STATS(YES)",
      "PATTERN("pattern_mask")"
    MYCC = RC
    IF (MYCC >< 0) THEN,
      DO
        SIGNAL EOPM_MemList
      END
    PDSMBR = STRIP(PDSMBR,"B"," ")
    HERE = HERE + 1
    call putitout right("     "HERE,5) "=" left(PDSMBR,8),
      dd_dsn.zllib
    SIGNAL Read_MemList

EOPM_MemList:
    finish_rc = 0
    return

ABNEXIT:
    finish_rc = 4
    return

term_MemList:
    ADDRESS ISPEXEC "LMMLIST DATAID("PDSID") OPTION(FREE)"
    ADDRESS ISPEXEC "LMCLOSE DATAID("PDSID")"
    return
/*                                                              */
/* FIND OUT WHAT IS ALREADY ALLOCATED                           */
fetch_dsnames:
  PSATOLD  = STORAGE(21C,4)                     /* POINTER TO TCB  */
  PTRTIOT  = STORAGE(D2X(C2D(PSATOLD)+12),4)    /* POINTER TO TIOT */
  tiotptr = d2c(c2d(ptrtiot)+24)
  tiotelen = c2d(STORAGE(D2X(C2D(tiotptr)+0),1))
  alcddname_list = ""
  max_entry = 0
  do while tiotelen > 0
    tiotflag = c2d(STORAGE(D2X(C2D(tiotptr)+1),1))
    tiotddnm = STORAGE(D2X(C2D(tiotptr)+4),8)
    IF BITAND(tiotflag,'80'X) = '80'X THEN,
      do
        if tiotddnm = copies("00"x,8) then,
          do
            Leave
          end
        else,
        if tiotddnm >< "        " then,
          do
            alcddname = tiotddnm
          end
        tioejfcb = storage(d2x(c2d(tiotptr)+12),3)
        jfcb = swareq(tioejfcb)
        jfcbqnam  = strip(alcddname,"B"," ")
        jfcbdsn   = strip(storage(d2x(jfcb+000),44),"B"," ")
        jfcbelnm  = strip(storage(d2x(jfcb+044),8),"B"," ")
        if jfcbelnm <> "" then,
          fullname = jfcbdsn"("jfcbelnm")"
        else,
          fullname = jfcbdsn
        if (alcddname = ddname) then,
          do
            max_entry = max_entry + 1
            dd_dsn.max_entry = fullname
          end
      end
    tiotptr = D2C(C2D(tiotptr)+tiotelen)
    tiotelen = c2d(STORAGE(D2X(C2D(tiotptr)+0),1))
  end
  Return

/*-------------------------------------------------------------------*/
swareq:   Procedure
If right(c2x(Arg(1)),1) <> 'F' Then    /* Swa=Below ?                */
  Return c2d(Arg(1))+16                /* Yes, return sva+16         */
sva = c2d(Arg(1))                      /* Convert to decimal         */
tcb = ptr(540)                         /* Tcb psatold                */
jscb = ptr(tcb+180)                    /* Jscb tcbjscb               */
qmpl = ptr(jscb+244)                   /* Qmpl jscbqmpi              */
qmat = ptr(qmpl+24)                    /* Qmat qmadd                 */
Do While sva>65536
  qmat = ptr(qmat+12)                  /* Next qmat qmat+12          */
  sva=sva-65536                        /* 010006F -> 000006F         */
End
Return ptr(qmat+sva+1)+16

/*-------------------------------------------------------------------*/
ptr:  Return c2d(storage(d2x(Arg(1)),4)) /* Return a pointer         */

/*
  ISPEXEC  LMMSTATS DATAID(DATAID)   MEMBER(MBRNAME) VERSION(VER1)    +
                    MODLEVEL(MOD1)   CREATED(CDATE)  MODDATE(MDATE)   +
                    MODTIME(MTIME)   CURSIZE(CSIZE)  INITSIZE(ISIZE)  +
                    MODRECS(MRECS)   USER(USERID)    CREATED4(CDATE4) +
                    MODDATE4(MDATE4) DELETE

     LMMSTATS - NAME OF THE DIALOG SERVICE
     DATAID   - THE DATA-ID ASSOCIATED WITH THE DATA SET CONTAINING THE
              - MEMBER(S) WHOSE STATISTICS ARE BEING SET.
     MBRNAME  - THE MEMBER(S) NAMES WHOSE STATISTICS ARE BEING SET.
                FULLY OR PARTIALLY SPECIFIED MEMBER NAMES ARE ACCEPTED
                AS WELL AS '*' FOR ALL MEMBERS.
     VER1     - OPTIONAL, THE VERSION NUMBER, VALID VALUES ARE 1 - 99.
     MOD1     - OPTIONAL, THE MODIFICATION LEVEL, VALID VALUES ARE
                0 - 99.
     CDATE    - OPTIONAL, THE DATE THE MEMBER WAS CREATED. FORMAT MUST
                BE YY/MM/DD OR A NLS FORMAT.
     CDATE4   - OPTIONAL, THE DATE THE MEMBER WAS CREATED. FORMAT MUST
                BE YYYY/MM/DD OR A NLS FORMAT.
     MDATE    - OPTIONAL, THE DATE THE MEMBER WAS LAST MODIFIED. FORMAT
                MUST BE YY/MM/DD OR A NLS FORMAT.
     MDATE4   - OPTIONAL, THE DATE THE MEMBER WAS LAST MODIFIED. FORMAT
                MUST BE YYYY/MM/DD OR A NLS FORMAT.
     MTIME    - OPTIONAL, THE TIME THE MEMBER WAS LAST MODIFIED. FORMAT
                MUST BE HH:MM.
     CSIZE    - OPTIONAL, THE CURRENT NUMBER OF RECORDS IN THE MEMBER.
                VALID VALUES ARE 0 - 65535.
     ISIZE    - OPTIONAL, THE INITIAL NUMBER OF RECORDS IN THE MEMBER
                WHEN IT WAS CREATED. VALID VALUES ARE 0 - 65535.
     MRECS    - OPTIONAL, THE NUMBER OF RECORDS MODIFIED IN THE MEMBER.
                VALID RANGE IS 0 - 65535.
     USERID   - OPTIONAL, THE USERID OF THE USER WHO LAST MODIFIED THE
                DATA.
     DELETE   - OPTIONAL, INDICATES THAT STATISTICS ARE TO BE DELETED.

   EXAMPLE:  ISPEXEC LMMSTATS DATAID(&INDID ) MEMBER(MBRNAME)        +
                              VERSION(20)     MODLEVEL(0)
*/
  IF rc     <>  0 THEN    /* RETURN CODES -                        */
    DO                    /*  4 - NO MEMBERS MATCH PATTERN.        */
    END                   /*    - NO MEMBER IN DATA SET.           */
  ELSE                    /*  8 - MEMBER NOT FOUND.                */
    DO                    /* 10 - NO DATA SET ASSOCIATED WITH THE  */
    END                   /*      GIVEN DATA-ID.                   */
                          /* 12 - INVALID PARAMETER VALUE.         */
                          /*    - DATA SET IS NOT OPEN OR IS NOT   */
                          /*      PARTITIONED.                     */
                          /* 20 - SEVERE ERROR, UNABLE TO CONTINUE.*/
  Return


/* --------------------------------------------------------- */
/* Restore the default environment that was active upon      */
/* entry.                                                    */
/* --------------------------------------------------------- */
Exit:

  Call Show_IPCS_members     /* Using ISPF services of course  */

restore_exit:
  if (retc >< 0) then,
    do
      call putitout "Return code >< 0, =" retc"."
      call putitout "Exiting early!"
    end

  "SETDEF "con prt src trm "FLAG("flg")"

  If (Qual_retc = 0) Then
    "SETDEF "qual
No_restore_exit:
  Exit Retc

HALT:
  failed_condition = Condition("D")

  call putitout " "
  Call Putitout Copies("=",79)
  Call Putitout " "
  msgtext = " Halt of" strip(source_uc_exec_name)"."
  call put
  Call Putitout " "
      exit 4

error:
  failed_condition = Condition("D")
  msgtext = left("Hey, you really need to be in IPCS!",76)
  say msgtext
  msgtext = failed_condition
  say msgtext
  exit 12

Put: procedure expose MsgText  /*                        @P1C*/
  /* --------------------------------------------------------- */
  /* Function:  Put                                            */
  /*                                                           */
  /* Invoke the IPCS NOTE subcommand to transmit data to the   */
  /* terminal, IPCS print file or both, depending on the IPCS  */
  /* message routing default.                                  */
  /*                                                           */
  /* Input:     Data to transmit.                              */
  /*                                                           */
  /*                                                           */
  /* Output:    Data is transmitted.                           */
  /* --------------------------------------------------------- */

  "NOTE '"MsgText"' ASIS"     /*                           @P1C*/
  if (rc>0) then
    signal Put_Error
  return

Putitout:
  parse arg msgtext
  call put
  return

Put_Error:
  say msgtext
  return
./ ADD NAME=JCLDSCB  0666-07208-07208-2225-00001-00001-00000-DIR2UPDT
rexx_JCLDSCB:  /* We still need rexx in comment if read from SYSPROC */
/*                                       */
/* LIB: REXX(JCLDSCB)                    */
/* GDE: Use LISTDSI to get DCB and add   */
/*      as JCL.                          */
/* DOC: EXTRACT DATASET NAME ON          */
/*      CURSOR LOCATION.                 */
/*                                       */
THE_BEGINNING:
  ADDRESS ISREDIT "MACRO () NOPROCESS"
  ADDRESS ISPEXEC "CONTROL ERRORS RETURN"
  ADDRESS ISREDIT,
    "(myrw, mycl) = CURSOR"
  myrw = myrw + 0
  ADDRESS ISREDIT,
    "(myln) = Line" myrw
  parse var myln . "DSN=" fulldsn "("
  parse var fulldsn fulldsn ","
  parse var fulldsn fulldsn " "
  if (fulldsn >< "") then call launch_it
  exit 0
launch_it:
  fulldsn = "'"fulldsn"'"
  loc_opt = "VOLUME("some_vol")"
  loc_opt = ""
  dsi_opt = "DIRECTORY RECALL SMSINFO" /* last-reference date updated */
  quietly = MSG("OFF")
  dsi_rc=LISTDSI(fulldsn loc_opt dsi_opt)
  asitwas = MSG(quietly)
  if (dsi_rc > 4) then,
    DO
      ZERRHM = "*"
      ZERRALRM = "YES"
      ZERRSM = "LISTDSI"
      ZERRLM = "Failed, RC="dsi_rc
      ADDRESS ISPEXEC "VPUT (ZERRSM ZERRLM ZERRHM ZERRALRM) SHARED"
      ADDRESS ISPEXEC "SETMSG MSG(ISRZ002)"
      return
      if (sysreason > 0) then,
        DO
          ZERRHM = "*"
          ZERRALRM = "YES"
          ZERRSM = "LISTDSI"
          ZERRLM = "REASON > 4, SYSREASON="sysreason,
            sysmsglvl1 sysmsglvl2
          ADDRESS ISPEXEC "VPUT (ZERRSM ZERRLM ZERRHM ZERRALRM) SHARED"
          ADDRESS ISPEXEC "SETMSG MSG(ISRZ002)"
          return
        end
    end
/*
     rc           (0=good, 4=partial, 16=failure)
     sysdsname
     sysvolume
     sysunit
     sysdsorg     (ps, psu, da, dau, is, isu, po, pou, vs)
     sysrecfm     (u, f, v, t, b, s, a, m)
     syslrecl
     sysblksize
     syskeylen
     sysalloc
     sysused
     sysusedpages
     sysprimary
     sysseconds
     sysunits
     sysextents
     syscreate    yyyy/doy
     sysrefdate   yyyy/doy
     sysexdate    yyyy/doy
     syspassword  (none, read, write)
     sysracfa     (none, generic, discrete)
     sysupdated   (yes, no)
     systrkscyl   (for unit type)
     sysblkstrk   (for unit type)
     sysadirblk
     sysudirblk
     sysmembers
     sysreason
     sysmsglvl1
     sysmsglvl2
     sysdssms
     sysdataclass
     sysstorclass
     sysmgmtclass
*/
  select
    when (sysunits = "CYLINDER") then space_unit = "CYL"
    when (sysunits = "TRACK") then space_unit = "TRK"
    when (sysunits = "BLOCK") then space_unit = sysblksize
    Otherwise
      space_unit = "?????"
  end
  dirs = ""
  if (left(sysdsorg,2) = "PO") then,
    dirs = SYSADIRBLK + 0
  if (SYSADIRBLK = "NO_LIM") then dirs = "0"
  syscreate_date = chg_date(syscreate)
  sysrefdate_date = chg_date(sysrefdate)
  sysexdate_date = chg_date(sysexdate)
  if (sysreason > 0) then,
    DO
      mymsg = "//*" sysmsglvl2
      Address IsrEdit,
        "LINE_AFTER" myrw "= DATALINE '&mymsg'"
      MYRC=RC
      mymsg = "//*" sysmsglvl1
      Address IsrEdit,
        "LINE_AFTER" myrw "= DATALINE '&mymsg'"
      MYRC=RC
    end
  mymsg = "//*            DFSMS="sysdssms
  Address IsrEdit,
    "LINE_AFTER" myrw "= DATALINE '&mymsg'"
  MYRC=RC
  mymsg = "//*            DATACLAS="sysdataclass||,
    ",STORCLAS="sysstorclass",MGMTCLAS="sysmgmtclass
  Address IsrEdit,
    "LINE_AFTER" myrw "= DATALINE '&mymsg'"
  MYRC=RC
  mymsg = "//*            PASSWORD="syspassword||,
    ",RACF="sysracfa
  Address IsrEdit,
    "LINE_AFTER" myrw "= DATALINE '&mymsg'"
  MYRC=RC
  mymsg = "//*            CREDATE="syscreate_date||,
    ",REFDATE="sysrefdate_date",EXPDATE="sysexdate_date
  Address IsrEdit,
    "LINE_AFTER" myrw "= DATALINE '&mymsg'"
  MYRC=RC
  mymsg = "//*            USED="sysalloc sysunits
  if ((left(sysdsorg,2) = "PO") & (SYSADIRBLK = "NO_LIM")) then,
    mymsg = mymsg,
    "PDSE_PAGES("sysusedpages")"
  if ((left(sysdsorg,2) = "PO") & (SYSADIRBLK >< "NO_LIM")) then,
    mymsg = mymsg,
    "PDS_DIR("sysused")"
  Address IsrEdit,
    "LINE_AFTER" myrw "= DATALINE '&mymsg'"
  MYRC=RC
  mymsg = "//*            DCB=(DSORG="sysdsorg ||,
    ",RECFM="sysrecfm",BLKSIZE="sysblksize",LRECL="syslrecl")"
  Address IsrEdit,
    "LINE_AFTER" myrw "= DATALINE '&mymsg'"
  MYRC=RC
  mymsg = "//*           ",
    "SPACE=("space_unit",("sysprimary","sysseconds","dirs")),"
  Address IsrEdit,
    "LINE_AFTER" myrw "= DATALINE '&mymsg'"
  MYRC=RC
  mymsg = "//*            UNIT="sysunit",VOL=SER="sysvolume","
  Address IsrEdit,
    "LINE_AFTER" myrw "= DATALINE '&mymsg'"
  MYRC=RC
  if (SYSADIRBLK = "NO_LIM") then
    do
      mymsg = "//             DSNTYPE=LIBRARY"
      Address IsrEdit,
        "LINE_AFTER" myrw "= DATALINE '&mymsg'"
      MYRC=RC
    end
  IF (MYRC > 4) THEN,
    DO
      ZERRHM = "*"
      ZERRALRM = "YES"
      ZERRSM = "LINE_AFTER"
      ZERRLM = "Failed to insert line, RC="MYRC
      ADDRESS ISPEXEC "VPUT (ZERRSM ZERRLM ZERRHM ZERRALRM) SHARED"
      ADDRESS ISPEXEC "SETMSG MSG(ISRZ002)"
    END
  return
/*                                                    */
chg_date: Procedure
  parse arg my_date
  parse var my_date my_year "/" my_doy
  if (my_year = "0000") then return "NO_EXP"
  my_date = Date("U",right(my_year,2)||my_doy,"J")
  return my_date
/*                                                    */
./ ADD NAME=JOBCARD  0666-07210-07210-0909-00001-00001-00000-DIR2UPDT
rexx_JOBCARD:  /* We still need rexx in comment if read from SYSPROC */
/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

 Dataset:  REXX(JOBCARD)
 Author:   "Kenneth Tomiak"<CBT_Ken@KTomiak.biz>
 Syntax:   JOBCARD {arguments ...}
 Overview: INSERT A STANDARD JOBCARD.

=======================================================================

 History of Modifications
 ------------------------
  When     Who      What you did
  -------- -------- ---------------------------------------------------
  20070729 KTomiak  01.01 Standardizing Rexx_Initialize routine
  20070610 KTOMIAK  01.00 Original code.

=======================================================================

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */

  ADDRESS ISREDIT 'MACRO PROCESS'
  rexxpgm_version = "01.01"
  Parse Arg all_my_arguments
  Numeric Digits 12

rexx_Main_JOBCARD:
  return_code = rexx_Initialize()
  If (return_code = 0) then,
    Do
      return_code = rexx_Process()
      return_code = rexx_Termination()
    End
  Return 0

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
 In this routine we open any files and initialize any
 constants we might need.
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
rexx_Initialize:
  PARSE VERSION,
    version_rexx_name,
    version_rexx_version,
    version_rexx_date
  PARSE SOURCE,
    source_host_env,
    source_call_type,
    source_uc_exec_name,
    source_hostdd,
    source_hostdsn,
    source_nf_exec_name,
    source_initial_cmd_env,
    source_asid_name,
    source_char8_user_token,
    source_hostother
  Address_Environment = Address()
  job_specs = rexx_jobspecs()
  sysvar_sysuid = SYSVAR("SYSUID")
  sysvar_sysenv = SYSVAR("SYSENV")
/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  say ""
  say Copies("=",55)
  say left("=" source_uc_exec_name rexxpgm_version,53) "="
  say left("=" "executing under" source_host_env,53) "="
  say left("=" "as a" source_call_type,53) "="
  say left("=  on" date() "at" time()".",53) "="
  say Copies("=",55)
  say ""
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
  return_code = 0

  If (source_host_env >< "TSO") Then,
    Do
      Say "Wrong host environment" source_host_env
      return_code = 16
    End
  ADDRESS ISPEXEC 'CONTROL ERRORS RETURN'
  ADDRESS ISREDIT '(DSN) = DATASET'
  ADDRESS ISREDIT '(MBR) = MEMBER'
  call start_of_data
  line_f = sx + 3
  call end_of_data
  line_x = sx - 4
  l_ctr = 0

  Return return_code

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
 In this routine we do our processing.
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
rexx_Process:
  do sx = line_f to line_x
    IN = LEFT(SOURCELINE(SX),72)
    call insertline
  end
  r = right(mbr,1)
  sys_sysuid = SYSVAR("SYSUID")
  pgmr = right(dsn"("mbr")",20)
  ADDRESS ISREDIT "C '//SYSUID' '//"sys_sysuid"!' first"
  ADDRESS ISREDIT "C 'DSN(' '"dsn"(' first"
  ADDRESS ISREDIT "C '(DSN)' '("dsn")' first"
  ADDRESS ISREDIT "C 'PGMR' '"pgmr"' first"
  ADDRESS ISREDIT "C 'MBR' '"mbr"' first"
  ADDRESS ISREDIT "C '/#/' '//*' 1 ALL"
  ADDRESS ISREDIT "C '/#J' '/*J' 1 ALL"
  ADDRESS ISREDIT "C '!' '"r"' FIRST"
  ADDRESS ISREDIT "UP MAX"
  ADDRESS ISREDIT "REN"
  ADDRESS ISREDIT "RES"
  Return return_code

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
 In this routine we close files and finish up.
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
rexx_Termination:
  Return return_code

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
 Place any of your subroutines and procedures below this.
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
rexx_jobspecs:
  /*---------------------------------------------------------------*/
  /* ADDRESSABILITY TO CVT FROM PSA                                */
  /*---------------------------------------------------------------*/
  PTR2PSA = 0
  CVTPTR = STORAGE(D2X(PTR2PSA + 16),4)
  /*---------------------------------------------------------------*/
  /* ADDRESSABILITY TO SMCA, THEN GET SMF SYSTEM ID                */
  /*---------------------------------------------------------------*/
  CVTSMCA = STORAGE(D2X(C2D(CVTPTR)+197),3)
  SMFID = STORAGE(D2X(C2D(CVTSMCA)+16),4)
  /*---------------------------------------------------------------*/
  /* GET JOBNAME, STEP, AND PROCEDURE                              */
  /*---------------------------------------------------------------*/
  PSATOLD  = STORAGE(21C,4)                    /* POINTER TO TCB   */
  PTRTIOT  = STORAGE(D2X(C2D(PSATOLD)+12),4)   /* POINTER TO TIOT  */
  JOBNAME  = STORAGE(D2X(C2D(PTRTIOT)),8)
  STEPNAME = STORAGE(D2X(C2D(PTRTIOT)+8),8)
  PROCNAME = STORAGE(D2X(C2D(PTRTIOT)+16),8)
  Tcbjscbb = Storage(D2x(C2d(Psatold)+181),3)              /* jscb */
  jscbssib = STORAGE(D2X(C2D(tcbjscbb)+316),4)      /* Ptr to SSIB */
  ssibjbid = STORAGE(D2X(C2D(jscbssib)+12),8)    /* job identifier */
  Return JOBNAME SSIBJBID STEPNAME PROCNAME
/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
 describe your routines here
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
/*                                                    */

whichlineami:
  sx = sigl
  return
/*                                                    */
insertline:
  Address IsrEdit "LINE_AFTER" l_ctr "= (IN)"
  l_ctr = l_ctr + 1
  return

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
__DATA__
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
start_of_data:
  call whichlineami
  return
/*
//SYSUID  JOB (999,CSI,KTOMIAK,60,9999,0,,1,,60),
//             'KENNETH E TOMIAK',
//             CLASS=A,MSGCLASS=X,TIME=1440,
//             REGION=32M,NOTIFY=&SYSUID
/#/
/#JOBPARM SYSAFF=*
/#JOBPARM LINES=9999
/#/
/#/MYPROCS JCLLIB ORDER=(DSN)
/#/
/#/ LIB:    DSN=dsn(mbr)
/#/ AUTHOR: KENNETH E TOMIAK <CBT_Ken@KTomiak.biz>
/#/ GUIDE:  THIS JOB WILL ......
/#/
*/
end_of_data:
  call whichlineami
  return
./ ADD NAME=OBJ2HEX  0666-07210-07210-0910-00001-00001-00000-DIR2UPDT
rexx_OBJ2HEX:  /* We still need rexx in comment if read from SYSPROC */
  rexxpgm_version = "01.01"
/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

  Dataset:  REXX(OBJ2HEX)
  Author:   "Kenneth Tomiak"<CBT_Ken@KTomiak.biz>
  Syntax:   OBJ2HEX (input_ddname output_ddname)
  Overview: Reads any 80 byte record and wraps it in rexx code to
            reconstruct it back later.

=======================================================================

 History of Modifications
 ------------------------
  When     Who      What you did
  -------- -------- ---------------------------------------------------
  20070729 KTomiak  01.01 Standardizing Rexx_Initialize routine
  20070528 KTOMIAK  01.00 Original code.

=======================================================================

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */

  Parse Arg all_my_arguments
  Numeric Digits 12

rexx_Main_OBJ2HEX:
  return_code = rexx_Initialize()
  If (return_code = 0) then,
    Do
      return_code = rexx_Process()
      return_code = rexx_Termination()
    End
  Return 0

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
 In this routine we open any files and initialize any
 constants we might need.
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
rexx_Initialize:
  PARSE VERSION,
    version_rexx_name,
    version_rexx_version,
    version_rexx_date
  PARSE SOURCE,
    source_host_env,
    source_call_type,
    source_uc_exec_name,
    source_hostdd,
    source_hostdsn,
    source_nf_exec_name,
    source_initial_cmd_env,
    source_asid_name,
    source_char8_user_token,
    source_hostother
  job_specs = rexx_jobspecs()
  sysvar_sysuid = SYSVAR("SYSUID")
  sysvar_sysenv = SYSVAR("SYSENV")
  say ""
  say Copies("=",55)
  say left("=" source_uc_exec_name rexxpgm_version,53) "="
  say left("=" "executing under" source_host_env,53) "="
  say left("=" "as a" source_call_type,53) "="
  say left("=  on" date() "at" time()".",53) "="
  say Copies("=",55)
  say ""
  return_code = 0

  If (source_host_env >< "TSO") Then,
    Do
      Say "Wrong host environment" source_host_env
      return_code = 16
    End

  Parse var all_my_arguments dd_in dd_ot .
  if (datatype(dd_in) = "NUM") then,
    do
      say "Setting default input and output DDnames."
      dd_in = "OBJIN"
      dd_ot = "HEXOT"
    end
  if (datatype(dd_ot) = "NUM") then,
    do
      say "Setting default output DDname."
      dd_ot = "HEXOT"
    end
  if (dd_in = "") then,
    do
      say "Setting default input and output DDnames."
      dd_in = "OBJIN"
      dd_ot = "HEXOT"
    end
  if (dd_ot = "") then,
    do
      say "Setting default output DDname."
      dd_ot = "HEXOT"
    end

  say "//DDIN:"dd_in"."
  say "//DDOT:"dd_ot"."
  text_out.0 = 0
  call add_rexx_code

  text_in.0 = 0
  "EXECIO * DISKR" dd_in "(FINIS STEM TEXT_IN.)"
  read_rc = RC
  if (read_rc >< 0) then,
    Do
      say "Encountered problems reading //DD:"dd_in"."
      say "RC("read_rc") >< 0"
      return_code = read_rc
    end
  say "Read" text_in.0 "records."

  Return return_code

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
 In this routine we do our processing.
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
rexx_Process:
  if (text_in.0 = 0) then,
    do
      say "//DD:"dd_in "appears to be a null file."
      return_code = 4
      return 4
    end
  hex_text = 0
  do text_ix = 1 to text_in.0
    line_1 = ""
    line_2 = ""
    text_hex = c2x(text_in.text_ix)
    do while text_hex >< ""
      parse var text_hex hex_odd +1 hex_even +1 text_hex
      line_1 = line_1""hex_odd
      line_2 = line_2""hex_even
    end
    text_out.0 = out_text(line_1)
    text_out.0 = out_text(line_2)
    hex_text = hex_text + 2
  end
  Return return_code

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
 In this routine we close files and finish up.
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
rexx_Termination:
  text_out.0 = out_text("ENDDATA*/")
  text_out.0 = out_text("  ")
  "EXECIO * DISKW" dd_ot "(FINIS STEM TEXT_OUT.)"
  write_rc = RC
  if (write_rc >< 0) then,
    Do
      say "Encountered problems writing //DD:"dd_ot"."
      say "RC("write_rc") >< 0"
      return_code = write_rc
    end
  say "Wrote" hex_text   "records."
  say "Wrote" text_out.0 "records, including HEX2OBJ extractor."
  say "E-O-R"
  Return return_code

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
 Place any of your subroutines and procedures below this.
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
rexx_jobspecs:
  /*---------------------------------------------------------------*/
  /* ADDRESSABILITY TO CVT FROM PSA                                */
  /*---------------------------------------------------------------*/
  PTR2PSA = 0
  CVTPTR = STORAGE(D2X(PTR2PSA + 16),4)
  /*---------------------------------------------------------------*/
  /* ADDRESSABILITY TO SMCA, THEN GET SMF SYSTEM ID                */
  /*---------------------------------------------------------------*/
  CVTSMCA = STORAGE(D2X(C2D(CVTPTR)+197),3)
  SMFID = STORAGE(D2X(C2D(CVTSMCA)+16),4)
  /*---------------------------------------------------------------*/
  /* GET JOBNAME, STEP, AND PROCEDURE                              */
  /*---------------------------------------------------------------*/
  PSATOLD  = STORAGE(21C,4)                    /* POINTER TO TCB   */
  PTRTIOT  = STORAGE(D2X(C2D(PSATOLD)+12),4)   /* POINTER TO TIOT  */
  JOBNAME  = STORAGE(D2X(C2D(PTRTIOT)),8)
  STEPNAME = STORAGE(D2X(C2D(PTRTIOT)+8),8)
  PROCNAME = STORAGE(D2X(C2D(PTRTIOT)+16),8)
  Tcbjscbb = Storage(D2x(C2d(Psatold)+181),3)              /* jscb */
  jscbssib = STORAGE(D2X(C2D(tcbjscbb)+316),4)      /* Ptr to SSIB */
  ssibjbid = STORAGE(D2X(C2D(jscbssib)+12),8)    /* job identifier */
  Return JOBNAME SSIBJBID STEPNAME PROCNAME

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
 Adds text to a stem variable
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
out_text:
  parse arg text_line
  text_next = text_out.0 + 1
  text_out.text_next = text_line
  return text_next

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
 Adds the rexx code to convert the member back.
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
add_rexx_code:
  sigl_record = sigl + 25
  rexx_code = "YES"
  process_data = "NO"
  DO WHILE rexx_code = "YES"
    SIGL_RECORD=SIGL_RECORD+1
    MY_DATA=SOURCELINE(SIGL_RECORD)
    IF (MY_DATA="ENDREXX*/") THEN,
      DO
        rexx_code="NO"
        LEAVE
      END
    IF (MY_DATA="/*BEGINREXX") THEN,
      DO
        SIGL_RECORD=SIGL_RECORD+1
        PROCESS_DATA="YES"
        ITERATE
      END
    IF (PROCESS_DATA="YES") THEN,
      DO
        text_out.0 = out_text(my_data)
      END
  END
  return

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
__DATA__
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
/*BEGINREXX
*/
rexx_HEX2OBJ:  /* We still need rexx in comment if read from SYSPROC */
  hex2obj_version = "01.00"
/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

  Dataset:  REXX(HEX2OBJ)
  Author:   "Kenneth Tomiak"<CBT_Ken@KTomiak.biz>
  Syntax:   HEX2OBJ (output_ddname)
  Overview: Reconstructs a member that was saved in hexadecimal
            format.

=======================================================================

 History of Modifications
 ------------------------
  When     Who      What you did
  -------- -------- ---------------------------------------------------
  20070528 KTOMIAK  Original code.

=======================================================================

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */

  Parse Arg all_my_arguments
  Numeric Digits 12

rexx_Main_HEX2OBJ:
  return_code = rexx_Initialize()
  If (return_code = 0) then,
    Do
      return_code = rexx_Process()
      return_code = rexx_Termination()
    End
  Return 0

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
 In this routine we open any files and initialize any
 constants we might need.
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
rexx_Initialize:
  PARSE VERSION,
    rexx_version,
    rexx_level,
    rexx_date
  PARSE SOURCE,
    source_host_env,
    source_call_type,
    source_uc_exec_name,
    source_hostdd,
    source_hostdsn,
    source_nf_exec_name,
    source_initial_cmd_env,
    source_asid_name,
    source_char8_user_token,
    source_hostother
  job_specs = rexx_jobspecs()
  sysvar_sysuid = SYSVAR("SYSUID")
  sysvar_sysenv = SYSVAR("SYSENV")
  say ""
  say Copies("=",55)
  say left("=" job_specs,53) "="
  say left("=" source_uc_exec_name hex2obj_VERSION,53) "="
  say left("=",
    "as a" source_call_type,53) "="
  say left("=  on" date() "at" time()".",53) "="
  say Copies("=",55)
  say ""
  return_code = 0

  If (source_host_env >< "TSO") Then,
    Do
      Say "Wrong host environment" source_host_env
      return_code = 16
    End

  Parse var all_my_arguments dd_ot .
  if (datatype(dd_ot) = "NUM") then,
    do
      say "Setting default output DDname."
      dd_ot = "OBJOT"
    end
  if (dd_ot = "") then,
    do
      say "Setting default output DDname."
      dd_ot = "OBJOT"
    end

  text_out.0 = 0

  text_in.0 = 0
  call add_rexx_code
  say "Read" text_in.0 "records."

  Return return_code

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
 In this routine we do our processing.
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
rexx_Process:
  if (text_in.0 = 0) then,
    do
      say source_uc_exec_name "is missing the data."
      return_code = 4
      return 4
    end
  do text_ix = 1 to text_in.0 by 2
    line_1 = ""
    text_1 = text_in.text_ix
    next_ix = text_ix + 1
    text_2 = text_in.next_ix
    do char_ix = 1 to length(text_1)
      char_1 = substr(text_1,char_ix,1)
      char_2 = substr(text_2,char_ix,1)
      line_1 = line_1""char_1""char_2
    end
    text_out.0 = out_text(x2c(line_1))
  end
  Return return_code

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
 In this routine we close files and finish up.
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
rexx_Termination:
  "EXECIO * DISKW" dd_ot "(FINIS STEM TEXT_OUT.)"
  write_rc = RC
  if (write_rc >< 0) then,
    Do
      say "Encountered problems writing //DD:"dd_ot"."
      say "RC("write_rc") >< 0"
      return_code = write_rc
    end
  say "Wrote" text_out.0 "records."
  Return return_code

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
 Place any of your subroutines and procedures below this.
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
rexx_jobspecs:
  /*---------------------------------------------------------------*/
  /* ADDRESSABILITY TO CVT FROM PSA                                */
  /*---------------------------------------------------------------*/
  PTR2PSA = 0
  CVTPTR = STORAGE(D2X(PTR2PSA + 16),4)
  /*---------------------------------------------------------------*/
  /* ADDRESSABILITY TO SMCA, THEN GET SMF SYSTEM ID                */
  /*---------------------------------------------------------------*/
  CVTSMCA = STORAGE(D2X(C2D(CVTPTR)+197),3)
  SMFID = STORAGE(D2X(C2D(CVTSMCA)+16),4)
  /*---------------------------------------------------------------*/
  /* GET JOBNAME, STEP, AND PROCEDURE                              */
  /*---------------------------------------------------------------*/
  PSATOLD  = STORAGE(21C,4)                    /* POINTER TO TCB   */
  PTRTIOT  = STORAGE(D2X(C2D(PSATOLD)+12),4)   /* POINTER TO TIOT  */
  JOBNAME  = STORAGE(D2X(C2D(PTRTIOT)),8)
  STEPNAME = STORAGE(D2X(C2D(PTRTIOT)+8),8)
  PROCNAME = STORAGE(D2X(C2D(PTRTIOT)+16),8)
  Tcbjscbb = Storage(D2x(C2d(Psatold)+181),3)              /* jscb */
  jscbssib = STORAGE(D2X(C2D(tcbjscbb)+316),4)      /* Ptr to SSIB */
  ssibjbid = STORAGE(D2X(C2D(jscbssib)+12),8)    /* job identifier */
  Return JOBNAME SSIBJBID STEPNAME PROCNAME

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
 Adds text to a stem variable
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
in_text:
  parse arg text_line
  text_next = text_in.0 + 1
  text_in.text_next = text_line
  return text_next

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
 Adds text to a stem variable
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
out_text:
  parse arg text_line
  text_next = text_out.0 + 1
  text_out.text_next = text_line
  return text_next

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
 Adds the rexx code to convert the member back.
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
add_rexx_code:
  sigl_record = sigl + 25
  rexx_code = "YES"
  process_data = "NO"
  DO WHILE rexx_code = "YES"
    SIGL_RECORD=SIGL_RECORD+1
    MY_DATA=SOURCELINE(SIGL_RECORD)
    IF (MY_DATA="ENDDATA*/") THEN,
      DO
        rexx_code="NO"
        LEAVE
      END
    IF (MY_DATA="/*BEGINDATA") THEN,
      DO
        PROCESS_DATA="YES"
        ITERATE
      END
    IF (PROCESS_DATA="YES") THEN,
      DO
        text_in.0 = in_text(my_data)
      END
  END
  return

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
__DATA__
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
/*BEGINDATA
ENDREXX*/

./ ADD NAME=PDS2UPDT 0666-07210-07210-0911-00001-00001-00000-DIR2UPDT
rexx_PDS2UPDT: /* We still need rexx in comment if read from SYSPROC */
  rexxpgm_version = "03.01"
/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

=======================================================================

  Dataset: REXX(PDS2UPDT)
  Author:  KTomiak
  Contact: "Kenneth Tomiak"<CBT_KEN@KTomiak.biz>
  Syntax:  PDS2UPDT (filename)
           filename - a PDS or PDSE
  Purpose: THIS CODE USES ISPF LIBRARY SERVICES TO GATHER ALL
           MEMBERS AND CREATES A SEQUENTIAL DATA WITH IEBUPDTE
           CONTROL CARDS AHEAD OF EACH ONE.
  Output: &sysuid..SEQOUT.&filename

  History of Modifications
  ------------------------
  When     Who      What you did
  -------- -------- ---------------------------------------------------
  20070729 KTomiak  03.01 Standardizing Rexx_Initialize routine
  20070715 KTomiak  03.00 Well, a long time ago, but this is now being
                          released for www.CBTTAPE.org FILE760.
  20000926 KTomiak  01.00 Close to original code date.

=======================================================================

STANDARD GLOBAL DISCLAIMER
The author explicitly disavows any claim whatsoever about the
correctness or functionality of this program, and disclaims liability
for anything and everything bad that might happen in connection with,
before, during, or after using it.  I have tried to make it work right,
and I am personally pretty confident that it does, but everybody makes
mistakes, so if you use it, you do so at your own risk.

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */

  Parse Arg dataset nothing
  ADDRESS ISPEXEC "CONTROL ERRORS RETURN"
  MYCTR = 0
  PDSDSN = STRIP(DATASET,"B","'")
  ADDRESS ISPEXEC "LMINIT DATAID(DATAID)",
    "DATASET('"PDSDSN"') ENQ(SHR)"
  MYCC = RC
  IF (MYCC >< 0) THEN ,
    DO
      ZERRSM = "FILE IN USE"
      ZERRLM = "THE FILE" PDSDSN "IS IN USE"
      ADDRESS ISPEXEC "SETMSG MSG(ISRZ002)"
      SIGNAL ABNEXIT
    END
      X = LISTDSI("'"PDSDSN"'")
  SAY PDSDSN
  ADDRESS ISPEXEC "LMOPEN DATAID("DATAID")",
    "OPTION(INPUT) LRECL(MYRECLN)"
  MYCC = RC
  IF (MYCC > 0) THEN ,
    DO
      ZERRSM = "FILE FAILED TO OPEN"
      ZERRLM = "THE FILE" PDSDSN "FAILED TO OPEN RC="MYCC
      ADDRESS ISPEXEC "SETMSG MSG(ISRZ002)"
      SIGNAL ABNEXIT
    END
  myrecln = myrecln + 0
  NUM_LVLS = 0
  REAL_DSN = pdsdsn
  DO WHILE REAL_DSN <> ""
    NUM_LVLS = NUM_LVLS + 1
    PARSE VAR REAL_DSN LQ '.' REAL_DSN
    LQ.NUM_LVLS = LQ
  END
  sysuid = sysvar("SYSUID")
  LQ.0 = NUM_LVLS
  OUT_DSN = SYSUID".SEQOUT"
  DO IX = 1 TO NUM_LVLS
    Ll = LQ.IX
    IF Ll = SYSUID THEN ITERATE
    OUT_DSN = OUT_DSN"."Ll
  END
  say out_dsn
  DSN_OK = SYSDSN("'"OUT_DSN"'")
  IF DSN_OK = "OK" THEN,
    DO
      ADDRESS TSO "ALLOC FILE(SEQOUT) DA('"OUT_DSN"') MOD",
        "TRACKS SPACE(250 150) REUSE"
      MYRC=RC
    END
  ELSE,
    DO
      VBLRECL = SYSLRECL + 4
      ADDRESS TSO "ALLOC FILE(SEQOUT) DA('"OUT_DSN"')",
        "NEW CATALOG RECFM(F B) REUSE",
        "BLKSIZE(0) LRECL("MYRECLN")",
        "TRACKS SPACE(250 150)",
        "UNIT(SYSALLDA)"
   /*   "UNIT(SYSALLDA) VOLUME("SYSVOLUME")"  */
      MYRC=RC
    END
  IF MYRC > 0 THEN,
    DO
          SAY "COULD NOT CREATE" out_dsN "RC="MYRC
          SIGNAL FREE_FILES
    END
  PDSMBR = ""
PDSREAD:
  ADDRESS ISPEXEC "LMMLIST DATAID("DATAID")",
    "OPTION(LIST) MEMBER(PDSMBR) STATS(YES)"
  MYCC = RC
  IF (MYCC > 0) THEN ,
    DO
      SIGNAL NORMEXIT
    END
  MEMBR       = PDSMBR
  isp_cmd = "LMMFind"
  Address IspExec,
    "LMMFIND DATAID("dataid") MEMBER("pdsmbr")",
    "LRECL(reclen) RECFM(recfmvr)",
    "STATS(NO)"
  IspExec_rc = rc
  Call check_IspExec
/* Return codes                          */
/*  8 - Member not found                 */
/* 10 - No data set or file associated   */
/*      with the given data-id           */
/* 12 - Data set or file not open or     */
/*      not open for input               */
/*    - Data set is not an ISPF library  */
/*      or MVS partitioned data set      */
/*    - CMS file is not a maclib, txtlib,*/
/*      or ISPF library                  */
/*    - Invalid parameter value          */
/*    - LOCK specified                   */
/* 16 - Truncation or translation        */
/*      error in accessing dialog        */
/*      variables                        */
/* 20 - Severe error                     */
  MYCTR = MYCTR + 1
  ispf_stats = ""
  seq = right("0000"myctr,4)
  if (zluser >< "") then,
    do
      parse var zlcdate yy "/" mm "/" dd
      udate = mm"/"dd"/"yy
      zlcjdate = yy""Right("000"Date("D",udate,"U"),3)
      parse var zlmdate yy "/" mm "/" dd
      udate = mm"/"dd"/"yy
      zlmjdate = yy""Right("000"Date("D",udate,"U"),3)
      zlmdtime = Left(zlmtime,2)""Right(zlmtime,2)
      zlidnorc = right("00000"space(zlinorc,0),5)
      zlcdnorc = right("00000"space(zlcnorc,0),5)
      zlmdnorc = right("00000"space(zlMnorc,0),5)
      ispf_stats = ZLVERS""ZLMOD"-"ZLCJDATE"-"ZLMJDATE"-"ZLMdTIME
      ispf_stats = ispf_stats"-"ZLIdNORC"-"ZLCdNORC
      ispf_stats = ispf_stats"-"ZLMdNORC"-"ZLUSER
    end
  QUEUE "./ ADD NAME="LEFT(MEMBR,8) ISPF_STATS
  isp_cmd = "LMGet  "
lmget_loop:
  Address IspExec,
    "LMGET DATAID("dataid") MODE(INVAR) DATALOC(locvar)",
    "DATALEN(lenvar) MAXLEN(32760)"
  IspExec_rc = rc
  If (IspExec_rc = 8) Then,
    Do
      Signal lmget_End
    End
  QUEUE LOCVAR
/* Return codes                     */
/*  8 - End-of-file condition       */
/* 10 - No data set or file         */
/*      associated with the dataid  */
/* 12 - Data file not open          */
/*    - Data file not open for      */
/*      input                       */
/*    - LMMFIND was not done for a  */
/*      partitioned data set        */
/*    - Invalid parameter value     */
/* 16 - Truncation or translation   */
/*      error in accessing dialog   */
/*      variables                   */
/* 20 - Severe error                */
  loadmem.0 = lmget_ctr
  Signal lmget_loop
lmget_End:
  "EXECIO" QUEUED() "DISKW SEQOUT"
  SIGNAL PDSREAD
ABNEXIT:
  RC = 4
NORMEXIT:
  QUEUE "./ ENDUP"
  SAY  MYCTR "MEMBERS PROCESSED"
  "EXECIO" QUEUED() "DISKW SEQOUT (FINIS"
free_files:
  "FREE FILE(SEQOUT)"
  ADDRESS ISPEXEC "LMMLIST DATAID("DATAID") OPTION(FREE)"
  ADDRESS ISPEXEC "LMCLOSE DATAID("DATAID")"
  ADDRESS ISPEXEC "LMFREE DATAID("DATAID")"
EXITIT:
  SAY "EXITING PDS2UPDT."
  EXIT RC
check_IspExec:
  If (IspExec_rc >< 0) Then,
    Do
      ZERRSM = "IspExec" IspExec_rc
      ZERRLM = "IspExec"isp_cmd "request failed, rc="IspExec_rc"."
      If (jobtype = "TSU") Then,
        Do
          isp_cmd = "SetMsg"
          Address IspExec "SETMSG MSG(ISRZ002)"
        End
      Else,
        Do
          Say ZERRLM
        End
      exit ispexec_rc
    End
  Return
./ ADD NAME=PDS2XMIT 0666-07210-07210-0912-00001-00001-00000-DIR2UPDT
rexx_PDS2XMIT: /* We still need rexx in comment if read from SYSPROC */
/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

=======================================================================

  Dataset: REXX(PDS2XMIT)
  Author:  KTomiak
  Contact: "Kenneth Tomiak"<CBT_KEN@KTomiak.biz>
  Syntax:  PDS2XMIT (filename)
           filename - a PDS or PDSE
  PURPOSE: THIS CODE USES TSO TRANSMIT, WHICH INVOKES IEBCOPY,
           TO CONVERT A PDS OR PDSE INTO A SEQUENTIAL DATASET.
  Output: &sysuid..XMIT.&filename..XMI

  History of Modifications
  ------------------------
  When     Who      What you did
  -------- -------- ---------------------------------------------------
  20070729 KTomiak  02.01 Standardizing Rexx_Initialize routine
  20070715 KTomiak  02.00 Well, a long time ago, but this is now being
                          released for www.CBTTAPE.org FILE760.

=======================================================================

STANDARD GLOBAL DISCLAIMER
The author explicitly disavows any claim whatsoever about the
correctness or functionality of this program, and disclaims liability
for anything and everything bad that might happen in connection with,
before, during, or after using it.  I have tried to make it work right,
and I am personally pretty confident that it does, but everybody makes
mistakes, so if you use it, you do so at your own risk.

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */

  ADDRESS ISREDIT "MACRO (locfile rmtfile options) NOPROCESS"
  rexxpgm_version = "02.01"
  ADDRESS ISPEXEC "CONTROL ERRORS RETURN"
  if (locfile = "LOCFILE") then
    do
      parse arg locfile rmtfile options
    end
  call who_am_i
  call where_am_i
  drc = 0
  bitbuckt = "Z"
  touser = sys_sysuid
  call alloc_plib
  call XMIT2_a_file
  call free_plib
  exit 0

XMIT2_a_file:
  if (sys_sysenv = "FORE") then,
    do
      Address ispexec "DISPLAY PANEL("uc_exec_name")"
      drc = rc
    end
  else,
    do
      say ""
      say Copies("=",55)
      say left("=" source_uc_exec_name rexxpgm_version,53) "="
      say left("=" "executing under" source_host_env,53) "="
      say left("=" "as a" source_call_type,53) "="
      say left("=  on" date() "at" time()".",53) "="
      say Copies("=",55)
      say ""
    end
  if (drc =  8) then,
    do
      return
    end
  if (drc >  8) then,
    do
      ZERRHM = "*"
      ZERRALRM = "YES"
      ZERRSM = uc_exec_name "terminating"
      ZERRLM = "Either you pressed END or the display panel failed."
      ADDRESS ISPEXEC "VPUT (ZERRSM ZERRLM ZERRHM ZERRALRM) SHARED"
      ADDRESS ISPEXEC "SETMSG MSG(ISRZ002)"
      return
    end
  NEWSTACK
  say ""
  say "Transmit" locfile "into" rmtfile"."
  say ""
  queue "* Control Section"
  queue ":altctl. '"sys_sysuid".NICKNAME'"
  if (prolog01 >< "") then,
    queue ":prolog."prolog01
  if (prolog02 >< "") then,
    queue ":prolog."prolog02
  if (prolog03 >< "") then,
    queue ":prolog."prolog03
  if (prolog04 >< "") then,
    queue ":prolog."prolog04
  if (prolog05 >< "") then,
    queue ":prolog."prolog05
  if (prolog06 >< "") then,
    queue ":prolog."prolog06
  if (prolog07 >< "") then,
    queue ":prolog."prolog07
  if (prolog08 >< "") then,
    queue ":prolog."prolog08
  if (prolog09 >< "") then,
    queue ":prolog."prolog09
  if (epilog01 >< "") then,
    queue ":epilog."epilog01
  if (epilog02 >< "") then,
    queue ":epilog."epilog02
  if (epilog03 >< "") then,
    queue ":epilog."epilog03
  if (epilog04 >< "") then,
    queue ":epilog."epilog04
  if (epilog05 >< "") then,
    queue ":epilog."epilog05
  if (epilog06 >< "") then,
    queue ":epilog."epilog06
  if (epilog07 >< "") then,
    queue ":epilog."epilog07
  if (epilog08 >< "") then,
    queue ":epilog."epilog08
  if (epilog09 >< "") then,
    queue ":epilog."epilog09
  queue ":nolog"
  queue "* Nicknames Section"
  queue ":nick.You"
  queue ":name. PDS2XMIT"
  queue ":node."
  queue ":userid."sys_sysuid
  queue ":addr.Where you get mail"
  queue "      Town, State zip-plus4"
  queue "      Country"
  queue ":nolog"
  numq = Queued()
  quiet = Outtrap("HLP.")
  "delete NAMES.TEXT"
  "delete '"rmtfile"'"
  quiet = Outtrap("OFF")
  "ALLOC FILE(NAMES) SPACE(1 1) RECFM(V B)",
    "TRACKS",
    "BLKSIZE(0) LRECL(255) DSORG(PS) NEW DELETE REUSE",
    "UNIT(SYSALLDA) DIR(0) DATASET(NAMES.TEXT)"
  "ALLOC FILE(DOTXMI) SPACE("rmt_space") RECFM(F B)",
    "TRACKS NEW CATALOG REUSE",
    "BLKSIZE(3120) LRECL(80) DSORG(PS)",
    "UNIT(SYSALLDA) DIR(0) DATASET('"rmtfile"')"
  "EXECIO" numq "DISKW NAMES (FINIS"
  "FREE FILE(DOTXMI)"
  if (bitbuckt = "") then bitbuckt = "*"
  quiet = Outtrap("HLP.")
  "TRANSMIT Ken COPYLIST PROLOG EPILOG NOLOG",
    "NONOTIFY DATASET('"locfile"')",
    "MSGDATASET('"sys_sysuid".RECEIVE.MSG')",
    options,
    "OUTDSNAME('"rmtfile"')",
    "SYSOUT("bitbuckt")"
  did_it = rc
  "FREE FILE(NAMES)"
  "delete '"sys_sysuid".RECEIVE.MSG'"
  quiet = Outtrap("OFF")
  if (did_it >< 0) then,
    do
      say "Transmit rc("did_it")"
      XMIT2in = Queued()
      do ix = 1 to XMIT2in
        parse pull dline
        say dline
      end
      do ix = 1 to HLP.0
        say HLP.ix
      end
    end
  DELSTACK
  if (sys_sysenv >< "FORE") then,
    drc = 8
  return

where_am_i:
  hostfile = locfile
  if (left(locfile,1) >< "'") then,
    do
      locfile = zprefix"."locfile
      if rmtfile = "" then rmfile = zprefix".XMIT."locfile".XMI"
      if rmtfile = "." then rmfile = zprefix".XMIT."locfile".XMI"
    end
  else,
    do
      locfile = strip(locfile,"B","'")
      if rmtfile = "" then,
        do
          parse var locfile hlq "." restofdsn
          if (hlq = zprefix) then
            rmtfile = zprefix".XMIT."restofdsn".XMI"
          else rmtfile = zprefix".XMIT."locfile".XMI"
        end
    end
  rmtfile = strip(left(rmtfile,44))
  call get_file_attributes
  return

get_file_attributes:
  lrc=LISTDSI("'"locfile"' DIRECTORY")
  DSIRC=SYSREASON
  if (dsirc >< 0) then,
    do
      msg = msg "LISTDSI("dsirc")"
      prolog03 = locfile msg
      return
    end
  dirs = ""
  if (left(sysdsorg,2) = "PO") then,
    dirs = "DIR="SYSADIRBLK
  if (SYSADIRBLK = "NO_LIM") then dirs = "PDSTYPE=PDSE"
  rmt_space = SYSPRIMARY SYSSECONDS
  call build_msg
  return

who_am_i:
  prolog01 = ""
  prolog02 = ""
  prolog03 = ""
  prolog04 = ""
  prolog05 = ""
  prolog06 = ""
  prolog07 = ""
  prolog08 = ""
  prolog09 = ""
  epilog01 = ""
  epilog02 = ""
  epilog03 = ""
  epilog04 = ""
  epilog05 = ""
  epilog06 = ""
  epilog07 = ""
  epilog08 = ""
  epilog09 = "Localhost is:" mvs_sysname "running" mvs_opsys
  Parse SOURCE,
    source_host_env,
    source_call_type,
    source_uc_exec_name,
    source_hostdd,
    source_hostdsn,
    source_nf_exec_name,
    source_initial_cmd_env,
    source_asid_name,
    source_char8_user_token,
    source_hostother
  Address_Environment = Address()
  sys_sysuid = SYSVAR("SYSUID")
  sys_sysenv = SYSVAR("SYSENV")
  mvs_sysname = MVSVAR("SYSNAME")
  mvs_opsys = MVSVAR("SYSOPSYS")
  Address ISPEXEC "VGET (ZPREFIX)"
  old_trap = OutTrap("RACF.")
  mvs_sysname = MVSVAR("SYSNAME")
  sys_sysuid = SYSVAR("SYSUID")
  "listuser" sys_sysuid
  new_trap = OutTrap("OFF")
  sys_username = sys_sysuid"@"mvs_sysname
  if (racf.0 > 0) then,
    do ix = 1 to racf.0
      if (pos("NAME=",racf.ix) > 0) then,
        do
          parse var racf.ix . "NAME=" sys_username "OWNER=" .
          sys_username = strip(an(sys_username))
          leave
        end
      if (pos("NO-INSTALLATION-DATA",racf.ix) > 0) then,
        do
          leave
        end
      if (pos("INSTALLATION-DATA",racf.ix) > 0) then,
        do
          parse var racf.ix . "=" sys_username
          sys_username = strip(an(sys_username))
          leave
        end
    end
  epilog09 = "From" sys_username
  return

uc: Procedure
  parse upper arg string
  return string

lc: Procedure
  parse arg string
  string = translate(string,
    "abcdefghijklmnopqrstuvwxyz",
    "ABCDEFGHIJKLMNOPQRSTUVWXYZ")
  return string

an: Procedure
  parse arg string
  all_ebcdic = xrange(x2c("00"),x2c("FF"))
  alpha_numeric = ,
    copies(" ",x2d("6B")-x2d("00"))||,
    "," ||,
    copies(" ",x2d("C1")-x2d("6C"))||,
    "ABCDEFGHI" ||,
    copies(" ",x2d("D1")-x2d("CA"))||,
    "JKLMNOPQR" ||,
    copies(" ",x2d("E2")-x2d("DA"))||,
    "STUVWXYZ" ||,
    copies(" ",x2d("F0")-x2d("EA"))||,
    "0123456789" ||,
    copies(" ",x2d("0100")-x2d("FA"))
  string = translate(string,alpha_numeric,all_ebcdic)
  return string

alloc_plib:
  bulk_dd = "BULK"RIGHT("0000"RANDOM(99999),4)
  "ALLOC NEW DEL F("bulk_dd") DSO(PO) DIR(1) SP(3,3) TRACK",
         "REUSE RECFM(F B) BLKSIZE(0) LRECL(80) UNIT(SYSDA)"
  a = panel_def()
  Do Until substr(line,1,7)="/*PANEL"
    line = sourceline(a)
    a=a+1
  End
  panelname = uc_exec_name
  Address ispexec,
    "LMINIT DATAID(TMPPNL) ENQ(EXCLU) DDNAME("bulk_dd")"
  Address ispexec,
    "LMOPEN DATAID("tmppnl") OPTION(OUTPUT)"
  Do Until substr(line,1,4)=")END"
    line = sourceline(a)
    Address ispexec,
      "LMPUT DATAID(&TMPPNL) MODE(INVAR) DATALOC(LINE) DATALEN(80)"
    a=a+1
  End
  Address ispexec,
    "LMMADD DATAID(&TMPPNL) MEMBER("panelname")"
  Address ispexec,
    "LMFREE DATAID(&TMPPNL)"
  Address ispexec,
    "LIBDEF ISPPLIB LIBRARY ID("bulk_dd") STACK"
  return

free_plib:
  address ispexec "LIBDEF ISPPLIB"
  "FREE F("bulk_dd")"
  return

panel_def:
  return next_line()

next_line:
  return sigl+4

/*PANEL XMIT2
)ATTR DEFAULT(%+_)
       %   TYPE(TEXT) INTENS(HIGH)
       +   TYPE(TEXT) INTENS(LOW)
       _   TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(LEFT)
)BODY EXPAND(//)
%-/-/- TRANSMIT a data set -/-/-
Command ===>_ZCMD
+
+Host Data set:_locfile                                             +
+Prolog: Bit-bucket output class:_Z+
_prolog01                                                            +
_prolog02                                                            +
_prolog03                                                            +
_prolog04                                                            +
_prolog05                                                            +
_prolog06                                                            +
_prolog07                                                            +
_prolog08                                                            +
_prolog09                                                            +
+epilog:
_epilog01                                                            +
_epilog02                                                            +
_epilog03                                                            +
_epilog04                                                            +
_epilog05                                                            +
_epilog06                                                            +
_epilog07                                                            +
_epilog08                                                            +
_epilog09                                                            +
+
)INIT
  .ZVARS = 'BITBUCKT'
)END
*/

build_msg:
  queue ,
"                                                                      "
  queue ,
"     This message is intended to help someone who is viewing          "
  queue ,
"     an EBCDIC binary version and not sure how to process             "
  queue ,
"     the file. If you are viewing this on a PC, then you              "
  queue ,
"     will need to file transfer this file in a binary                 "
  queue ,
"     format to an "MVS" system with RECFM=FB, BLKSIZE=3120,           "
  queue ,
"     and LRECL=80. Then you can issue the TSO/E command:              "
  queue ,
"                                                                      "
  queue ,
"       RECEIVE INDATASET('your.mvs.dataset.name')                     "
  queue ,
"                                                                      "
  queue ,
"     You will get any messages inside this file and then              "
  queue ,
"     be prompted:                                                     "
  queue ,
"                                                                      "
  queue ,
"INMR906A Enter restore parameters or 'DELETE' or 'END' +              "
  queue ,
"                                                                      "
  queue ,
"     The '+' plus sign indicates there is more to the prompt. Enter   "
  queue ,
"     a question mark in response to each line and you will get the    "
  queue ,
"     next line. INMR908A will show file attributes for the file       "
  queue ,
"     that was processed by 'TRANSMIT'. Normally you can just press    "
  queue ,
"     the enter key and take all the defaults. You can always          "
  queue ,
"     rename the received file afterwards. If you want to save time    "
  queue ,
"     then respond 'DATASET('my.new.dataset.name'). And optionally,    "
  queue ,
"     VOLUME(volser) if non-SMS managed.                               "
  queue ,
"                                                                      "
  queue ,
" INMR906A Enter restore parameters or 'DELETE' or 'END' +             "
  queue ,
"?                                                                     "
  queue ,
" INMR908A The input file attributes are: DSORG=PARTITIONED, RECFM=FB, "
  queue ,
"BLKSIZE=32720, LRECL=80, File size=53K bytes +                        "
  queue ,
"?                                                                     "
  queue ,
" INMR909A You may enter DSNAME, SPACE, UNIT, VOL, OLD/NEW, or RESTORE/"
  queue ,
"COPY/DELETE/END                                                       "
  queue ,
"                                                                      "
  queue ,
"     This file was allocated with:                                    "
  queue "RECFM="SYSRECFM "BLKSIZE="SYSBLKSIZE,
        "LRECL="SYSLRECL
  queue "TRACKS" "PRIMARY="SYSPRIMARY,
    "SECONDARY="SYSSECONDS dirs
  queue " "
  numq = Queued()
  quiet = Outtrap("HLP.")
  "delete '"sys_sysuid".RECEIVE.MSG'"
  quiet = Outtrap("OFF")
  "ALLOC FILE(RMSG) SPACE(2 1) RECFM(F B)",
    "TRACKS",
    "BLKSIZE(0) LRECL(80) DSORG(PS) NEW CATALOG REUSE",
    "UNIT(SYSALLDA) DIR(0) DATASET('"sys_sysuid".RECEIVE.MSG')"
  "EXECIO" numq "DISKW RMSG (FINIS"
  "FREE FILE(RMSG)"
  return
./ ADD NAME=PDSLOAD  0666-07209-07209-1735-00001-00001-00000-DIR2UPDT
rexx_HEX2OBJ:  /* We still need rexx in comment if read from SYSPROC */         
/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>         
                                                                                
  Dataset:  KET2812.REXX(HEX2OBJ)                                               
  Author:   KTomiak                                                             
  Contact:  "Kenneth Tomiak"<cbt_ken@KTomiak.biz>                               
  Syntax:   HEX2OBJ (output_ddname)                                             
  Overview: Reconstructs a member that was saved in hexadecimal                 
            format.                                                             
                                                                                
=======================================================================         
                                                                                
 History of Modifications                                                       
 ------------------------                                                       
  When     Who      What you did                                                
  -------- -------- ---------------------------------------------------         
  20070528 KTOMIAK  Original code.                                              
                                                                                
=======================================================================         
                                                                                
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */         
                                                                                
  Parse Arg all_my_arguments                                                    
  Numeric Digits 12                                                             
                                                                                
rexx_Main_HEX2OBJ:                                                              
  return_code = rexx_Initialize()                                               
  If (return_code = 0) then,                                                    
    Do                                                                          
      return_code = rexx_Process()                                              
      return_code = rexx_Termination()                                          
    End                                                                         
  Return 0                                                                      
                                                                                
/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>         
=======================================================================         
 In this routine we open any files and initialize any                           
 constants we might need.                                                       
=======================================================================         
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */         
rexx_Initialize:                                                                
  PARSE VERSION,                                                                
    rexx_version,                                                               
    rexx_date                                                                   
  PARSE SOURCE,                                                                 
    source_host_env,                                                            
    source_call_type,                                                           
    source_uc_exec_name,                                                        
    source_hostdd,                                                              
    source_hostdsn,                                                             
    source_nf_exec_name,                                                        
    source_initial_cmd_env,                                                     
    source_asid_name,                                                           
    source_char8_user_token,                                                    
    source_hostother                                                            
  job_specs = rexx_jobspecs()                                                   
  sysvar_sysuid = SYSVAR("SYSUID")                                              
  sysvar_sysenv = SYSVAR("SYSENV")                                              
  say ""                                                                        
  say Copies("=",55)                                                            
  say left("=" job_specs,53) "="                                                
  say left("=" source_uc_exec_name,                                             
    "executing under" source_host_env,                                          
    "as a" source_call_type,53) "="                                             
  say left("=  on" date() "at" time()".",53) "="                                
  say Copies("=",55)                                                            
  say ""                                                                        
  return_code = 0                                                               
                                                                                
  If (source_host_env >< "TSO") Then,                                       
    Do                                                                          
      Say "Wrong host environment" source_host_env                              
      return_code = 16                                                          
    End                                                                         
                                                                                
  Parse var all_my_arguments dd_ot .                                            
  if (datatype(dd_ot) = "NUM") then,                                            
    do                                                                          
      say "Setting default output DDname."                                      
      dd_ot = "OBJOT"                                                           
    end                                                                         
  if (dd_ot = "") then,                                                         
    do                                                                          
      say "Setting default output DDname."                                      
      dd_ot = "OBJOT"                                                           
    end                                                                         
                                                                                
  text_out.0 = 0                                                                
                                                                                
  text_in.0 = 0                                                                 
  call add_rexx_code                                                            
  say "Read" text_in.0 "records."                                               
                                                                                
  Return return_code                                                            
                                                                                
/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>         
=======================================================================         
 In this routine we do our processing.                                          
=======================================================================         
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */         
rexx_Process:                                                                   
  if (text_in.0 = 0) then,                                                      
    do                                                                          
      say source_uc_exec_name "is missing the data."                            
      return_code = 4                                                           
      return 4                                                                  
    end                                                                         
  do text_ix = 1 to text_in.0 by 2                                              
    line_1 = ""                                                                 
    text_1 = text_in.text_ix                                                    
    next_ix = text_ix + 1                                                       
    text_2 = text_in.next_ix                                                    
    do char_ix = 1 to length(text_1)                                            
      char_1 = substr(text_1,char_ix,1)                                         
      char_2 = substr(text_2,char_ix,1)                                         
      line_1 = line_1""char_1""char_2                                           
    end                                                                         
    text_out.0 = out_text(x2c(line_1))                                          
  end                                                                           
  Return return_code                                                            
                                                                                
/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>         
=======================================================================         
 In this routine we close files and finish up.                                  
=======================================================================         
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */         
rexx_Termination:                                                               
  "EXECIO * DISKW" dd_ot "(FINIS STEM TEXT_OUT.)"                               
  write_rc = RC                                                                 
  if (write_rc >< 0) then,                                                      
    Do                                                                          
      say "Encountered problems writing //DD:"dd_ot"."                          
      say "RC("write_rc") >< 0"                                                 
      return_code = write_rc                                                    
    end                                                                         
  say "Wrote" text_out.0 "records."                                             
  Return return_code                                                            
                                                                                
/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>         
=======================================================================     
 Place any of your subroutines and procedures below this.                       
=======================================================================         
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */         
rexx_jobspecs:                                                                  
  /*---------------------------------------------------------------*/           
  /* ADDRESSABILITY TO CVT FROM PSA                                */           
  /*---------------------------------------------------------------*/           
  PTR2PSA = 0                                                                   
  CVTPTR = STORAGE(D2X(PTR2PSA + 16),4)                                         
  /*---------------------------------------------------------------*/           
  /* ADDRESSABILITY TO SMCA, THEN GET SMF SYSTEM ID                */           
  /*---------------------------------------------------------------*/           
  CVTSMCA = STORAGE(D2X(C2D(CVTPTR)+197),3)                                     
  SMFID = STORAGE(D2X(C2D(CVTSMCA)+16),4)                                       
  /*---------------------------------------------------------------*/           
  /* GET JOBNAME, STEP, AND PROCEDURE                              */           
  /*---------------------------------------------------------------*/           
  PSATOLD  = STORAGE(21C,4)                    /* POINTER TO TCB   */           
  PTRTIOT  = STORAGE(D2X(C2D(PSATOLD)+12),4)   /* POINTER TO TIOT  */           
  JOBNAME  = STORAGE(D2X(C2D(PTRTIOT)),8)                                       
  STEPNAME = STORAGE(D2X(C2D(PTRTIOT)+8),8)                                     
  PROCNAME = STORAGE(D2X(C2D(PTRTIOT)+16),8)                                    
  Tcbjscbb = Storage(D2x(C2d(Psatold)+181),3)              /* jscb */           
  jscbssib = STORAGE(D2X(C2D(tcbjscbb)+316),4)      /* Ptr to SSIB */           
  ssibjbid = STORAGE(D2X(C2D(jscbssib)+12),8)    /* job identifier */           
  Return JOBNAME SSIBJBID STEPNAME PROCNAME                                     
                                                                                
/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>         
=======================================================================         
 Adds text to a stem variable                                                   
=======================================================================         
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */         
in_text:                                                                        
  parse arg text_line                                                           
  text_next = text_in.0 + 1                                                     
  text_in.text_next = text_line                                                 
  return text_next                                                              
                                                                                
/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>         
=======================================================================         
 Adds text to a stem variable                                                   
=======================================================================         
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */         
out_text:                                                                       
  parse arg text_line                                                           
  text_next = text_out.0 + 1                                                    
  text_out.text_next = text_line                                                
  return text_next                                                              
                                                                                
/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>         
=======================================================================         
 Adds the rexx code to convert the member back.                                 
=======================================================================         
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */         
add_rexx_code:                                                                  
  sigl_record = sigl + 25                                                       
  rexx_code = "YES"                                                             
  process_data = "NO"                                                           
  DO WHILE rexx_code = "YES"                                                    
    SIGL_RECORD=SIGL_RECORD+1                                                   
    MY_DATA=SOURCELINE(SIGL_RECORD)                                             
    IF (MY_DATA="ENDDATA*/") THEN,                                              
      DO                                                                        
        rexx_code="NO"                                                          
        LEAVE                                                                   
      END                                                                       
    IF (MY_DATA="/*BEGINDATA") THEN,                                            
      DO                                                                        
        PROCESS_DATA="YES"                                                      
        ITERATE                                                             
      END                                                                       
    IF (PROCESS_DATA="YES") THEN,                                               
      DO                                                                        
        text_in.0 = in_text(my_data)                                            
      END                                                                       
  END                                                                           
  return                                                                        
                                                                                
/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>         
=======================================================================         
__DATA__                                                                        
=======================================================================         
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */         
/*BEGINDATA                                                                     
0CEC444444014400DCEDDCC40000001A4444444444444444444444444444444444444444DCEDDCCF
25240000000000017423614000000090000000000000000000000000000000000000000074236141
0EEE4000440344004FF51DCEDDCC4FFFFFFFF44CDE4DDCCD4DEE744F7C6E66C44EDEDC6CDCEDDCCF
2373000000080001700417423614020070529001580395330643A001A6B50E60D39453B574236142
0EEE400344034400EECDC544F7E66E44EDEDC54400059ED01A4F0F4BA01250A541A6005FDCEDDCCF
237300080008000173554D002A50E50D39453D0010580C0C8F10FF1F01818000500CAA8074236143
0EEE400744034400A51E150E5D1051D01DF2DCBFF1DCBFF1DCBA94DC94D6D0D7B2D0D6BADCEDDCCF
23730000000800010081F5E4000400088180442280472281492C204B203A27482021082E74236144
0EEE400A44034400512040101048AE411040BB44A1D010BF47AF92D6411040BB48AE9610DCEDDCCF
23730008000800018000800020701210029020701E520023700060391003B02070125B0074236145
0EEE400E4403440047AA411040BB48AED010BF47A194D6411040BB48AE961047AA411040DCEDDCCF
237300000008000170181001B0227012520026701E60391003B02070125B0070181001B074236146
0EEE400144034400BB48AE40BB44AAD010BB47A8411040BB4FD74ED8951048A61F4BA5D0DCEDDCCF
23730018000800012270129020701851002470141002B026104810405D0070149E701C2074236147
0EEE400544034400F0104FF0411040A44FAE411040BB48AE961047AA411040BB48AA40BBDCEDDCCF
2373001000080001000010011001601070121001B02270125B0070181001B0227018902874236148
0EEE40084403440047AAD010BB47AA951047AAD0D6104FAE41AD0280DCEDDCC4ECDD4CCCDCEDDCCF
2373001800080001701855002A70185D0870182108067012501A0A00742361406933012574236149
0EEE400C44034400DC464CDECDCC4DCDCDCECD000202410600D5D6B7D5DCBDD5D2B343D6DCEDDCCF
237300100008000154000955139407191453590000A31004AD2F0C402F0C40271C50100C74236140
0EEE400F4403440044DC45D292D648A0D042B2982041AB512041101148A7901047A79010DCEDDCCF
2373001800080001100C101C1039702E2708281000702E8004100021702C5000702C170174236141
0EEE40034403440047A7921044AB901248A4D04212931044AB901248A6D03212941044ABDCEDDCCF
2373002000080001702C5801702E5002702A2708025001702E500A702027080A5801702E74236142
0EEE400644034400901448ABD052144FAB0041AB0380DCEDDCC464CDECDCC4CCDCDC4DECDCEDDCCF
23730028000800015002702E270802702E70502C0700742361400095513940445145065574236143
0EEE400A44014400DDCCC4DCDCDCECD4CCDDDCC000244444444444444444444444444444DCEDDCCF
23730020000B00019994507191453590975695400000000000000000000000000000000074236144
0EEE400B440344000246D59860119F1090104E0053004E0001913341A04F014FB6D013BCDCEDDCCF
2373002C00080001A3100020008640006F00310001002100A31000703210007006510E2074236145
0EEE400F4403440007D013159E120F98D6119F104E0054004E0001914341AB4F01D042B3DCEDDCCF
23730024000800017E210E024F047E6038864000310001002100A310007030100057082074236146
0EEE40024403440047B6D042B20041A60280DCEDDCC4ECDD4DCEDE4ECEC4CCDCDC7EEECDDCEDDCCF
2373003C0008000170062708287050380800742361406933095398069380445145E2829574236147
0EEE4006440344000002024FA09C120190DB94120190DB9812D013BC47A9D013159E120FDCEDDCCF
23730034000800010000A3703210047E241510047E20156004510E20703C210E024F047E74236148
0EEE400944034400D015BC07D015139E120F94D69C4241A8D8D6D6D4D6B2D0BC4542A911DCEDDCCF
2373003C000800015102207E21020E4F047E6038100470FA243B3A253C4751220270F68674236149
0EEE400D440344009F1090104E0055004E0001915341A34F014FB69C1244A148A0D01515DCEDDCCF
237300340008000140006F00310001002100A3100070401000700610047044704E71020274236140
0EEE4000440344000FD01242D015BC47A2D0154598120190DB0F92D69C5241A8945248A5DCEDDCCF
2373004C000800017E200404510220704421020210047E24177E6038100470FA1004704C74236141
0EEE400444034400984248A5D8D6D6D4D6B94FA9400040538000800050D841A70051D851DCEDDCCF
23730044000800011004704C243B3A2D3C3B70F61007A00E8003900400145044AA00180074236142
0EEE400744034400D9D010101040DB50D9415351D941108100810051DAD010101040DB50DCEDDCCF
2373004C000800011073000081A0160014A00E0018100780039003001073000081A0160074236143
0EEE400B44034400DA415351DA41DBD110B851D941DDD110B851DAD8D6D6D0D8B21151D5DCEDDCCF
237300440008000114A00E0018101C230058001C1010230058001C243B3A274020B1000874236144
0EEE400E4403440051D54EAA111FBF130E51DB400050D550D5D8D6D61F4FDBD0BAF047AFDCEDDCCF
2373004C00080001000C50F284FFF7015F00101001A0040004243B3A81A014512E00705C74236145
0EEE40024403440094DFD4DFDF4E041148A413B31043BC1342A41E4EAA4FDF430446D4D2DCEDDCCF
237300540008000120102E111010079F705AF3F300B0249E705A8340581010100710307774236146
0EEE4005440344006060114000D0606043AA48AC1E1E131F43AB48AB1E1E98605F604E60DCEDDCCF
2373005C000800010000B11004770000405E705A81BFBE814054705A81BF60060000000474236147
0EEE4009440344001348AC46601F40A64FACD0DFF0D0F0B9D0F0B94E3098605F604E6046DCEDDCCF
2373005400080001BE705A1008816056705A201000D0005CD0006C1001600600000004107423
0EEE400C44034400D4986048AF51604F6040001F42AF8F004FAE4FAF4FA44FAF94D848A6DCEDDCCF
2373005C00080001301006705C80008004100390705C90027F5C705C7076705C5040706074236149
0EEE400044034400410051D551D598D648AF41455EDB90DB48A2B1E041DB41BB4DA54EDBDCEDDCCF
23730064000800011001A008000810397044800280105015706CF300B01490227068A01474236140
0EEE400344034400D0E0D647A5D0E0BA410051D551D54EA84FAF90D641AF90D6D8D6D6D1DCEDDCCF
2373006C00080001510008706821002E1001A00C000C50607044143870446438243B3A2774236141
0EEE400744034400D6B34EAA4FAF5ED896D95EDB415590DB48AAB1E044AAB1E010171742DCEDDCCF
23730064000800013C2850F27044001C89108010800250177064D3007064F30087A1987074236142
0EEE400A44034400AF57D94F4590DB48AFBFE090DB47AD4EDB4FDB4FAF17476017B1704EDCEDDCCF
2373006C000800016E0014800250157062F30050177066A014B0147062B6000080E300A074236143
0EEE400E44034400BB4FBB40BB41BBBFD6005ED80F90D648A151DA5E101FBFE30E119210DCEDDCCF
237300640008000126B026A026B026F83AEE801C7E18387076801C8008BFF7055F89200574236144
0EEE400144034400550056001FBF530ED0D9DA96DA46DB56DA90D64FA84EAFD0D8B29FD6DCEDDCCF
2373007C000800010108010CBFF7015F2F10100910A01600146838706450CC2740204B3874236145
0EEE4005440344009FD69FD61151D551D597D6D8D6D6D4D6DF4EAAD010B648AA46D49860DCEDDCCF
23730074000800014D384E38B10008000C4F39243B3A273C1050F25B002070781038100674236146
0EEE40084403440048AFD060BB47A35160D010BF47AFD0D8B246D5986048AF4F604FBC4DDCEDDCCF
2373007C00080001705C51042070CE8000520029705C27402010301006705C8004B0247074236147
0EEE400C44034400A25160D010BF47A2411040001F42AFD0D8B20F4FAFD0D8104FAED0D8DCEDDCCF
23730074000800018A800054002C708A1005100890705C274020607074204000407ED74074236148
0EEE400F44034400BA47A99FD84BA996D848A994D748A24EAF47A298D64FAC46D5986048DCEDDCCF
2373007C000800017070BC504070BC504070BC5048708250BA708660397084103810067074236149
0EEE400344034400AF4F604FBC4DAF5160D010BF47AF411040001F42AFD0D8B20F4FA7D0DCEDDCCF
23730084000800015C8004B024705C800054002C705C1005100890705C2740206070802074236140
0EEE400644034400D8104FA6D0D8BA47A99FD84BA996D848A994D748A94EAF47AA98D646DCEDDCCF
2373008C000800014000408AD7407070BC504070BC504070BC5048708E50BA708260391074236141
0EEE400A44034400D54F6056604FBC47A9D060B648AE4FA946D5986048A94F6056604FBCDCEDDCCF
23730084000800013080048000902670B853002C708A70B81038100670B880048000902674236142
0EEE400D4403440047A0D060B647A0D0D86041D840004EAA90D64FAF90DB966047A190DBDCEDDCCF
2373008C00080001709453002C7094274C04104C100450B6613870442018500C7098211874236143
0EEE4001440344004FA64FBC44A94FBB42A9966047A9966047A9966147A9966147A99661DCEDDCCF
23730094000800017094B02870B8902870B8500470B8500A70B8500070B8500570B8500B74236144
0EEE40044403440047A9966247A9966247A94FAB4FBC44A94FBB42A9966047A9966047A9DCEDDCCF
2373009C0008000170B8500170B8500770B87090B02A70B8902870B8500470B8500C70B874236145
0EEE400844034400966147A9966147A9966147A9966247A9966247A94FAAD060BA47A9D0DCEDDCCF
2373009400080001500470B8500970B8500F70B8500570B8500B70B870A6D3008070B8D474236146
0EEE400B4403440060BA47A9D060BA47A9D061BA47A9D061BA47A9D061BA47A9D062BA47DCEDDCCF
2373009C00080001058070B8D40B8070B8D3018070B8D4068070B8D40C8070B8D402807074236147
0EEE400F44034400A9F7D46040D440D8F7D46040D440D8F7D46090D4D060BC4BA290D4D0DCEDDCCF
2373009400080001B8210800F008204C210802F008204D2408056F0F51052C70AA610C2374236148
0EEE400244034400D9D4F7D46090D4D060BC4BA490D4D0D9D4F7D46150D4800040D9F7D4DCEDDCCF
237300AC00080001400C24080B6F0F510B2C70A8610C23440C230801800C80040048240874236149
0EEE4006440344006140D440D9F7D46140D440D9F7D46240D440D9D0DABC4FA9D0DA624FDCEDDCCF
237300A40008000106F008004A24080CF008004C240802F008004E29402E70AA2040084074236140
0EEE400944034400A990D64FA9D060BA47A9D060BA47A9D060BA47A9D061BA47A9D061BADCEDDCCF
237300AC00080001A4623870B8D3008070B8D4078070B8D40F8070B8D3058070B8D40A8074236141
0EEE400D4403440047A9D062BA47A9D062BA47A9F7D46040D440D8F7D46040D440D8F7D4DCEDDCCF
237300A40008000170B8D4008070B8D4068070B8210800F008204C210802F008204D240874236142
0EEE4000440344006090D4D060BC4BA290D4D0D9D4F7D46090D4D060BC4BA390D4D0D9D4DCEDDCCF
237300BC00080001076F0F51072C70B0610C23400C24080F6F0F510F2C70BE610C23440C74236143
0EEE400444034400F7D46150D4800040D9F7D46140D440D9F7D46240D440D9F7D46240D4DCEDDCCF
237300B400080001230805800C8004004824080AF008004A240800F008004C240806F00874236144
0EEE40074403440040D9D0DABC4FA9D0DA624FA890D64FAFD0D8B24FAF5EDE1F1E4E109FDCEDDCCF
237300BC00080001004E29402E70B020400C40BA62387044274020705C001881BE30005074236145
0EEE400B44034400104BAB4EE38E004EF04E109F104BAD4EE38E018E014EF0D0F0F04110DCEDDCCF
237300B4000800010070BE1009900420003001500170B61009900C800C2001600001100274236146
0EEE400E440344004FF040AA5EDE0F9ED043D844D74000954048A2964048A2964048A2D0DCEDDCCF
237300BC00080001100160BC80187E0C0C1040104810085C0070CC5F0070CC5C0070CC5074236147
0EEE400244034400403047A34330444040A09ED00FD060BC47AF5160D010B048B5D010B0DCEDDCCF
237300C400080001000070C81001100160CA8C0C7E510424705C8000540031700E54003674236148
0EEE40054403440047AF46D5986048AF4F604FBC4DAF5160D010BF47AF411040001F42AFDCEDDCCF
237300CC00080001705C10301006705C8004B024705C800054002C705C1005100890705C74236149
0EEE400944034400D0D8B20F4FAAD0D8104FAAD0D8BA47A99FD84BA996D848A9D8D6D6D0DCEDDCCF
237300C4000800012740206070C620400040C0D7407070BC504070BC504070BC243B3A2474236140
0EEE400C44034400D8B0D0D9D846D89860111011014EAF5EDE4FA3D0D8B24FAF5EDE90D6DCEDDCCF
237300CC000800013B362732401040600B858631A510C200147FE627402070440014183874236141
0EEE40004403440048A151DA5E101FBFE30E9FD696D91747DB4DA6485390DB48A3475311DCEDDCCF
237300D40008000170DC801C8008BFF7055F47388910B6B01670D2800E541770DA000E8974236142
0EEE4003440344009210550056001FBF530E115E101FBFE30E485351D941DB51D951DA41DCEDDCCF
237300DC0008000120050108010CBFF7015F898008BFF7055F000E8010A01600148010A07423
0EEE400744034400DB51DAD8D6D694D848A898D648A890D890D648AB90D8D0D9D548A0D0DCEDDCCF
237300D400080001160014243B3A504070F4103970F4204B123870D82F4B514A0A70EC2174236144
0EEE400A44034400D9D591D64FA094D648A090D8D1D8D890D8D0D8D841000051D951D980DCEDDCCF
237300DC000800014A0A603970EC103970E02F4B7D4C4C214C714E4E1002AB004000448074236145
0EEE400E440344000140D951D541D941D9D0DABD4FA090D648A090D8D0D8BED0D9D846D8DCEDDCCF
237300D4000800010000488008004C004A29402870EC113870EC224B253B22273240104074236146
0EEE400144034400D0606011101101BFBE42AA4FA34FA54FA64FA74FA84FA84FA94FAAD0DCEDDCCF
237300EC00080001720808858631A5D22870EC7FE670E270E670E070E470EE70E870E2D874236147
0EEE400544034400D9B9D010B541104FABD1D9BE4FABD0D9B9D010B041104FABD2D9B14FDCEDDCCF
237300E400080001326C270120100970EE263B1070E2D8326C24013B100670EE203B307074236148
0EEE400844034400ABD1D9B74FABD1D9B84FABD1D9B04FABD1D9B390D64EAA4FA898D841DCEDDCCF
237300EC00080001E22B3B2070E22B3B2C70E22F3B2070E22C3B31240750F270F4104B7074236149
0EEE400C44034400A851D65FD54FD4D010B4D010D494104110941047AFD010104FAE4110DCEDDCCF
237300E400080001F000008008E00826013EE6010D2D011002500070E826000170E6100174236140
0EEE400F44034400941047AFD010B54FBB47A1D010100191D648A29ED6D010B54EAA5FD5DCEDDCCF
237300EC00080001500070E8270128902270FA21070860103970FC4F392E083550F2800C74236141
0EEE4003440344001F48A8D8D6D651D64FD4D010B4D010D494104110941047A6D010104FDCEDDCCF
237300F4000800012F70F4243B3A8000E00826013EE6010D2D011002500070FE2600017074236142
0EEE400644034400A54110941047A6D010B64EAA5EDE0FD8D6D6D3D6BE4EAA4F014FB641DCEDDCCF
237300FC00080001FC1001500070FE28013450F280147E243B3A2D3C3950F2100070061074236143
0EEE400A44034400D640079EDA43D6F1DCDC4DACF1DCBFF1DCBF48B040BE4BAED8DCDC0EDCEDDCCF
237300F4000800013B1009024C100C91474970F28047229047227008902A70FE244C4B6074236144
0EEE400D440344004FAED0DC104EAE41DC1211101FBF130EF1DCB69EDA0FF2DCB6D8DCDCDCEDDCCF
237300FC0008000170F6204C0040F0104C818382FFF7015FA0473D824C7EA0443D244C4B74236145
0EEE4011440344009FDCD2DCB641D0D010BED010DCD010BA1140DC1FBF130ED8DCDC1140DCEDDCCF
2373000400080001214C2C4D3E105E25032CE5034423002883104CFFF7015F244C4B831074236146
0EEE401444034400DC1FBF130E90DB4FAC4EAF4FD61246D5986092D648BE114E0055004EDCEDDCCF
2373000C000800014CFFF7015F814470FC50CC80068F100020001038700686310001002174236147
0EEE401844034400000111901141BD1FBF115EF01E47BA93F047BD90111E11B1F04EF010DCEDDCCF
237300040008000100A48511077004FFF70580002E700A100470046107BEB1F3063005CE74236148
0EEE401B44034400411094F04EBC41101041F00091D648BE90D841100094D648B4114E00DCEDDCCF
2373000C0008000110081004700C1008811000AA1038700681141000AA1038701A86310074236149
0EEE401F4403440054004E000111901141B41FBF115EF01E47B293F047B490111E11B1F0DCEDDCCF
237300040008000101002100A4841107701AFFF70580002E70101004701A6107BEB1F30674236140
0EEE4012440344004EF010411094F04EB441101041F00098D648BB43D6114E0053004E00DCEDDCCF
2373001C000800013005CE1008100470121008811000AA10387012100C8631000100210074236141
0EEE4016440344000111901141BB1FBF115EF01E47B893F047BB90111E11B1F04EF01041DCEDDCCF
2373001400080001A48311077012FFF70580002E7018100470126107BEB1F3063005CE1074236142
0EEE4019440344001094F04EBA41101041F0001150A55DD04110001F90D15ED00F444444DCEDDCCF
2373001C00020001081004701A1008811000AA8D800080041000AA828C04800C7E00000074236143
0EEE401D440044008006800F800E44444444444444444444444444444444444444444444DCEDDCCF
23730010000C0001503E503A502E0000000000000000000000000000000000000000000074236144
0EEE401E44034400DDE4CCCCC45554CDDCCCE4CECEEE4555DDE4EEDECC45554EEDDCCC4CDCEDDCCF
23730010000800015630144540CCC0139514805792320CCC56302366540CCC023691750574236145
0EEE401144034400DDDD455544444444EEECD444EEEEEF44EDCDDCDC4CDD4464CCC4CCDCDCEDDCCF
237300280008000199690CCC0000000028295000282431002297795706690B101440319474236146
0EEE401544034400DCDDCCCCDCCDDCE5464CCC4DCDC7EEC7DDE4EEDECC45554C6D4CDDDDDCEDDCCF
2373002000080001957313549536942DB1014405145E229E56302366540CCC091605996974236147
0EEE4018440344004555DDE4EEDECC45554CCC4CDDDD4555DCCC00460000E40000EDCEC4DCEDDCCF
23730028000800010CCC56302366540CCC04320599690CCC71755CB103012D020947435D74236148
0EEE401C44034400000500000202FF4444444444DCEDDCC444DCDCCD01074222220DCEEDDCEDDCCF
23730020000800010000050C090D66000000000074236140004542590809000000C5562774236149
0EEE401F44034400CCCCDCDC7CDCEDCDCCECCCCCDDE4EEDECC45554CCDCCEDDE4CEDD455DCEDDCCF
237300280008000161445145E55447139121445456302366540CCC0499533698064330CC74236140
0EEE4013440344005DDE4EEDECC45554DCEC4CDDDD45554226222464EECEE4CCECC5DDCCDCEDDCCF
2373003000080001C56302366540CCC074250599690CCC000B01000023132069754D464974236141
0EEE401644034400CCCC516664DCEDDCC46664DCE4DCDCCD4DCDDCC4EECDCEE46664444DDCEDDCCF
23730038000800016954DC0000742361400000742045425909536140439393800000000774236142
0EEE401A44034400CEDDCC4ECDDCDCECC464ECDCCCDC6DCDCEC4DEEDEE4DCDECDCE4ECDCDCEDDCCF
23730030000800014236140359495135400051991235035573806437430958499520519974236143
0EEE401D44034400CCDC6DCDCEC4CDDEE4444DCEDDCC4ECDDCDCECC464EDCCCCDCC4DCCDDCEDDCCF
23730038000800011235035573809574300007423614035949513540004545695540953674236144
0EEE401144034400DC4CDDDCE4DDE4EEDDDDECC4444DCEDDCC4ECDDCDCECC464CDDEE4CCDCEDDCCF
23730040000800019406694130563024776935400007423614035949513540009574306974236145
0EEE401444034400DC4DDCCCCD4DCCDDC4DCDCEC4DCEE4ECCD4FF0000000000000000000DCEDDCCF
23730048000800013503679313095369403557380352203815080000000000000000000074236146
0EEE40184403440000000000004000000000901DEEEDDCDE000500000000000000000000DCEDDCCF
23730040000800010000000100000001000140182827995320000001000100000000000174236147
0EEE401B4403440000000000000700000000000000000000000000000000000000400000DCEDDCCF
2373004800080001000100010009000100000001000000000000000000000001000000017423
0EEE401F440344000015001DEEEEEF440040000000000000000000000000000000000000DCEDDCCF
2373004000080001000E001028243100208000010001000000000001000100010000000174236149
0EEE40124403440000000000000000000000000000000000000000000000001DEEEEEF44DCEDDCCF
23730058000800010000000100000000000000000000200100200001000100142824320074236140
0EEE40164403440000020000000000000000000000000000000000000000020000000000DCEDDCCF
23730050000800012004000100010000000000010001000100000001000000000000000074236141
0EEE4019440344000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDCEDDCCF
23730058000800010000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF74236142
0EEE401D44034400FFFFFFFFFFFF0FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0DCEDDCCF
2373005000080001FFFFFFFFFFFF0FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF074236143
0EEE401044034400FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDCEDDCCF
2373006800080001FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF74236144
0EEE401444034400FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDCEDDCCF
2373006000080001FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF74236145
0EEE401744034400FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000000000000000DCEDDCCF
2373006800080001FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000000000000000000074236146
0EEE401B4403440000000000000000000000000000000000000000000000400000000000DCEDDCCF
23730060000800010000000000000000000000000000000000000000000000000000000074236147
0EEE401E4403440000000000000000000000000000000006000000000000000000000000DCEDDCCF
23730068000800010000000000000000000000000000000B00000000000000000000000074236148
0EEE40124403440000000000000000000000000000000000000000000000000000000000DCEDDCCF
23730070000800010000000000000000000000000000000000000000000000000000000074236149
0EEE40154403440000000000000000000000000000000000000000000000000000000000DCEDDCCF
23730078000800010000000000000000000000000000000000000000000000000000000074236140
0EEE4019440344000000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDCEDDCCF
23730070000800010000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF74236141
0EEE401C44034400FFFFFFFFFFFFFFFFFFFFFFFF0FFFFFFFFFFFFFFFFFFFFFFFFFF0FFFFDCEDDCCF
2373007800080001FFFFFFFFFFFFFFFFFFFFFFFF0FFFFFFFFFFFFFFFFFFFFFFFFFF0FFFF74236142
0EEE4010440344000FFFFFFFFFFFFFFFFFFFFFFFFFF00FFFFFFFFFFFFFFFFFFFFFFFFFFFDCEDDCCF
23730080000800010FFFFFFFFFFFFFFFFFFFFFFFFFF00FFFFFFFFFFFFFFFFFFFFFFFFFFF74236143
0EEE401344034400FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000FFFFFFDCEDDCCF
2373008800080001FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000FFFFFF74236144
0EEE401744034400F000000000FFFFFFFF00000000FFFFFF0000000000FFFFFFFFFFFFFFDCEDDCCF
2373008000080001F000000000FFFFFFFF00000000FFFFFF0000000000FFFFFFFFFFFFFF74236145
0EEE401A44034400FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDCEDDCCF
2373008800080001FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF74236146
0EEE401E44034400FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDCEDDCCF
2373008000080001FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF74236147
0EEE401144034400FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDCEDDCCF
2373009800080001FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF74236148
0EEE401544034400FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDCEDDCCF
2373009000080001FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF74236149
0EEE401844014400FFFFFFFF0000000000FFFFFF44444444444444444444444444444444DCEDDCCF
2373009800080001FFFFFFFF0000000000FFFFFF0000000000000000000000000000000074236140
0DDC4444440244440000001D001D001D0019001F001F0015444444444444444444444444DCEDDCCF
29340000000000000101901190159019904590419045805500000000000000000000000074236141
0CDC4444444444444444444444444444FFFFFFFFFF4FFFFFFFFF44444444444444444444DCEDDCCF
25540000000000000000000000000000156962340000105071490000000000000000000074236142
ENDDATA*/                                                                       
                                                                            
./ ADD NAME=RACFINFO 0666-07194-07194-2148-00001-00001-00000-DIR2UPDT
rexx_racfinfo:    /* rexx */
/****************************REXX***********************************/
/* Source: http://www.xephon.com/arcinframe.php//f002a04           */
/* Modified: Kenneth E Tomiak - use setr list to get active        */
/*           classes to be used instead of GRINDD.                 */
/* DOC: To execute this exec, enter the command followed by two    */
/*      parms (USER INFOALL). The USER should be the RACF userid   */
/*      of whom information is requested. INFOALL MUST BE EQUAL    */
/*      to ALL to generate full security information. Otherwise,   */
/*      set INFOALL to NOT or blank.                               */
/*    *** YOU MUST BE AUTHORIZED TO ISSUE THE SEARCH COMMAND ***   */
/*    *** YOU MUST BE AUTHORIZED TO ISSUE THE SETR LIST COMMAND    */
/****************************REXX***********************************/
  arg USER INFOALL
  if sysvar(syspref) = "" then
    do
      address tso "profile prefix("sysvar(sysuid)")"
      prfxon = on
    end
/******************* RACF User   ***********************************/
  title1 = " " || USER || " INFORMATION "
  say center(title1,75,"*")
  say ""
  address tso "LISTUSER " USER,
    "CICS DCE DFP EIM KERB LANGUAGE LNOTES NDS",
    "NETVIEW OMVS OPERPARM OVM PROXY TSO WORKATTR"
  say ""
/******************* RACF GROUPS ***********************************/
  title1 = " GROUPS " || USER || " ADMINISTERS "
  say center(title1,75,"*")
  say ""
  if INFOALL = "ALL" then
    do
      address tso "SEARCH USER(" USER ") CLASS(GROUP) CLIST('LG ')"
      "ALLOC FILE(RACFEXEC)",
        "DATASET('"sysvar(SYSPREF)".EXEC.RACF.CLIST') SHR REUSE"
      "EXECIO * DISKR RACFEXEC (FINIS STEM RACFCMD."
      "FREE FILE(RACFEXEC)"
      if (RACFCMD.0 > 1) then,
        do
          say ""
          title1 = " GROUP DETAIL INFORMATION "
          say center(title1,75,"*")
          say ""
          address tso "EXEC '"sysvar(SYSPREF)".EXEC.RACF.CLIST'"
          say ""
        end
    end
  else
    do
      address tso "SEARCH USER(" USER ") CLASS(GROUP)"
    end
/******************* RACF DATASETS *********************************/
  title1 = " DATASETS ACCESSIBLE BY " || USER || " "
  say center(title1,75,"*")
  say ""
  if INFOALL = "ALL" then
    do
      address tso "SR USER("USER") LIST NOMASK CLIST('LD DA(' ') AUTH')"
      "ALLOC FILE(RACFEXEC)",
        "DATASET('"sysvar(SYSPREF)".EXEC.RACF.CLIST') SHR REUSE"
      "EXECIO * DISKR RACFEXEC (FINIS STEM RACFCMD."
      "FREE FILE(RACFEXEC)"
      if (RACFCMD.0 > 1) then,
        do
          say ""
          title1 = " DATASET ACCESS DETAIL INFORMATION "
          say center(title1,75,"*")
          say ""
          address tso "EXEC '"sysvar(SYSPREF)".EXEC.RACF.CLIST'"
          say ""
        end
    end
  else
    do
      address tso "SR USER("USER") LIST NOMASK"
    end
/******************* RACF GENERAL RESOURCES ************************/
  call get_active_classes
  do gr_x = 1 to grindd.0
    record = grindd.gr_x
    record = substr(record,1,8)
    title1 = " GENERAL RESOURCE "||record||,
      " ACCESSIBLE BY "||USER||" "
    say center(title1,75,"*")
    if INFOALL = "ALL" then
      do
        say ""
        address tso "SR USER("USER") CLASS("record") CLIST('RL ",
          record" ' ' AUTH')"
        "ALLOC FILE(RACFEXEC)",
          "DATASET('"sysvar(SYSPREF)".EXEC.RACF.CLIST') SHR REUSE"
        "EXECIO * DISKR RACFEXEC (FINIS STEM RACFCMD."
        "FREE FILE(RACFEXEC)"
        if (RACFCMD.0 > 1) then,
          do
            say ""
            title1 = " GENERAL RESOURCE "||,
              record||" DETAIL INFORMATION "
            say center(title1,75,"*")
            say ""
            address tso "EXEC '"sysvar(SYSPREF)".EXEC.RACF.CLIST'"
            say ""
          end
      end
    else
      do
        address tso "SR USER("USER") CLASS("record")"
      end
  end
/******************* END OF EXEC ***********************************/
  if prfxon = on then
    address tso "PROFILE NOPREFIX"
  exit
/******************* issue setr list to get active classes *********/
get_active_classes:
  quiet = OutTrap("RACF.")
  "SETROPTS LIST"
  quiet = OutTrap("OFF")
  process = "Off"
  r_x = 0

  do racf_x = 1 to racf.0
    setr = racf.racf_x
    if (pos("ACTIVE CLASSES =",setr) > 0) then,
      do
        process = "ON"
        parse var setr junk "=" setr
      end
    if ((process = "ON") & (left(setr,1)  >< "")) then,
      do
        Leave
      end
    if (process = "Off") then iterate
    do while setr >< ""
      parse var setr res " " setr
      if ((res = "DATASET") | (res = " ") | (res = "")) then,
        iterate
      if ((res = "USER") | (res = "GROUP")) then,
        iterate
      r_x = r_x + 1
      grindd.r_x = res
    end
  end
  grindd.0 = r_x
  return

./ ADD NAME=REXBRWSR 0666-07213-07213-1944-00001-00001-00000-DIR2UPDT
rexx_REXBRWSR: /* We still need rexx in comment if read from SYSPROC */
  rexxxpgm_version = "01.02"
/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

=======================================================================

  Dataset: REXX(REXBRWSR)
  Author:  KTomiak
  Contact: "Kenneth Tomiak"<CBT_Ken@KTomiak.biz>
  Syntax:  REXBRWSR {UniformResourceLocator}
           url needs to be complete.
     *------------------------------------------------------*
     * URL:                                                 *
     *   http://www.sitename.com                            *
     *   http://www.sitename.com/doclib/filename.doc        *
     *------------------------------------------------------*
  Purpose: Fetch the web page and view it.

  History of Modifications
  ------------------------
  When     Who      What you did
  -------- -------- ---------------------------------------------------
  20070731 KTomiak  01.02 Standardized for FILE 760. Sort of.
  200????? KTomiak  01.01 Converted to just write to disk, no panel.
  2003???? KTomiak  01.00 Original code.

=======================================================================

   OWNERSHIP:
   ==========
   This program is the property of Kenneth E Tomiak.
   It may be freely used without the consent of Kenneth E Tomiak.
   It may not be modified in any form.
   No payment for distribution shall be received by anyone.

   Copyright (c) 02007 - Kenneth E Tomiak : All rights reserved.

=======================================================================

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */

URLCheck:
  Parse Arg URLLine
  signal on halt
  signal on syntax

  call standard_global_disclaimer

  help_rc = check_for_help()
  If (help_rc > 0) Then Return help_rc

  Call Program_Initiation
  Call Initialize_TCPIP_Services

  Call CheckURLs URLLine

  Call Terminate_TCPIP_Services
  if (rcvdata >< "") then,
    Call Lineout 'HTMLOUT', rcvdata
  "EXECIO 0 DISKW HTMLOUT (FINIS"
  "FREE FILE(HTMLOUT)"
  Address ISPEXEC 'CONTROL ERRORS RETURN'
  Address ISPEXEC 'View dataset(REXBROWS.HTMLOUT)'
  "Delete REXBROWS.HTMLOUT"
  Exit

  /*------------------------------------------------------*/
  /*                                                      */
  /* Procedure: Program initiation                        */
  /* Purpose:   Initialize variables.                     */
  /* Arguments: None                                      */
  /* Returns:   Nothing                                   */
  /*                                                      */
  /*------------------------------------------------------*/
Program_Initiation:
  call WHERE_AM_I_STORED
  Say "Input comes from ddname="URLLine
  htmlfile = "HTMLOUT"
  nomsg = Outtrap('msgstat.')
  "FREE FILE(HTMLOUT)"
  "Delete REXBROWS.HTMLOUT"
  msgss = Outtrap(nomsg)
  "ALLOC FILE(HTMLOUT) DATASET(REXBROWS.HTMLOUT)",
    "SPACE(10, 10) TRACKS RECFM(F B) BLKSIZE(0) LRECL(1024)",
    "UNIT(SYSALLDA) NEW CATALOG"
  Say "Output goes to ddname="HTMLFile "RC="rc

  CRLF = x2c('0D25')
  LF = x2c('25')
  rcvdata = ""
  Return

  /*------------------------------------------------------*/
  /*                                                      */
  /* Procedure: Establish_A_Socket                        */
  /* Purpose:   Get the TCP/IP socket primed.             */
  /* Arguments: None                                      */
  /* Returns:   rc                                        */
  /*                                                      */
  /*------------------------------------------------------*/
Initialize_TCPIP_Services:

 /*----------------------------------------------------------------*/
 /* Initialize the Socket                                          */
 /*----------------------------------------------------------------*/
  so_txt = Socket('Initialize', 'URLCHECK', 2)
  parse var so_txt s_rc s_subtask s_maxdesc s_servicename
  socket_rc = s_rc
  if s_rc = 0 then,
    Do
      initialized = 1
      Say s_servicename":"s_subtask "initialized" s_maxdesc "sockets"
    End
  else,
    call error 'E', 40, 'Unable to initialize SOCKET URLCheck' s_rc
  Return

  /*------------------------------------------------------*/
  /*                                                      */
  /* Procedure: Establish_A_Socket                        */
  /* Purpose:   Get the TCP/IP socket primed.             */
  /* Arguments: None                                      */
  /* Returns:   rc                                        */
  /*                                                      */
  /*------------------------------------------------------*/
Establish_A_Socket:
 /*----------------------------------------------------------------*/
 /* Establish a socket                                             */
 /*----------------------------------------------------------------*/
  so_txt = Socket('Socket', 'AF_INET', 'STREAM', 'TCP')
  parse var so_txt s_rc s_results
  if s_rc <> 0 then,
    do
      call error 'E', 60, 'SOCKET(SOCKET) rc='s_rc
    end
  else,
    Do
      say "Socket(STREAM)="so_txt
      s_d = s_results
      say 'socket descriptor='s_d
      socket_rc = 0
    End

 /*----------------------------------------------------------------*/
 /* Turn  on               EBCDIC-Ascii conversion                 */
 /*----------------------------------------------------------------*/
  so_txt = Socket('SetSockOpt',s_d,'SOL_SOCKET','SO_ASCII','On')
  parse var so_txt s_rc s_results
  if s_rc = 0 then,
    Do
      Say "'Socket' So_ASCII" so_txt
    End
  else,
    call error 'W', 70, 'Unable to set SOCKET So_ASCii' s_rc
  Return

  /*------------------------------------------------------*/
  /*                                                      */
  /* Procedure: CheckURLs                                 */
  /* Purpose:   Check the modification dates of all URLs  */
  /*            listed in the specified file. If the date */
  /*            has changed, update the list file with    */
  /*            the new date.                             */
  /* Arguments: URLFile - file containing URL list        */
  /* Returns:   nothing                                   */
  /*                                                      */
  /*------------------------------------------------------*/
CheckURLs:
  Parse Arg URLline

  If socket_rc <> 0 then exit socket_rc
    /* read line with URL and last modification date    */
    say 'inline='urlline'='

       /* retrieve file   for specified URL             */
       Header = GetHeader(URLLine)

  Return


  /*------------------------------------------------------*/
  /*                                                      */
  /* Procedure: LineOut                                   */
  /* Purpose:   Output the line using EXECIO.             */
  /* Arguments: ddname                                    */
  /*            TextString                                */
  /* Returns:   rc                                        */
  /*                                                      */
  /*------------------------------------------------------*/
LineOut:
  outddname = arg(1)
  TextString = arg(2)
  push TextString
  "EXECIO 1 DISKW" outddname
  Return

  /*------------------------------------------------------*/
  /*                                                      */
  /* Function:  Connect                                   */
  /* Purpose:   Create a socket and connect it to server. */
  /* Arguments: Server - server name, may contain port no.*/
  /* Returns:   Socket number if successful, -1 otherwise */
  /*                                                      */
  /*------------------------------------------------------*/
Connect:
  Parse Arg Server

  /* if the servername has a port address specified     */
  /* then use this one, otherwise use the default http  */
  /* port 80                                            */
  Parse Var Server Server ':' Port
  If Port = '' Then
    Port = 80

  if this_is_real  = 1 then,
    do
  /* resolve server name alias to dotted IP address     */
  so_txt = Socket('Gethostbyname', server)
  parse var so_txt s_rc s_results
  if s_rc <> 0 then,
    do
      call error 'I', 80, 'GetHostByName for',
        server 'failed' s_rc
     Return -1
    end
    end

 /*----------------------------------------------------------------*/
 /* Connect the socket                                             */
 /*----------------------------------------------------------------*/
  so_txt = Socket('Connect', s_d, 'AF_INET' port server)
  parse var so_txt s_rc s_results
  if s_rc <> 0 then,
    do
      call error 'W', 120, 'SOCKET(CONNECT) rc='s_rc
    end
  else,
    Do
      say "Connected to" server s_results
    End
  Return 0

 /*----------------------------------------------------------------*/
 /* Hear what the server has to say                                */
 /*----------------------------------------------------------------*/
Peek_at_socket:
  so_txt = Socket('Recv', s_d, 1024, 'PEEK')
  parse var so_txt s_rc s_type s_port s_ip s_results
  parse var so_txt s_rc s_data_len s_data_text
  if s_rc <> 0 then,
    do
      call error 'W', 250, 'SOCKET(Peek) rc='s_rc
    end
  Return so_txt

  /*------------------------------------------------------*/
  /*                                                      */
  /* Procedure: Close_Socket                              */
  /* Purpose:   Close the socket                          */
  /* Arguments: Socket - active socket number             */
  /* Returns:   nothing                                   */
  /*                                                      */
  /*------------------------------------------------------*/
Close_socket:
  so_txt = Socket('Close', s_d)
  parse var so_txt s_rc s_results
  if s_rc <> 0 then,
    do
      call error 'W', 234, 'Close rc='s_rc
    end
  Return

  /*------------------------------------------------------*/
  /*                                                      */
  /* Function:  GetHeader                                 */
  /* Purpose:   Request the header for the specified URL  */
  /*            from the network.                         */
  /* Arguments: URL - fully specified document locator    */
  /* Returns:   Full header of specified document or      */
  /*            empty string if failed (also if no header */
  /*            exists).                                  */
  /*                                                      */
  /*------------------------------------------------------*/
GetHeader:
  Parse Arg URL

  /* Isolate server name and document name, document    */
  /* name is always preceded with a slash               */
  Parse Var URL 'http://' Server '/' Document
  Document = '/' || Document

  socket_rc = -1
  Call Establish_A_Socket
  Socket = Connect(Server)
  If Socket = -1 Then
    Return ''

  Command = 'GET' Document 'HTTP/1.0'
  sendrc = SendCommand(Socket, Command)
  Command = ''
  sendrc = SendCommand(Socket, Command)
  Header  = read_from_socket()
  Call Close_Socket
  Return Header

  /*------------------------------------------------------*/
  /*                                                      */
  /* Function:  SendCommand                               */
  /* Purpose:   Send a command via the specified socket   */
  /*            and return the full response to caller.   */
  /* Arguments: Socket - active socket number             */
  /*            Command - command string                  */
  /* Returns:   Response from server or empty string if   */
  /*            failed.                                   */
  /*                                                      */
  /*------------------------------------------------------*/
SendCommand:
  Parse Arg Socket, Command

  /* append two pairs of CRLF to end the command string */
  Command = Command || crlf
  say 'cmd='command'=cmd'

  so_txt = Socket('Write', s_d,Command)
  parse var so_txt s_rc s_results
  if s_rc <> 0 then,
    do
      call error 'E', 230, 'SOCKET(WRITE) rc='s_rc
    end
  else,
    Do
      s_data_len = s_results
      if s_data_len < 1 then say "Writing nothing?" s_data_len
    End
  return so_txt

  /*------------------------------------------------------*/
  /*                                                      */
  /* Function:  Read_From_Socket                          */
  /* Purpose:   Retrieve the results of a command or      */
  /*            socket call.                              */
  /* Arguments: Socket - active socket number             */
  /* Returns:   Response from server or empty string if   */
  /*            failed.                                   */
  /*                                                      */
  /*------------------------------------------------------*/
read_from_socket:
  Response = ''
  Do Forever
    so_txt = peek_at_socket()
    if s_rc <> 0 then,
      do
        say 'I tried to peek but had a problem:'s_rc
        say '::'so_txt'::'
        Leave
      end
    if s_data_len = 0 then,
      do
        say "I peeked and found nothing more to read."
        Leave
      end
    BytesRcvd = Socket('Recvfrom', s_d, s_data_len)
    parse var bytesrcvd s_rc s_type s_port s_ipaddr s_real_len txtdata
    If s_rc <  0 Then
      do
        say  s_rc '<= 0 so i am leaving read_from_socket' rcvdata
        Leave
      end
    if s_rc <> 0 then,
      do
        call error 'I', 242, 'SOCKET(RecvFrom) rc='s_rc
      end
    rcvdata = rcvdata||txtdata
    lf25 = pos(lf,rcvdata)
    do while lf25 > 0
      parse var rcvdata thisdata +(lf25) rcvdata
      Call Lineout 'HTMLOUT', thisdata
      lf25 = pos(lf,rcvdata)
    end
  End
  Return Response

  /*------------------------------------------------------*/
  /* Find out who I am and then show it.                  */
  /*------------------------------------------------------*/
WHERE_AM_I_STORED:
  myexitrc = 0
  PARSE VERSION,
    version_rexx_name,
    version_rexx_version,
    version_rexx_date
  PARSE SOURCE,
    source_host_env,
    source_call_type,
    source_uc_exec_name,
    source_hostdd,
    source_hostdsn,
    source_nf_exec_name,
    source_initial_cmd_env,
    source_asid_name,
    source_char8_user_token,
    source_hostother
  Address_Environment = Address()
  job_specs = rexx_jobspecs()
  say ""
  say Copies("=",55)
  say left("=" source_uc_exec_name rexxpgm_version,53) "="
  say left("=" "executing under" source_host_env,53) "="
  say left("=" "as a" source_call_type,53) "="
  say left("=  on" date() "at" time()".",53) "="
  say Copies("=",55)
  say ""
  return_code = 0
  sysvar_sysuid=SYSVAR("SYSUID")
  RETURN


  /*------------------------------------------------------*/
  /* Syntax error routine                                 */
  /*------------------------------------------------------*/
syntax:
  xrc = rc
  say "xrc="xrc
  sigl_record = sigl
  MY_DATA=SOURCELINE(SIGL_RECORD)
  say sigl_record my_data
  call error 'E', rc, '==> REXX Error No.' xrc '@ line',
    sigl_record
  return

  /*------------------------------------------------------*/
  /* Halt   error routine                                 */
  /*------------------------------------------------------*/
halt:
  call error 'E', 220, '==> REXX Interrupted'
  return

  /*------------------------------------------------------*/
  /* Common error routine                                 */
  /*------------------------------------------------------*/
error:
  type = arg(1)
  retc = arg(2)
  text = arg(3)
  ecretc = right(retc,3,'0')
  ectype = translate(type)
  ecfull = 'URLCheck' || ecretc || ectype
  say '===> 'type":" ecfull text
  if type <> 'E' then return
  if (initialized = 0) then,
    do
      so_txt = Socket('SocketSetStatus')
      parse var so_txt s_rc s_severreason
      if (s_rc <> 'Connected') then,
        say 'The status of the socket set is' s_rc s_severreason
    end
  else,
    do
      so_txt = Socket('SocketSetStatus')
      parse var so_txt s_rc s_severreason
      if (s_rc <> 'Connected') then,
        say 'The status of the socket set is' s_rc s_severreason
    end
  so_txt = Socket('Terminate')
  exit retc

Terminate_TCPIP_Services:
  /*-------------------------------------------------------*/
  /* Terminate the socket and exit                         */
  /*-------------------------------------------------------*/
  so_txt = Socket('Terminate')
  Return

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
 Warn them they ought to do due-diligence and know what they run.
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
standard_global_disclaimer:
  Say ""
  Say "STANDARD GLOBAL DISCLAIMER"
  Say "=========================="
  Say "The author explicitly disavows any claim whatsoever about"
  Say "the correctness or functionality of this program, and"
  Say "disclaims liability for anything and everything bad that"
  Say "might happen in connection with, before, during, or after"
  Say "using it. I have tried to make it work right, and I am"
  Say "personally pretty confident that it does, but everybody"
  Say "makes mistakes, so if you use it, you do so at your own"
  Say "risk."
  Say ""
  Return

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
 Either a question mark or some switch form of HELP, gets syntax.
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
check_for_help:
  Push all_my_arguments
  Pull all_uc_arguments
  If (all_my_arguments= "") Then,
    Do
      Call show_simple_syntax
      Call show_some_history
      Return 4
    End
  If (Pos("?",all_my_arguments) > 0) Then,
    Do
      Call show_simple_syntax
      Return 4
    End
  If (Pos("/HELP",all_uc_arguments) > 0) Then,
    Do
      Call show_simple_syntax
      Return 4
    End
  If (Pos("-HELP",all_uc_arguments) > 0) Then,
    Do
      Call show_simple_syntax
      Return 4
    End
  Return 0

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
  Place any of your subroutines and procedures below this.
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
rexx_jobspecs:
  /*---------------------------------------------------------------*/
  /* ADDRESSABILITY TO CVT FROM PSA                                */
  /*---------------------------------------------------------------*/
  PTR2PSA = 0
  CVTPTR = STORAGE(D2X(PTR2PSA + 16),4)
  /*---------------------------------------------------------------*/
  /* ADDRESSABILITY TO SMCA, THEN GET SMF SYSTEM ID                */
  /*---------------------------------------------------------------*/
  CVTSMCA = STORAGE(D2X(C2D(CVTPTR)+197),3)
  SMFID = STORAGE(D2X(C2D(CVTSMCA)+16),4)
  /*---------------------------------------------------------------*/
  /* GET JOBNAME, STEP, AND PROCEDURE                              */
  /*---------------------------------------------------------------*/
  PSATOLD  = STORAGE(21C,4)                    /* POINTER TO TCB   */
  PTRTIOT  = STORAGE(D2X(C2D(PSATOLD)+12),4)   /* POINTER TO TIOT  */
  JOBNAME  = STORAGE(D2X(C2D(PTRTIOT)),8)
  STEPNAME = STORAGE(D2X(C2D(PTRTIOT)+8),8)
  PROCNAME = STORAGE(D2X(C2D(PTRTIOT)+16),8)
  Tcbjscbb = Storage(D2x(C2d(Psatold)+181),3)                /* jscb */
  jscbssib = STORAGE(D2X(C2D(tcbjscbb)+316),4)        /* Ptr to SSIB */
  ssibjbid = STORAGE(D2X(C2D(jscbssib)+12),8)      /* job identifier */
  Return JOBNAME SSIBJBID STEPNAME PROCNAME

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
 Either a question mark or some switch form of HELP, gets syntax.
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
show_simple_syntax:
  Say ""
  Say "You want to know how to use" source_uc_exec_name"?"
  Say "So would I."
  Say ""
  back_wards = Reverse(source_uc_exec_name)
  Parse Var back_wards ucname "\" path_drive
  ucname = Reverse(ucname)
  Parse Var ucname ucname "." extension
  dashname = Left(ucname""Copies("-",12),12)
  Say "Syntax:"
  Say ">>--"dashname"+url+-----------------+----<<"
  Say ""
  Say "              url needs to be a complete url, including"
  Say "              http:// the hostname / directories / filename"
  Say ""
  Say "Note: Some web servers are case sensitive."
  Say ""
  Return

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
 No parameters were passed.
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
show_some_history:
  Say Copies("-",79)
  Say "History:"
  Say "I first ported URLCHECK from the PC to z/OS, then I started"
  Say "expanding it to receive the entire web page. At one point I"
  Say "had a panel with an input field field for a url and plans"
  Say "to have a cursor sensitive pfkey to let you click a url on"
  Say "any web page."
  Say ""
  Say "Some day I will get back to that project. Until then,"
  Say "this code will retrieve an entire web page to a z/OS"
  Say "dataset and let you view it. Which would let you use ISPF"
  Say "cut & paste if the page is suited for the mainframe."
  Say ""
  Say "I produce web pages where 'MVS' code is suitable for that."
  Say ""
  Say '"Kenneth Tomiak"<CBT_Ken@KTomiak.biz>'
  Say ""
  Say Copies("-",79)
  Say ""
  Return

    /*------------------------------------------------------

     The HEAD command can be sent in two formats: the simple request or
the full request. The full request format of the HEAD command is defined
as follows:

    HEAD documentname HTTP/1.0<CRLF>
    request header<CRLF>

For our purpose we don't need to pass additional options in the request
header field so we can leave this field blank. However we may not omit
the closing CRLF character pair terminating the request header field
otherwise the server would not accept it as a valid command. The full
request sent to a server will return a full response in the format:

    HTTP/1.0 statuscode reasonphrase<CRLF>
    response body<CRLF>

The HTTP specification lists several information fields for the
response body that can appear in any order. Currently we are only
interested in the Last-Modified field and ignore all other fields.

     The following line shows a sample HEAD command sent to a server
with the appropriate response:

    HEAD / HTTP/1.0<CRLF><CRLF>

Response from server:

    HTTP/1.0 200 OK<CRLF>
    Server: GoServe/2.45<CRLF>
    Date: Thu, 18 Jul 1996 15:40:47 GMT<CRLF>
    Content-Type: text/html<CRLF>
    Content-Length: 1081<CRLF>
    Content-Transfer-Encoding: binary<CRLF>
    Last-Modified: Thu, 19 Oct 1995 16:27:52 GMT<CRLF>

Since we are only interested in the date when the document has been
last modified we have to search the response for this keyword. During
development of this sample I discovered that most web servers use the
exact string as shown above to identify this field, some other servers
however don't. To be able to find  the date in responses from all
servers we can simply uppercase the whole string before searching the
last-modified field.

     This is already everything we need to know for our program.

      ------------------------------------------------------*/
./ ADD NAME=REXFTPAP 0666-07213-07213-1943-00001-00001-00000-DIR2UPDT
rexx_REXFTPAP: /* We still need rexx in comment if read from SYSPROC */
/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

 Dataset:  KTOMIAK.REXX(REXFTPAP)
 Author:   KTomiak
 Contact:  "Kenneth Tomiak"<KenTomiak@KTomiak.org>
 Syntax:   REXFTPAP {ftp_site}
 Overview: Use the CS REXX api to effectively do an FTP.

=======================================================================

 History of Modifications
 ------------------------
  When     Who      What you did
  -------- -------- ---------------------------------------------------
  20070506 KTOMIAK  Original code.

=======================================================================

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */

  Parse Arg all_my_arguments
  Numeric Digits 12

rexx_Main_REXFTPAP:
/*---------------------------------------------------------------------

Create an FTP Control Area Interface stem variable
Initialize the API and open a connection to an FTP server
Login with your userid     (what about NETRC?)
Specify your password      (what about NETRC?)
Do
  things you want to do
  (this will list all MVS datasets for the user,
   select a PDS and cd into it,
   get a member into a sequential dataset,
   cd up,
   list the MVS datasets)
End
Quit to end your session
Terminate this instance of the FTP Client API

---------------------------------------------------------------------*/

  my_rc = init_my_parms()
  if (my_rc = 0) then my_rc = my_main_loop()
  if (ftp_api_initialized = 1) then my_rc = my_cleanup()
  return my_rc

init_my_parms:
  PARSE VERSION,
    version_rexx_name,
    version_rexx_version,
    version_rexx_date
  PARSE SOURCE,
    source_host_env,
    source_call_type,
    source_uc_exec_name,
    source_hostdd,
    source_hostdsn,
    source_nf_exec_name,
    source_initial_cmd_env,
    source_asid_name,
    source_char8_user_token,
    source_hostother
  Address_Environment = Address()
  job_specs = rexx_jobspecs()
  say ""
  say Copies("=",55)
  say left("=" source_uc_exec_name rexxpgm_version,53) "="
  say left("=" "executing under" source_host_env,53) "="
  say left("=" "as a" source_call_type,53) "="
  say left("=  on" date() "at" time()".",53) "="
  say Copies("=",55)
  say ""
  return_code = 0
  sysvar_sysuid=SYSVAR("SYSUID")

/*-------------------------------------------------------------------*/
/* Setup the constants for the FTPAPI invocations                    */
/*-------------------------------------------------------------------*/
  TRACEID      = "123"
  USER_COMMAND = "user" sys_sysuid
  PASS_COMMAND = "pass atshare"
  PASS_ACCT    = "acct SYSPROG"
  DIR_COMMAND  = "dir *"
  TMP_COMMAND  = "dir /tmp/*"
  OPENSTRING   = "-w 300 ftp.ktomiak.biz 21"
  OPENSTRING   = "127.0.0.1 21 -w 300"
  ENVVAR.      = ""
  ENVVAR.0     = 9
  ENVVAR.1     = "_CEE_DMPTARG=/tmp"
  ENVVAR.2     = "_BPX_JOBNAME=MYJOB"

  msg_rc = MSG("OFF")
  "delete fcai.trace"
  "Alloc file(FTPRXTRC) dataset(fcai.trace) new catalog",
    "unit(sysallda)",
    "track space(10 10)",
    "dsorg(ps) recfm(f b) blksize(0) lrecl(80)"
  alloc_rc = rc
  msg_rc = MSG("ON")
  if (alloc_rc >< 0) then,
    "Alloc file(FTPRXTRC) dataset(fcai.trace) old reuse"

/*-------------------------------------------------------------------*/
/* Initialize the FCAI stem.                                         */
/*-------------------------------------------------------------------*/
  ftp_rc = FtpApi('fcai.', 'create', TRACEID)
  if (ftp_rc < 0) then,
    do
      Say 'Unable to create the FCAI'
      return ftp_rc
    end

/*-------------------------------------------------------------------*/
/* Turn on tracing of the Client API tracing.  This is a different   */
/* trace from the REXX FTP Client API trace and is always written    */
/* to SYSOUT.                                                        */
/*-------------------------------------------------------------------*/
  if (traceid >< "") then,
    do
      ftp_rc = FtpApi('fcai.', 'set_trace', 'ON')
      if (ftp_rc < 0) then,
        do
          call ftp_error 'fcai.'
          return ftp_rc
        end
      end
  ftp_api_initialized = 1
  pds_mbr = ""

  return 0

my_cleanup:
/*-------------------------------------------------------------------*/
/* Enter the QUIT subcommand and  terminate the connection.          */
/* It's better to enter the QUIT subcommand before entering the      */
/*    FTPAPI('term') command.   In this way, any error traces can be */
/*    displayed.                                                     */
/*-------------------------------------------------------------------*/
  ftp_rc = FtpApi('fcai.', 'scmd', 'QUIT', 'W')
  if (ftp_rc < 0) then,
    do
      call ftp_error 'fcai.'
    end
/*-------------------------------------------------------------------*/
/* Enter the TERM request to close this instance of the FTP client   */
/* API.                                                              */
/*-------------------------------------------------------------------*/
  ftp_rc = FtpApi('fcai.', 'term')
  if (ftp_rc < 0) then,
    do
      Say "Unexpected error on FTPAPI('term')"
      return ftp_rc
    end
  ftp_api_initialized = 0
  msg_rc = MSG("OFF")
  "Free file(FTPRXTRC)"
  msg_rc = MSG("ON")
  return 0

my_main_loop:
/*-------------------------------------------------------------------*/
/* Initialize the FTP client environment and open a connection       */
/* to the FTP server using the OPENSTRING.  Two environment          */
/* variables are also provided to the FTP Client API to be used      */
/* when intitializing its environment.                               */
/*-------------------------------------------------------------------*/
  ftp_rc = FTPAPI('fcai.', 'init', OPENSTRING, ENVVAR.1, ,
    ENVVAR.2, ENVVAR.3, ENVVAR.4, ENVVAR.5, ,
    ENVVAR.6, ENVVAR.7, ENVVAR.8, ENVVAR.9)
  if (ftp_rc < 0) then,
    do
      call ftp_error 'fcai.'
      return ftp_rc
    end
  login_req = fcai.FCAI_ReplyCode
  call ftp_error 'fcai.'
  ftp_rc = FtpApi('fcai.', 'getl_copy', 'lines.', 'A')
  if (ftp_rc < 0) then,
    do
      call ftp_error 'fcai.'
      return ftp_rc
    end
  say 'INIT output is:'
  do i = 1 to lines.0
    say lines.i
  end

/*-------------------------------------------------------------------*/
/* Sign on                                                           */
/* Enter the userid.                                                 */
/*-------------------------------------------------------------------*/
  if (login_req = 220) then,
    do
      say "We need to login"
      ftp_rc = FtpApi('fcai.', 'scmd', USER_COMMAND, 'W')
      if (ftp_rc < 0) then,
        do
          call ftp_error 'fcai.'
          return ftp_rc
        end
    end
  else,
    do
      say "User does not need to login."
    end

/*-------------------------------------------------------------------*/
/* If the FTP server prompts for a password, provide one.  In some   */
/* instances, an FTP server may not prompt for a password (e.g.,     */
/* when an anonymous user logs on to some FTP servers).              */
/*-------------------------------------------------------------------*/
  if (fcai.FCAI_Result =  FCAI_RESULT_PROMPTPASS) then,
    do
      say "We need to use a password."
      ftp_rc = FtpApi('fcai.', 'scmd', PASS_COMMAND, 'W')
      if (ftp_rc < 0) then,
        do
          call ftp_error 'fcai.'
          return ftp_rc
        end
    end
  else,
    do
      say "Password is not required."
    end

/*-------------------------------------------------------------------*/
/* If the FTP server prompts for an acct,    provide one.  In some   */
/* instances, an FTP server may not prompt for an acct. Few do.      */
/*-------------------------------------------------------------------*/
  if (fcai.FCAI_Result =  FCAI_RESULT_PROMPTACCT) then,
    do
      say "We need to use an acct."
      ftp_rc = FtpApi('fcai.', 'scmd', PASS_ACCT, 'W')
      if (ftp_rc < 0) then,
        do
          call ftp_error 'fcai.'
          return ftp_rc
        end
    end
  else,
    do
      say "An account is not required."
    end

/*-------------------------------------------------------------------*/
/* STATUS                                                            */
/*-------------------------------------------------------------------*/
  ftp_rc = FtpApi('fcai.', 'scmd', "STATUS", 'W')
  if (ftp_rc < 0) then,
    do
      call ftp_error 'fcai.'
      return ftp_rc
    end
/*-------------------------------------------------------------------*/
/* Fetch the lines returned by the STATUS command.                   */
/*-------------------------------------------------------------------*/
  ftp_rc = FtpApi('fcai.', 'getl_copy', 'lines.', 'A')
  if (ftp_rc < 0) then,
    do
      call ftp_error 'fcai.'
      return ftp_rc
    end
  say 'STATUS output is:'
  do i = 1 to lines.0
    say lines.i
  end

/*-------------------------------------------------------------------*/
/* List directory entries                                            */
/* Enter a subcommand DIR_COMMAND to retrieve a listing of all files */
/*    in the directory.  The REXX program requests the FTP client    */
/*    API wait for the subcommand to complete before returning.      */
/*-------------------------------------------------------------------*/
  ftp_rc = FtpApi('fcai.', 'scmd', DIR_COMMAND, 'W')
  if (ftp_rc < 0) then,
    do
      call ftp_error 'fcai.'
      return ftp_rc
    end
/*-------------------------------------------------------------------*/
/* Fetch the lines returned by the DIR subcommand.                   */
/*-------------------------------------------------------------------*/
  ftp_rc = FtpApi('fcai.', 'getl_copy', 'lines.', 'L')
  if (ftp_rc < 0) then,
    do
      call ftp_error 'fcai.'
      return ftp_rc
    end

/*-------------------------------------------------------------------*/
/* Display the results of the output.  lines.0 contains the total    */
/* number of lines returned, while lines.1...lines.n contains the    */
/* output for each individual line.                                  */
/*-------------------------------------------------------------------*/
  say 'Directory output is:'
  do i = 1 to lines.0
     parse var lines.i,
       dir_vol,
       dir_unit,
       dir_refdt,
       dir_ext,
       dir_used,
       dir_recfm,
       dir_lrecl,
       dir_blksize,
       dir_dsorg,
       dir_dsnllqs,
       .
/*
     say,
       dir_vol,
       dir_unit,
       dir_refdt,
       dir_ext,
       dir_used,
       dir_recfm,
       dir_lrecl,
       dir_blksize,
       dir_dsorg,
       dir_dsnllqs
*/
     if ((dir_recfm = "FB") &,
         (dir_lrecl = "80") &,
         (dir_dsorg = "PO")) then,
       pds_dsn = dir_dsnllqs
  end
  say pds_dsn

/*

 Volume Unit    Referred Ext Used Recfm Lrecl BlkSz Dsorg Dsname
 SHTSO2 3390   2007/02/25  1    1  FB     150  1500  PS  BRODCAST
 SHTSO1 3390   2007/02/25  1    8  FB      80 32720  PO  CLIST
 SHTSO4 3390   2007/02/25  1   10  U    13680 13680  PS  ISR9139.BACKUP

*/
  say "CD to KEN"
  ftp_rc = FtpApi('fcai.', 'scmd', 'cd KEN', 'W')
  if (ftp_rc < 0) then,
    do
      call ftp_error 'fcai.'
    end
  say "CD to .."
  ftp_rc = FtpApi('fcai.', 'scmd', 'cd ..', 'W')
  if (ftp_rc < 0) then,
    do
      call ftp_error 'fcai.'
    end
  say "CD to" pds_dsn
  ftp_rc = FtpApi('fcai.', 'scmd', 'cd' pds_dsn, 'W')
  if (ftp_rc < 0) then,
    do
      call ftp_error 'fcai.'
      return ftp_rc
    end

  ftp_rc = FtpApi('fcai.', 'scmd', 'DIR *', 'W')
  if (ftp_rc < 0) then,
    do
      call ftp_error 'fcai.'
      return ftp_rc
    end
  ftp_rc = FtpApi('fcai.', 'getl_copy', 'lines.', 'L')
  if (ftp_rc < 0) then,
    do
      call ftp_error 'fcai.'
      return ftp_rc
    end
  do i = 1 to lines.0
    parse var lines.i,
       =1 mbr_name +8,
      =11 mbr_stats +5,
      =17 mbr_credt +10,
      =28 mbr_chgdt +10,
      =44 mbr_size +6,
      =50 mbr_init +6,
      =55 mbr_mod +6,
      =63 mbr_user +7
    if (mbr_name >< "") then,
      pds_name = mbr_name
    say pds_name
  end

  say "lcd"
  ftp_rc = FtpApi('fcai.', 'scmd', "lcd '"sys_sysuid"'", 'W')
  if (ftp_rc < 0) then,
    do
      call ftp_error 'fcai.'
      return ftp_rc
    end
  loc_cmd = "locsite progress=15"
  say loc_cmd
  ftp_rc = FtpApi('fcai.', 'scmd', loc_cmd, 'W')
  if (ftp_rc < 0) then,
    do
      call ftp_error 'fcai.'
    end
  loc_cmd = "locsite dsorg=ps recfm=fb lrecl=80 blksize=0"
  say loc_cmd
  ftp_rc = FtpApi('fcai.', 'scmd', loc_cmd, 'W')
  if (ftp_rc < 0) then,
    do
      call ftp_error 'fcai.'
    end
  loc_cmd = "locsite tracks primary=5 secondary=2"
  say loc_cmd
  ftp_rc = FtpApi('fcai.', 'scmd', loc_cmd, 'W')
  if (ftp_rc < 0) then,
    do
      call ftp_error 'fcai.'
    end
  say "get" mbr_name
  ftp_rc = FtpApi('fcai.', 'scmd', 'get' mbr_name, 'W')
  if (ftp_rc < 0) then,
    do
      call ftp_error 'fcai.'
    end

/*

 Name     VV.MM   Created       Changed      Size  Init   Mod   Id
IEBGENER  01.01 2006/12/24 2006/12/30 12:06    14    14     3 KTOMIAK
IEBUPDTE  01.07 2006/12/20 2006/12/30 12:48    14    10     8 KTOMIAK
IEFBR14   01.07 2006/12/20 2007/01/07 00:50    26    18    17 KTOMIAK
UPDTE     01.01 2006/12/20 2006/12/20 23:15    13    13     0 KTOMIAK

*/
  return 0

/*-------------------------------------------------------------------*/
/* Generic error handling routine for the FTP interface.  This       */
/* should only be called with a valid FCAI.                          */
/*-------------------------------------------------------------------*/
ftp_error: arg stem
  say 'FTP Client API Display:' stem
  say '    Result     =' value(stem'FCAI_Result')
  say '    IE         =' value(stem'FCAI_IE')
  say '    CEC        =' value(stem'FCAI_CEC')
  say '    ReplyCode  =' value(stem'FCAI_ReplyCode')
  say '    TraceStatus=' value(stem'FCAI_TraceStatus')
  say '    ReturnCode =' value(stem'FCAI_ReturnCode')
  say '    ReasonCode =' value(stem'FCAI_ReasonCode')
  say '    SCMD       =' value(stem'FCAI_SCMD')

  say '    Status     =' value(stem'FCAI_Status')
  map_it = c2x(value(stem'FCAI_MAP'))
  ftp_rc = FtpApi('fcai.', 'get_fcai_map', "fcaimap.")
  if (ftp_rc < 0) then,
    do
      say "get_fcai_map failed" ftp_rc
      return
    end
   do while map_it >< ""
     parse var map_it tmp_it +40 map_it
     say "  Map " tmp_it
   end
   say "   "fcaimap".FCAI_EyeCatcher =",
      value(fcaimap."FCAI_EyeCatcher")
   say "   "fcaimap".FCAI_Size =",
      value(fcaimap."FCAI_Size")
   say "   "fcaimap".FCAI_Version =",
      value(fcaimap."FCAI_Version")
   say "   "fcaimap".FCAI_PollWait =",
      value(fcaimap."FCAI_PollWait")
   say "   "fcaimap".FCAI_ReqTimer =",
      value(fcaimap."FCAI_ReqTimer")
   say "   "fcaimap".FCAI_TraceIt =",
      value(fcaimap."FCAI_TraceIt")
   say "   "fcaimap".FCAI_TraceID =",
      value(fcaimap."FCAI_TraceID")
   say "   "fcaimap".FCAI_TraceCAPI =",
      value(fcaimap."FCAI_TraceCAPI")
   say "   "fcaimap".FCAI_TraceStatus =",
      value(fcaimap."FCAI_TraceStatus")
   say "   "fcaimap".FCAI_TraceSClass =",
      value(fcaimap."FCAI_TraceSClass")
   say "   "fcaimap".FCAI_TraceName =",
      value(fcaimap."FCAI_TraceName")
   say "   "fcaimap".FCAI_Token =",
      value(fcaimap."FCAI_Token")
   say "   "fcaimap".FCAI_RequestID =",
      value(fcaimap."FCAI_RequestID")
   say "   "fcaimap".FCAI_Result =",
      value(fcaimap."FCAI_Result")
   say "   "fcaimap".FCAI_IE =",
      value(fcaimap."FCAI_IE")
   say "   "fcaimap".FCAI_CEC =",
      value(fcaimap."FCAI_CEC")
   say "   "fcaimap".FCAI_ReplyCode =",
      value(fcaimap."FCAI_ReplyCode")
   say "   "fcaimap".FCAI_SCMD =",
      value(fcaimap."FCAI_SCMD")
   say "   "fcaimap".FCAI_ReturnCode =",
      value(fcaimap."FCAI_ReturnCode")
   say "   "fcaimap".FCAI_ReasonCode =",
      value(fcaimap."FCAI_ReasonCode")
   say "   "fcaimap".FCAI_NumberLines =",
      value(fcaimap."FCAI_NumberLines")
   say "   "fcaimap".FCAI_LongestLine =",
      value(fcaimap."FCAI_LongestLine")
   say "   "fcaimap".FCAI_SizeAll =",
      value(fcaimap."FCAI_SizeAll")
   say "   "fcaimap".FCAI_SizeMessages =",
      value(fcaimap."FCAI_SizeMessages")
   say "   "fcaimap".FCAI_SizeReplies =",
      value(fcaimap."FCAI_SizeReplies")
   say "   "fcaimap".FCAI_SizeList =",
      value(fcaimap."FCAI_SizeList")
   say "   "fcaimap".FCAI_SizeTrace =",
      value(fcaimap."FCAI_SizeTrace")
   say "   "fcaimap".FCAI_PID =",
      value(fcaimap."FCAI_PID")
   return

/*
Map  C6C3C1C9010001000001F1F2F30000C1E2E8E2F0
Map  F0F0F4F53174E200C9D5C9E30000000000DC0A00
Map  0000000000000000000000060000004F00000122
Map  000000960000008F000000000000000000000114
Map  0000000000000000000000000000000000000000
Map  0000000000000000000000000000000000000000
Map  0000000000000000000000000000000000000000
Map  0000000000000000000000000000000000000000
Map  000000003174FEF03174E224B163844EB1755118
Map  B1755118317500243174EF603163FAE300000004
Map  B1638340317510BC3179AB783163EC9831752EED
Map  3175036431750024B163820031752EED06000001
Map  0000000031750410000000003163863C
*/

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
  Place any of your subroutines and procedures below this.
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
rexx_jobspecs:
  /*---------------------------------------------------------------*/
  /* ADDRESSABILITY TO CVT FROM PSA                                */
  /*---------------------------------------------------------------*/
  PTR2PSA = 0
  CVTPTR = STORAGE(D2X(PTR2PSA + 16),4)
  /*---------------------------------------------------------------*/
  /* ADDRESSABILITY TO SMCA, THEN GET SMF SYSTEM ID                */
  /*---------------------------------------------------------------*/
  CVTSMCA = STORAGE(D2X(C2D(CVTPTR)+197),3)
  SMFID = STORAGE(D2X(C2D(CVTSMCA)+16),4)
  /*---------------------------------------------------------------*/
  /* GET JOBNAME, STEP, AND PROCEDURE                              */
  /*---------------------------------------------------------------*/
  PSATOLD  = STORAGE(21C,4)                    /* POINTER TO TCB   */
  PTRTIOT  = STORAGE(D2X(C2D(PSATOLD)+12),4)   /* POINTER TO TIOT  */
  JOBNAME  = STORAGE(D2X(C2D(PTRTIOT)),8)
  STEPNAME = STORAGE(D2X(C2D(PTRTIOT)+8),8)
  PROCNAME = STORAGE(D2X(C2D(PTRTIOT)+16),8)
  Tcbjscbb = Storage(D2x(C2d(Psatold)+181),3)                /* jscb */
  jscbssib = STORAGE(D2X(C2D(tcbjscbb)+316),4)        /* Ptr to SSIB */
  ssibjbid = STORAGE(D2X(C2D(jscbssib)+12),8)      /* job identifier */
  Return JOBNAME SSIBJBID STEPNAME PROCNAME

./ ADD NAME=REXFTPLS 0666-07213-07213-1936-00001-00001-00000-DIR2UPDT
9exx_REXFTPLS: /* We still need rexx in comment if read from SYSPROC */
/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

 Dataset:  KTOMIAK.REXX(REXFTPLS)
 Author:   KTomiak
 Contact:  "Kenneth Tomiak"<KenTomiak@KTomiak.org>
 Syntax:   REXFTPLS {arguments ...}
 Overview: (tell us about the code)

Create an FTP Control Area Interface stem variable
Initialize the API and open a connection to an FTP server
Login with your userid
Specify your password
Do
  things you want to do
End
Quit to end your session
Terminate this instance of the FTP Client API


=======================================================================

 History of Modifications
 ------------------------
  When     Who      What you did
  -------- -------- ---------------------------------------------------
  20070506 KTOMIAK  Original code.

=======================================================================

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */

  Parse Arg all_my_arguments
  Numeric Digits 12

rexx_Main_REXFTPLS:
  return_code = rexx_Initialize()
  If (return_code = 0) then,
    Do
      return_code = rexx_Process()
      return_code = rexx_Termination()
    End
  Return 0

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
 In this routine we open any files and initialize any
 constants we might need.
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
rexx_Initialize:
  PARSE VERSION,
    version_rexx_name,
    version_rexx_version,
    version_rexx_date
  PARSE SOURCE,
    source_host_env,
    source_call_type,
    source_uc_exec_name,
    source_hostdd,
    source_hostdsn,
    source_nf_exec_name,
    source_initial_cmd_env,
    source_asid_name,
    source_char8_user_token,
    source_hostother
  Address_Environment = Address()
  job_specs = rexx_jobspecs()
  say ""
  say Copies("=",55)
  say left("=" source_uc_exec_name rexxpgm_version,53) "="
  say left("=" "executing under" source_host_env,53) "="
  say left("=" "as a" source_call_type,53) "="
  say left("=  on" date() "at" time()".",53) "="
  say Copies("=",55)
  say ""
  return_code = 0
  sysvar_sysuid=SYSVAR("SYSUID")
  sysvar_sysenv = SYSVAR("SYSENV")

  If (source_host_env >< "TSO") Then,
    Do
      Say "Wrong host environment" source_host_env
      return_code = 16
    End
/*-------------------------------------------------------------------*/
/* Setup the constants for the FTPAPI invocations                    */
/*-------------------------------------------------------------------*/
  TRACEID      = "PAZ"
  parse var all_my_arguments localhost .
  Select
    when (localhost = "YES") then,
      do
        USER_COMMAND = "user ktomiak"
        PASS_COMMAND = "pass atshare"
        PASS_ACCT    = "acct SYSPROG"
        TMP_COMMAND  = "DIR /tmp/*"
        OPENSTRING   = "-w 300 127.0.0.1 21 "
      end
    Otherwise,
      say "H e l p     M e !!"
      exit 12
  END
  ENVVAR1      = "_CEE_DMPTARG=/tmp"
  ENVVAR2      = "_BPX_JOBNAME=MYJOB"

/*-------------------------------------------------------------------*/
/* Initialize the FCAI stem.                                         */
/*-------------------------------------------------------------------*/
  ftpapi_verb = "create"
  ftp_rc = FtpApi("fcai.", ftpapi_verb, TRACEID)
  if (ftp_rc < 0) then,
    do
      Say "Unable to create the FCAI"
      return ftp_rc
    end

/*-------------------------------------------------------------------*/
/* Turn on tracing of the Client API tracing.  This is a different   */
/* trace from the REXX FTP Client API trace and is always written    */
/* to SYSOUT.                                                        */
/*-------------------------------------------------------------------*/
  if (traceid >< "") then,
    do
      ftpapi_verb = "set_trace"
      ftp_rc = FtpApi("fcai.", ftpapi_verb, "ON")
      if (ftp_rc < 0) then,
        do
          call ftp_error "fcai."
          return ftp_rc
        end
      end
  ftp_rc = FtpApi("fcai.", "set_trace", "OFF")
  Return return_code

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
 In this routine we do our processing.
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
rexx_Process:
  if (return_code = 0) then return_code = my_main_loop()
  Return return_code

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
 In this routine we close files and finish up.
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
rexx_Termination:
/*-------------------------------------------------------------------*/
/* Enter the QUIT subcommand and  terminate the connection.          */
/* It"s better to enter the QUIT subcommand before entering the      */
/*    FTPAPI("term") command.   In this way, any error traces can be */
/*    displayed.                                                     */
/*-------------------------------------------------------------------*/
  ftpapi_verb = "scmd"
  ftp_rc = FtpApi("fcai.", ftpapi_verb, "QUIT", "W")
  if (ftp_rc < 0) then,
    do
      call ftp_error "fcai."
    end
/*-------------------------------------------------------------------*/
/* Enter the TERM request to close this instance of the FTP client   */
/* API.                                                              */
/*-------------------------------------------------------------------*/
  ftpapi_verb = "term"
  ftp_rc = FtpApi("fcai.", ftpapi_verb)
  if (ftp_rc < 0) then,
    do
      Say "Unexpected error on FTPAPI("term")"
      exit -1
    end
  return 0

  Return return_code

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
 Place any of your subroutines and procedures below this.
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
rexx_jobspecs:
  /*---------------------------------------------------------------*/
  /* ADDRESSABILITY TO CVT FROM PSA                                */
  /*---------------------------------------------------------------*/
  PTR2PSA = 0
  CVTPTR = STORAGE(D2X(PTR2PSA + 16),4)
  /*---------------------------------------------------------------*/
  /* ADDRESSABILITY TO SMCA, THEN GET SMF SYSTEM ID                */
  /*---------------------------------------------------------------*/
  CVTSMCA = STORAGE(D2X(C2D(CVTPTR)+197),3)
  SMFID = STORAGE(D2X(C2D(CVTSMCA)+16),4)
  /*---------------------------------------------------------------*/
  /* GET JOBNAME, STEP, AND PROCEDURE                              */
  /*---------------------------------------------------------------*/
  PSATOLD  = STORAGE(21C,4)                    /* POINTER TO TCB   */
  PTRTIOT  = STORAGE(D2X(C2D(PSATOLD)+12),4)   /* POINTER TO TIOT  */
  JOBNAME  = STORAGE(D2X(C2D(PTRTIOT)),8)
  STEPNAME = STORAGE(D2X(C2D(PTRTIOT)+8),8)
  PROCNAME = STORAGE(D2X(C2D(PTRTIOT)+16),8)
  Tcbjscbb = Storage(D2x(C2d(Psatold)+181),3)              /* jscb */
  jscbssib = STORAGE(D2X(C2D(tcbjscbb)+316),4)      /* Ptr to SSIB */
  ssibjbid = STORAGE(D2X(C2D(jscbssib)+12),8)    /* job identifier */
  Return JOBNAME SSIBJBID STEPNAME PROCNAME
/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
 describe your routines here
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */

/*-------------------------------------------------------------------*/
/* Initialize the FTP client environment and open a connection       */
/* to the FTP server using the OPENSTRING.  Two environment          */
/* variables are also provided to the FTP Client API to be used      */
/* when intitializing its environment.                               */
/*-------------------------------------------------------------------*/
my_main_loop:
  ftpapi_verb = "init"
  ftp_rc = FTPAPI("fcai.", ftpapi_verb, OPENSTRING, ENVVAR1, ENVVAR2)
  if (ftp_rc < 0) then,
    do
      call ftp_error "fcai."
      return ftp_rc
    end

/*-------------------------------------------------------------------*/
/* Sign on                                                           */
/* Enter the userid.                                                 */
/*-------------------------------------------------------------------*/
  ftpapi_verb = "scmd"
  ftp_rc = FtpApi("fcai.", ftpapi_verb, USER_COMMAND, "W")
  if (ftp_rc < 0) then,
    do
      call ftp_error "fcai."
      return ftp_rc
    end

/*-------------------------------------------------------------------*/
/* If the FTP server prompts for a password, provide one.  In some   */
/* instances, an FTP server may not prompt for a password (e.g.,     */
/* when an anonymous user logs on to some FTP servers).              */
/*-------------------------------------------------------------------*/
  if (fcai.FCAI_Result =  FCAI_RESULT_PROMPTPASS) then,
    do
      ftpapi_verb = "scmd"
      ftp_rc = FtpApi("fcai.", ftpapi_verb, PASS_COMMAND, "W")
      if (ftp_rc < 0) then,
        do
          call ftp_error "fcai."
          return ftp_rc
        end
    end
/*-------------------------------------------------------------------*/
/* If the FTP server prompts for an acct,    provide one.  In some   */
/* instances, an FTP server may not prompt for an acct. Few do.      */
/*-------------------------------------------------------------------*/
  if (fcai.FCAI_Result =  FCAI_RESULT_PROMPTACCT) then,
    do
      say "We need to use an acct."
      ftpapi_verb = "scmd"
      ftp_rc = FtpApi("fcai.", ftpapi_verb, PASS_ACCT, "W")
      if (ftp_rc < 0) then,
        do
          call ftp_error "fcai."
          return ftp_rc
        end
    end
  else,
    do
      say "An account is not required."
    end


/*-------------------------------------------------------------------*/
/* Find the largest file in /tmp                                     */
/* Do a DIR of /tmp in non-wait mode, find the largest file in the   */
/*    directory.  The FTP client will return immediately, even if    */
/*    the subcommand has not completed.  The POLL request is then    */
/*    used to determine when the subcommand has completed.           */
/*-------------------------------------------------------------------*/
  ftpapi_verb = "scmd"
  ftp_rc = FtpApi("fcai.", ftpapi_verb, TMP_COMMAND, "N")
  if (ftp_rc < 0) then,
    do
      call ftp_error "fcai."
    end

  say "Before poll starts."
  say "Total number of lines:",
     value(fcaimap."FCAI_NumberLines")
  say "Longest line         :",
     value(fcaimap."FCAI_LongestLine")
  say "Total size of all    :",
     value(fcaimap."FCAI_SizeAll")
  say "Total size of msgs   :",
     value(fcaimap."FCAI_SizeMessages")
  say "Total size of replies:",
     value(fcaimap."FCAI_SizeReplies")
  say "Total size of list   :",
     value(fcaimap."FCAI_SizeList")
  say "Total size of trace   :",
     value(fcaimap."FCAI_SizeTrace")
  call get_fcaimap
  say "Total number of lines:",
     value(fcaimap."FCAI_NumberLines")
  say "Longest line         :",
     value(fcaimap."FCAI_LongestLine")
  say "Total size of all    :",
     value(fcaimap."FCAI_SizeAll")
  say "Total size of msgs   :",
     value(fcaimap."FCAI_SizeMessages")
  say "Total size of replies:",
     value(fcaimap."FCAI_SizeReplies")
  say "Total size of list   :",
     value(fcaimap."FCAI_SizeList")
  say "Total size of trace   :",
     value(fcaimap."FCAI_SizeTrace")

/*-------------------------------------------------------------------*/
/* Poll to see when the DIR is done.                                 */
/*                                                                   */
/* If running under USS/OMVS, make sure that syscalls are not        */
/* enabled prior to making the first CREATE request.  Enabling       */
/* syscalls makes the USS/OMVS environment variables no longer       */
/* available to the REXX program, so the REXX FTP Client API would   */
/* be unable to read the FTP_REXX_TRACE_FILE environment variable    */
/* (if provided) once syscalls are enabled.                          */
/*-------------------------------------------------------------------*/
/*
  call syscalls "ON"                 /* Enable SYSCALLS              */
*/
  say "Polling      " Time()
  ftpapi_verb = "poll"
  say ">>" Time()
  ftp_rc = FtpApi("fcai.", ftpapi_verb,120)
  say "<<" Time()
  if (ftp_rc < 0) then,
    do
      call ftp_error "fcai."
    end
  do while fcai.fcai_result = FCAI_RESULT_INPROGRESS
    say "Polling again" Time()
/*
     address syscall "sleep 20"
*/
  say ">>>>" Time()
    ftp_rc = FtpApi("fcai.", ftpapi_verb, 120)
  say "<<<<" Time()
    if (ftp_rc < 0) then,
      do
        call ftp_error "fcai."
      end
  end

  say "After poll completed."
  say "Total number of lines:",
     value(fcaimap."FCAI_NumberLines")
  say "Longest line         :",
     value(fcaimap."FCAI_LongestLine")
  say "Total size of all    :",
     value(fcaimap."FCAI_SizeAll")
  say "Total size of msgs   :",
     value(fcaimap."FCAI_SizeMessages")
  say "Total size of replies:",
     value(fcaimap."FCAI_SizeReplies")
  say "Total size of list   :",
     value(fcaimap."FCAI_SizeList")
  say "Total size of trace  :",
     value(fcaimap."FCAI_SizeTrace")
  call get_fcaimap
  say "Total number of lines:",
     value(fcaimap."FCAI_NumberLines")
  say "Longest line         :",
     value(fcaimap."FCAI_LongestLine")
  say "Total size of all    :",
     value(fcaimap."FCAI_SizeAll")
  say "Total size of msgs   :",
     value(fcaimap."FCAI_SizeMessages")
  say "Total size of replies:",
     value(fcaimap."FCAI_SizeReplies")
  say "Total size of list   :",
     value(fcaimap."FCAI_SizeList")
  say "Total size of trace  :",
     value(fcaimap."FCAI_SizeTrace")

/*-------------------------------------------------------------------*/
/* find the largest file                                             */
/*    Each line of output of a DIR command appears as:               */
/* drwxrwxrwx cnt userid groupid size date file                      */
/*-------------------------------------------------------------------*/
  largest_file = ""
  largest_file_size = 0
  ftpapi_verb = "getl_find"
  ftp_rc = FtpApi("fcai.", ftpapi_verb, "lines.", "L", "F")
  if (ftp_rc < 0) then,
    do
      call ftp_error "fcai."
    end
/*-------------------------------------------------------------------*/
/* Continue to search until there are no more lines.  When there     */
/* is no matching line, the REXX FTP Client API returns a result     */
/* of FCAI_RESULT_NOMATCH and sets lines.0 to 0.                     */
/*-------------------------------------------------------------------*/
  do until lines.0 = 0
    say lines.1
    parse var lines.1 dirinfo count userid groupid size date file .
    if size > largest_file_size then
      do
        largest_file = lines.1
        largest_file_size = size
      end
    ftpapi_verb = "getl_find"
    ftp_rc = FtpApi("fcai.", ftpapi_verb, "lines.", "L", "N")
    if (ftp_rc < 0) then,
      do
        call ftp_error "fcai."
      end
  end
  if largest_file <> ""  then
    do
      say "Characteristics of the largest file are"
      say "  "largest_file
    end
  else,
    do
      say "No files found"
    end

  return 0

/*-------------------------------------------------------------------*/
/* Get the fcai_map block and variables.                             */
/*-------------------------------------------------------------------*/
get_fcaimap:
  ftp_rc = FtpApi("fcai.", "get_fcai_map", "fcaimap.")
  return 0

/*-------------------------------------------------------------------*/
/* Generic error handling routine for the FTP interface.  This       */
/* should only be called with a valid FCAI.                          */
/*-------------------------------------------------------------------*/
ftp_error: arg stem
  say "FTP Client API Display:" stem
  say "Verb("ftpapi_verb")"
  say "    Result     =" value(stem"FCAI_Result")
  say "    IE         =" value(stem"FCAI_IE")
  say "    CEC        =" value(stem"FCAI_CEC")
  say "    ReplyCode  =" value(stem"FCAI_ReplyCode")
  say "    TraceStatus=" value(stem"FCAI_TraceStatus")
  say "    ReturnCode =" value(stem"FCAI_ReturnCode")
  say "    ReasonCode =" value(stem"FCAI_ReasonCode")
  say "    SCMD       =" value(stem"FCAI_SCMD")

  say "    Status     =" value(stem"FCAI_Status")
  map_it = c2x(value(stem"FCAI_MAP"))
  ftp_rc = FtpApi("fcai.", "get_fcai_map", "fcaimap.")
  if (ftp_rc < 0) then,
    do
      say "get_fcai_map failed" ftp_rc
      return
    end
  do while map_it >< ""
    parse var map_it tmp_it +40 map_it
    say "  Map " tmp_it
  end
  say "   "fcaimap".FCAI_EyeCatcher =",
     value(fcaimap."FCAI_EyeCatcher")
  say "   "fcaimap".FCAI_Size =",
     value(fcaimap."FCAI_Size")
  say "   "fcaimap".FCAI_Version =",
     value(fcaimap."FCAI_Version")
  say "   "fcaimap".FCAI_PollWait =",
     value(fcaimap."FCAI_PollWait")
  say "   "fcaimap".FCAI_ReqTimer =",
     value(fcaimap."FCAI_ReqTimer")
  say "   "fcaimap".FCAI_TraceIt =",
     value(fcaimap."FCAI_TraceIt")
  say "   "fcaimap".FCAI_TraceID =",
     value(fcaimap."FCAI_TraceID")
  say "   "fcaimap".FCAI_TraceCAPI =",
     value(fcaimap."FCAI_TraceCAPI")
  say "   "fcaimap".FCAI_TraceStatus =",
     value(fcaimap."FCAI_TraceStatus")
  say "   "fcaimap".FCAI_TraceSClass =",
     value(fcaimap."FCAI_TraceSClass")
  say "   "fcaimap".FCAI_TraceName =",
     value(fcaimap."FCAI_TraceName")
  say "   "fcaimap".FCAI_Token =",
     value(fcaimap."FCAI_Token")
  say "   "fcaimap".FCAI_RequestID =",
     value(fcaimap."FCAI_RequestID")
  say "   "fcaimap".FCAI_Result =",
     value(fcaimap."FCAI_Result")
  say "   "fcaimap".FCAI_IE =",
     value(fcaimap."FCAI_IE")
  say "   "fcaimap".FCAI_CEC =",
     value(fcaimap."FCAI_CEC")
  say "   "fcaimap".FCAI_ReplyCode =",
     value(fcaimap."FCAI_ReplyCode")
  say "   "fcaimap".FCAI_SCMD =",
     value(fcaimap."FCAI_SCMD")
  say "   "fcaimap".FCAI_ReturnCode =",
     value(fcaimap."FCAI_ReturnCode")
  say "   "fcaimap".FCAI_ReasonCode =",
     value(fcaimap."FCAI_ReasonCode")
  say "   "fcaimap".FCAI_NumberLines =",
     value(fcaimap."FCAI_NumberLines")
  say "   "fcaimap".FCAI_LongestLine =",
     value(fcaimap."FCAI_LongestLine")
  say "   "fcaimap".FCAI_SizeAll =",
     value(fcaimap."FCAI_SizeAll")
  say "   "fcaimap".FCAI_SizeMessages =",
     value(fcaimap."FCAI_SizeMessages")
  say "   "fcaimap".FCAI_SizeReplies =",
     value(fcaimap."FCAI_SizeReplies")
  say "   "fcaimap".FCAI_SizeList =",
     value(fcaimap."FCAI_SizeList")
  say "   "fcaimap".FCAI_SizeTrace =",
     value(fcaimap."FCAI_SizeTrace")
  say "   "fcaimap".FCAI_PID =",
     value(fcaimap."FCAI_PID")
  return

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
 Follow control blocks to find out who we really are
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
rexx_jobspecs:
  /*---------------------------------------------------------------*/
  /* ADDRESSABILITY TO CVT FROM PSA                                */
  /*---------------------------------------------------------------*/
  PTR2PSA = 0
  CVTPTR = STORAGE(D2X(PTR2PSA + 16),4)
  /*---------------------------------------------------------------*/
  /* ADDRESSABILITY TO SMCA, THEN GET SMF SYSTEM ID                */
  /*---------------------------------------------------------------*/
  CVTSMCA = STORAGE(D2X(C2D(CVTPTR)+197),3)
  SMFID = STORAGE(D2X(C2D(CVTSMCA)+16),4)
  /*---------------------------------------------------------------*/
  /* GET JOBNAME, STEP, AND PROCEDURE                              */
  /*---------------------------------------------------------------*/
  PSATOLD  = STORAGE(21C,4)                    /* POINTER TO TCB   */
  PTRTIOT  = STORAGE(D2X(C2D(PSATOLD)+12),4)   /* POINTER TO TIOT  */
  JOBNAME  = STORAGE(D2X(C2D(PTRTIOT)),8)
  STEPNAME = STORAGE(D2X(C2D(PTRTIOT)+8),8)
  PROCNAME = STORAGE(D2X(C2D(PTRTIOT)+16),8)
  Tcbjscbb = Storage(D2x(C2d(Psatold)+181),3)              /* jscb */
  jscbssib = STORAGE(D2X(C2D(tcbjscbb)+316),4)      /* Ptr to SSIB */
  ssibjbid = STORAGE(D2X(C2D(jscbssib)+12),8)    /* job identifier */
  Return JOBNAME SSIBJBID STEPNAME PROCNAME

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
__DATA__
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
./ ADD NAME=REXFTPQU 0666-07213-07213-1943-00001-00001-00000-DIR2UPDT
rexx_REXFTPQU: /* We still need rexx in comment if read from SYSPROC */
/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

 Dataset:  KTOMIAK.REXX(REXFTPQU)
 Author:   KTomiak
 Contact:  "Kenneth Tomiak"<KenTomiak@KTomiak.org>
 Syntax:   REXFTPQU {site} {password}
 Overview: Simply queue up some commands and invoke FTP.
           Use filetype=JES to submit a job and get the output back.

=======================================================================

 History of Modifications
 ------------------------
  When     Who      What you did
  -------- -------- ---------------------------------------------------
  20070506 KTOMIAK  Original code.

=======================================================================

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */

  Parse Arg all_my_arguments
  Numeric Digits 12

rexx_Main_REXFTPQU:
  return_code = rexx_Initialize()
  If (return_code = 0) then,
    Do
      return_code = rexx_Process()
      return_code = rexx_Termination()
    End
  Return 0

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
 In this routine we open any files and initialize any
 constants we might need.
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
rexx_Initialize:
  PARSE VERSION,
    version_rexx_name,
    version_rexx_version,
    version_rexx_date
  PARSE SOURCE,
    source_host_env,
    source_call_type,
    source_uc_exec_name,
    source_hostdd,
    source_hostdsn,
    source_nf_exec_name,
    source_initial_cmd_env,
    source_asid_name,
    source_char8_user_token,
    source_hostother
  Address_Environment = Address()
  job_specs = rexx_jobspecs()
  say ""
  say Copies("=",55)
  say left("=" source_uc_exec_name rexxpgm_version,53) "="
  say left("=" "executing under" source_host_env,53) "="
  say left("=" "as a" source_call_type,53) "="
  say left("=  on" date() "at" time()".",53) "="
  say Copies("=",55)
  say ""
  return_code = 0
  sysvar_sysuid=SYSVAR("SYSUID")
  sysvar_sysenv = SYSVAR("SYSENV")

  If (source_host_env >< "TSO") Then,
    Do
      Say "Wrong host environment" source_host_env
      return_code = 16
    End
  parse var all_my_arguments  ftp_site arguments "(" options ")" .
  "NEWSTACK"
  Return return_code

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
 In this routine we do our processing.
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
rexx_Process:

  queue sysvar_sysuid
  queue arguments
  queue "lcd '"sysvar_sysuid"'"
  queue "QUOTE SITE FILETYPE=JES"
  queue "get CNTL(CANCELME) JOBOUT (REPLACE"
  queue "dir"
  queue "QUOTE SITE FILETYPE=SEQ"
  queue "dir"
  queue "quit"

  quiet = Outtrap("HLP.")
  "ftp" ftp_site
  quiet = Outtrap("OFF")
  ftpin = Queued()

  if (ftpin > 0) then,
    say "If FTP ends prematurely, there are still commands queued:"
  do ix = 1 to ftpin
    parse pull dline
    say dline
  end

  if (hlp.0 > 0) then,
    say "Whatever FTP did, trapped messages are here:"
  do ix = 1 to hlp.0
    say hlp.ix
  end
  say "Check DDNAME(OUTPUT) for FTP messages."
  Return return_code

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
 In this routine we close files and finish up.
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
rexx_Termination:
  "DELSTACK"
  Return return_code

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
 Place any of your subroutines and procedures below this.
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
rexx_jobspecs:
  /*---------------------------------------------------------------*/
  /* ADDRESSABILITY TO CVT FROM PSA                                */
  /*---------------------------------------------------------------*/
  PTR2PSA = 0
  CVTPTR = STORAGE(D2X(PTR2PSA + 16),4)
  /*---------------------------------------------------------------*/
  /* ADDRESSABILITY TO SMCA, THEN GET SMF SYSTEM ID                */
  /*---------------------------------------------------------------*/
  CVTSMCA = STORAGE(D2X(C2D(CVTPTR)+197),3)
  SMFID = STORAGE(D2X(C2D(CVTSMCA)+16),4)
  /*---------------------------------------------------------------*/
  /* GET JOBNAME, STEP, AND PROCEDURE                              */
  /*---------------------------------------------------------------*/
  PSATOLD  = STORAGE(21C,4)                    /* POINTER TO TCB   */
  PTRTIOT  = STORAGE(D2X(C2D(PSATOLD)+12),4)   /* POINTER TO TIOT  */
  JOBNAME  = STORAGE(D2X(C2D(PTRTIOT)),8)
  STEPNAME = STORAGE(D2X(C2D(PTRTIOT)+8),8)
  PROCNAME = STORAGE(D2X(C2D(PTRTIOT)+16),8)
  Tcbjscbb = Storage(D2x(C2d(Psatold)+181),3)              /* jscb */
  jscbssib = STORAGE(D2X(C2D(tcbjscbb)+316),4)      /* Ptr to SSIB */
  ssibjbid = STORAGE(D2X(C2D(jscbssib)+12),8)    /* job identifier */
  Return JOBNAME SSIBJBID STEPNAME PROCNAME

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
 describe your routines here
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
__DATA__
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
./ ADD NAME=REXFTPSK 0666-07214-07214-2037-00001-00001-00000-DIR2UPDT
rexx_REXFTPSK: /* We still need rexx in comment if read from SYSPROC */
/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

 Dataset:  KTOMIAK.REXX(REXFTPSK)
 Author:   KTomiak
 Contact:  "Kenneth Tomiak"<KenTomiak@KTomiak.org>
 Syntax:   REXFTPSK {ftp_site}
 Overview: Use the SOCKET() api to effectively do an FTP.

=======================================================================

 History of Modifications
 ------------------------
  When     Who      What you did
  -------- -------- ---------------------------------------------------
  20070506 KTOMIAK  Original code.

=======================================================================

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */

  Parse Arg all_my_arguments
  Numeric Digits 12

rexx_Main_REXFTPSK:
  return_code = rexx_Initialize()
  If (return_code = 0) then,
    Do
      return_code = rexx_Process()
      return_code = rexx_Termination()
    End
  Return 0

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
 In this routine we open any files and initialize any
 constants we might need.
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
rexx_Initialize:
  PARSE VERSION,
    version_rexx_name,
    version_rexx_version,
    version_rexx_date
  PARSE SOURCE,
    source_host_env,
    source_call_type,
    source_uc_exec_name,
    source_hostdd,
    source_hostdsn,
    source_nf_exec_name,
    source_initial_cmd_env,
    source_asid_name,
    source_char8_user_token,
    source_hostother
  Address_Environment = Address()
  job_specs = rexx_jobspecs()
  say ""
  say Copies("=",55)
  say left("=" source_uc_exec_name rexxpgm_version,53) "="
  say left("=" "executing under" source_host_env,53) "="
  say left("=" "as a" source_call_type,53) "="
  say left("=  on" date() "at" time()".",53) "="
  say Copies("=",55)
  say ""
  return_code = 0
  sysvar_sysuid=SYSVAR("SYSUID")
  sysvar_sysenv = SYSVAR("SYSENV")

  If (source_host_env >< "TSO") Then,
    Do
      Say "Wrong host environment" source_host_env
      return_code = 16
    End
  Return return_code

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
 In this routine we do our processing.
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
rexx_Process:
  parse var all_my_arguments  ftp_site arguments "(" options

/* ------------------------------------------------------------------*/
/* ----------------------- Main Program ---------------------------- */
/* ------------------------------------------------------------------*/
  Call init_rtn                   /* Initialize the variables        */
  Call Initialize_TCPIP_Services
  if (initialized = 1) then,
    do
      Call main_rtn               /* Receive lines and send commands */
    end
  if (initialized = 1) then,
    do
      Call Terminate_TCPIP_Services
    end
  Call shut_rtn                   /* Terminate the program           */
  Return return_code

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
 In this routine we close files and finish up.
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
rexx_Termination:
  Return return_code

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
 Place any of your subroutines and procedures below this.
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
rexx_jobspecs:
  /*---------------------------------------------------------------*/
  /* ADDRESSABILITY TO CVT FROM PSA                                */
  /*---------------------------------------------------------------*/
  PTR2PSA = 0
  CVTPTR = STORAGE(D2X(PTR2PSA + 16),4)
  /*---------------------------------------------------------------*/
  /* ADDRESSABILITY TO SMCA, THEN GET SMF SYSTEM ID                */
  /*---------------------------------------------------------------*/
  CVTSMCA = STORAGE(D2X(C2D(CVTPTR)+197),3)
  SMFID = STORAGE(D2X(C2D(CVTSMCA)+16),4)
  /*---------------------------------------------------------------*/
  /* GET JOBNAME, STEP, AND PROCEDURE                              */
  /*---------------------------------------------------------------*/
  PSATOLD  = STORAGE(21C,4)                    /* POINTER TO TCB   */
  PTRTIOT  = STORAGE(D2X(C2D(PSATOLD)+12),4)   /* POINTER TO TIOT  */
  JOBNAME  = STORAGE(D2X(C2D(PTRTIOT)),8)
  STEPNAME = STORAGE(D2X(C2D(PTRTIOT)+8),8)
  PROCNAME = STORAGE(D2X(C2D(PTRTIOT)+16),8)
  Tcbjscbb = Storage(D2x(C2d(Psatold)+181),3)              /* jscb */
  jscbssib = STORAGE(D2X(C2D(tcbjscbb)+316),4)      /* Ptr to SSIB */
  ssibjbid = STORAGE(D2X(C2D(jscbssib)+12),8)    /* job identifier */
  Return JOBNAME SSIBJBID STEPNAME PROCNAME

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
 describe your routines here
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
/* ------------------------------------------------------------------*/
/* ----------------------- MAIN Routine ---------------------------- */
/* ------------------------------------------------------------------*/
main_rtn:                         /* Start of routine                */
  say uc_exec_name "main_rtn"
  do while translate(Command) >< "QUIT"
    call get_response
    if (ftp_cont = " ") then,
      do
        say uc_exec_name "Enter command:"
        parse pull command
        parse var command command ";" .
        command = strip(command,"B"," ")
        say "Command("command")"
/*      if (command = "LIST *") then trace ?ilrs  */
        sendrc = SendCommand(Socket, Command)
      end
  end
  Return

get_response:
  site_response = read_from_socket(o_d)
  parse var site_response ftp_rc ftp_prot ftp_port ftp_ipaddr ftp_len,
    site_response
  do while site_response >< ""
    parse var site_response one_line (cr_lf) site_response
    say one_line
  end
  if (o_d = c_d) then,
    call analyze_rtn
  Return

/* ------------------------------------------------------------------*/
/* ----------------------- INIT Routine ---------------------------- */
/* ------------------------------------------------------------------*/
init_rtn:                         /* Start of routine                */
  sys_sysenv  = SYSVAR("SYSENV")  /* FORE means I can prompt         */
  sys_sysispf = SYSVAR("SYSISPF") /* ACTIVE means I could do a panel */
  if (pos("trace",options) > 0) then,
    interpret options
  if (ftp_site = "") then,
    do
      say "I require a site name or ip address."
      ftp_site = "localhost"
      say "Defaulting to" ftp_site
    end
  mvs_sysname = MVSVAR("SYSNAME")
  sys_sysuid = SYSVAR("SYSUID")
  if (translate(ftp_site) = mvs_sysname) then,
    do
      say copies("*",79)
      say left("* You really want to ftp to the same system?",77) "*"
      say copies("*",79)
      pull answer
      if (left(answer,1) >< "Y") then exit 0
      ftp_site = "localhost"
    end
  if (translate(ftp_site) = "ZOS1") then ftp_site = "192.168.1.10"
  if (translate(ftp_site) = "ZOS2") then ftp_site = "192.168.2.21"
  if (translate(ftp_site) = "ZVM1") then ftp_site = "192.168.3.32"
  if (translate(ftp_site) = "ZVM2") then ftp_site = "192.168.4.43"
  /*
  "Alloc file(NETRC) dataset(cor.cntl(netrc)) shr reuse"
  */
  allcblk = ddbycblk()
  call de_parse
  find_dd = "NETRC"
  netrc_dd = tiotddnm.find_dd
  if (netrc_dd >< "") then,
    do
      say "NETRC("netrc_dd")"
      netrc_dsns = dd_dsname.netrc_dd.0
      do ds_x = 1 to netrc_dsns
        say "  DSN="dd_dsname.netrc_dd.ds_x
      end
      call read_netrc
    end
  else,
    do
      say "Since NETRC is not allocated to your session,"
      say "I will require a userid and password for" ftp_site"."
      call get_user
      call get_pswd
    end
  find_dd = "SYSFTPD"
  netrc_dd = tiotddnm.find_dd
  if (netrc_dd >< "") then,
    do
      say "I hope your FTP Client overrides are OK for" ftp_site
      say "SYSFTPD("netrc_dd")"
      netrc_dsns = dd_dsname.netrc_dd.0
      do ds_x = 1 to netrc_dsns
        say "  DSN="dd_dsname.netrc_dd.ds_x
      end
    end
/*
  "Alloc file(SYSFTPD) dataset(cor.cntl(ftpclnt)) shr reuse"
  "Alloc file(NETRC) dataset(cor.cntl(netrc)) shr reuse"
*/
  cr_lf  = x2c('0D25')
  rcvdata = ""
  initialized = 0
  port = 21
  return                          /* Return to caller                */

get_user:
  net_user = ""
  do while net_user = ""
    say "Enter userid:"
    parse pull net_user
  end
  return

get_pswd:
  net_pswd = ""
  do while net_pswd = ""
    say "Enter" net_user"'s password:"
    parse pull net_pswd
    parse var net_pswd net_pswd ";" .
  end
  return

read_netrc:
  Address TSO "EXECIO * DISKR NETRC (FINIS stem netpswd.)"
  myrc = rc
  if (myrc >< 0) then,
    do
      say "NETRC is allocated but 'I canna read it captain.'."
      return
    end
  if (netpswd.0 = 0) then,
    do
      say "NETRC is allocated but 'Dr. Spock! Look at this,"
      say "theare argh no records onna it.'"
      return
    end
  good_site = 0
  do net_x = 1 to netpswd.0
    good_site = pos(ftp_site,netpswd.net_x)
    if (good_site > 0) then leave
  end
  if (good_site = 0) then,
    do
      say ftp_site "is not listed in NETRC so,"
      say "I will require a userid and password for" ftp_site"."
    end
  else,
    do
      netpswd.net_x = space(netpswd.net_x)
      parse var netpswd.net_x . "login" net_user "password" net_pswd
      select
        when ((net_user = "") & (net_pswd = "")) then,
          do
            say "Even though" ftp_site "is listed in NETRC,"
            say "I still require a userid and password."
            call get_user
            call get_pswd
          end
        when (net_user = "") then,
          do
            say "Even though" ftp_site "is listed in NETRC,"
            say "I still require a userid."
            call get_user
          end
        when (net_pswd = "") then,
          do
            say "Even though" ftp_site "is listed in NETRC,"
            say "I still require a password."
            call get_pswd
          end
        otherwise
          say "I sure hope" net_user "and" new_pswd "are valid."
      end
    end
  return                          /* Return to caller                */

de_parse:
/* #dds;dd#;ddname;#dsn;dsn#;dsname;...                        */
  allofit = allcblk
  tiotddnm. = ""
  tiotddnm.0 = 0
  parse var allofit nbr_dds ";" allofit
  do dd_x = 1 to nbr_dds
    parse var allofit dd_nbr ";" dd_name ";" nbr_dsns ";" allofit
    tiotddnm.dd_name = dd_x
    dd_dsname.dd_x. = ""
    do ds_x = 1 to nbr_dsns
      parse var allofit ds_nbr ";" ds_name ";" allofit
      dd_dsname.dd_x.ds_x = ds_name
    end
    dd_dsname.dd_x.0 = ds_x - 1
  end
  tiotddnm.0 = dd_x - 1
  return

/* ------------------------------------------------------------------*/

    /*------------------------------------------------------*/
    /*                                                      */
    /* Procedure: Establish_A_Socket                        */
    /* Purpose:   Get the TCP/IP socket primed.             */
    /* Arguments: None                                      */
    /* Returns:   rc                                        */
    /*                                                      */
    /*------------------------------------------------------*/
Initialize_TCPIP_Services:

 /*----------------------------------------------------------------*/
 /* Initialize the Socket                                          */
 /*----------------------------------------------------------------*/
  so_txt = Socket('Initialize', uc_exec_name, 3)
  parse var so_txt s_rc s_subtask s_maxdesc s_servicename
  socket_rc = s_rc
  if s_rc = 0 then,
    Do
      initialized = 1
/*
      Say s_servicename":"s_subtask "initialized" s_maxdesc "sockets"
*/
    End
  else,
    call error 'E', 40, 'Unable to initialize SOCKET' uc_exec_name s_rc

 /*----------------------------------------------------------------*/
 /* Show the version of the sockets                                */
 /*----------------------------------------------------------------*/
  so_txt = Socket('Version')
  parse var so_txt s_rc s_results
  if s_rc = 0 then,
    Do
/*
      Say "'Socket' version="s_results
*/
    End
  else,
    call error 'W', 50, 'Unable to get SOCKET version' s_rc

 /*----------------------------------------------------------------*/
 /* Open a socket                                                  */
 /*----------------------------------------------------------------*/
  so_txt = Socket('Socket', 'AF_INET', 'STREAM', 'TCP')
  parse var so_txt s_rc s_results
  if s_rc >< 0 then,
    do
      call error 'E', 60, 'SOCKET(SOCKET) rc='s_rc
    end
  else,
    Do
/*
      say "Socket(STREAM)="so_txt
*/
      c_d = s_results
      o_d = c_d
    End

 /*----------------------------------------------------------------*/
 /* Turn  on               EBCDIC-Ascii conversion                 */
 /*----------------------------------------------------------------*/
  so_txt = Socket('SetSockOpt',c_d,'SOL_SOCKET','SO_ASCII','On')
  parse var so_txt s_rc s_results
  if s_rc = 0 then,
    Do
      Say "Socket('SetSockOpt',So_ASCII)" so_txt" turned on."
    End
  else,
    call error 'W', 70, 'Unable to set SOCKET So_ASCii' s_rc

 /*----------------------------------------------------------------*/
 /* See if ftp_site is an ipaddres or resolve name                 */
 /*----------------------------------------------------------------*/
  parse var ftp_site d1 '.' d2 '.' d3 '.' d4
  must_be_name = "N"
  if datatype(d1) >< "NUM" then must_be_name = "Y"
  if datatype(d2) >< "NUM" then must_be_name = "Y"
  if datatype(d3) >< "NUM" then must_be_name = "Y"
  if datatype(d4) >< "NUM" then must_be_name = "Y"
  if must_be_name = "Y" then,
    do
      so_txt = Socket('Gethostbyname', ftp_site)
      parse var so_txt s_rc s_results
      if s_rc >< 0 then,
        do
          call error 'I', 80, 'GetHostByName for',
            ftp_site 'failed' s_rc
        end
      else,
        Do
          max_ip_addresses = 0
          Do while s_results >< ""
            max_ip_addresses = max_ip_addresses + 1
            parse var s_results ip_address s_results
            smtp_ipaddr.max_ip_addresses = ip_address
/*
            say max_ip_addresses '=' ip_address
*/
          End
          smtp_ipaddr.0 = max_ip_addresses
/*
          Say ftp_site "resolved into" smtp_ipaddr.0 "address(es)"
*/
        End
    end
  else,
    do
      so_txt = Socket('Gethostbyaddr', ftp_site)
      parse var so_txt s_rc s_results
      if s_rc >< 0 then,
        do
          call error 'I', 90, 'GetHostByaddr for',
            ftp_site 'failed' s_rc
        end
      else,
        Do
/*
          say ftp_site "resolved to" s_results
*/
          ftp_name = s_results    /* not that I use it, just nice */
        end
    end

 /*----------------------------------------------------------------*/
 /* Find domain name                                               */
 /*----------------------------------------------------------------*/
  so_txt = Socket('Getdomainname')
  parse var so_txt s_rc s_results
  if s_rc >< 0 then,
    do
      call error 'W', 105, 'Getdomainname failed' s_rc
    end
  else,
    Do
      domain = s_results
    end

 /*----------------------------------------------------------------*/
 /* Find IP address of client's machine                            */
 /*----------------------------------------------------------------*/
  so_txt = Socket('Gethostid')
  parse var so_txt s_rc s_results
  if s_rc >< 0 then,
    do
      call error 'E', 100, 'GetHostID failed' s_rc
    end
  else,
    Do
      max_ip_addresses = 0
      Do while s_results >< ""
        max_ip_addresses = max_ip_addresses + 1
        parse var s_results ip_address s_results
        client_ipaddr.max_ip_addresses = ip_address
/*
        say max_ip_addresses '=' ip_address
*/
      End
      client_ipaddr.0 = max_ip_addresses
/*
      Say "Client resolved into" client_ipaddr.0 "address(es)"
*/
    End
  clientip = client_ipaddr.1
  so_txt = Socket('Gethostbyaddr', clientip)
  parse var so_txt s_rc s_results
  if s_rc >< 0 then,
    do
      call error 'W', 110, 'GetHostByaddr for' client 'failed' s_rc
    end
  else,
    Do
/*
      say clientip "resolved to" s_results
*/
      client = s_results
    end
 /*----------------------------------------------------------------*/
 /* Connect the socket                                             */
 /*----------------------------------------------------------------*/
  so_txt = Socket('Connect', c_d, 'AF_INET' port ftp_site)
  parse var so_txt s_rc s_results
  if s_rc >< 0 then,
    do
      call error 'W', 120, 'SOCKET(CONNECT) rc='s_rc
    end
  else,
    Do
/*
      say "Connected to" ftp_site s_results
*/
    End


 /*----------------------------------------------------------------*/
 /* Determine   blocking mode                                      */
 /*----------------------------------------------------------------*/
  so_txt = Socket('Fcntl', c_d, 'F_GETFL')
  parse var so_txt s_rc s_results
  if s_rc >< 0 then,
    do
      call error 'W', 140, 'SOCKET(Fcntl) rc='s_rc
    end
  else,
    Do
/*
      say "Running in "s_results "mode"
*/
    End
  Return

connect_new_port:
  parse arg my_port

 /*----------------------------------------------------------------*/
 /* Open a socket                                                  */
 /*----------------------------------------------------------------*/
  so_txt = Socket('Socket', 'AF_INET', 'STREAM', 'TCP')
  parse var so_txt s_rc s_results
  if s_rc >< 0 then,
    do
      call error 'E', 60, 'SOCKET(SOCKET) rc='s_rc
    end
  else,
    Do
/*
      say "Socket(STREAM)="so_txt
*/
      f_d = s_results
    End

 /*----------------------------------------------------------------*/
 /* Turn  on               EBCDIC-Ascii conversion                 */
 /*----------------------------------------------------------------*/
  so_txt = Socket('SetSockOpt',f_d,'SOL_SOCKET','SO_ASCII','On')
  parse var so_txt s_rc s_results
  if s_rc = 0 then,
    Do
      Say "Socket('SetSockOpt',So_ASCII)" so_txt"."
    End
  else,
    call error 'W', 70, 'Unable to set SOCKET So_ASCii' s_rc
 /*----------------------------------------------------------------*/
 /* Connect the socket                                             */
 /*----------------------------------------------------------------*/
  so_txt = Socket('Connect', f_d, 'AF_INET' my_port ftp_site)
  parse var so_txt s_rc s_results
  if s_rc >< 0 then,
    do
      call error 'W', 120, 'SOCKET(CONNECT) rc='s_rc
    end
  else,
    Do
/*
      say "Connected to" ftp_site s_results
*/
    End
  return

  /*------------------------------------------------------*/
  /*                                                      */
  /* Procedure: LineOut                                   */
  /* Purpose:   Output the line using EXECIO.             */
  /* Arguments: ddname                                    */
  /*            TextString                                */
  /* Returns:   rc                                        */
  /*                                                      */
  /*------------------------------------------------------*/
LineOut:
  outddname = arg(1)
  TextString = arg(2)
  push TextString
  "EXECIO 1 DISKW" outddname
  Return

  /*------------------------------------------------------*/
  /*                                                      */
  /* Procedure: Close_Socket                              */
  /* Purpose:   Close the socket                          */
  /* Arguments: Socket - active socket number             */
  /* Returns:   nothing                                   */
  /*                                                      */
  /*------------------------------------------------------*/
Close_socket:
  so_txt = Socket('Shutdown', c_d, 'BOTH')
  parse var so_txt s_rc s_results
  if s_rc <> 0 then,
    do
      call error 'W', 232, 'Shutdown rc='s_rc
    end

  so_txt = Socket('Close', c_d)
  parse var so_txt s_rc s_results
  if s_rc <> 0 then,
    do
      call error 'W', 234, 'Close rc='s_rc
    end

  so_txt = Socket('Close', f_d)
  parse var so_txt s_rc s_results
  if s_rc <> 0 then,
    do
      call error 'W', 234, 'Close rc='s_rc
    end
  Return

  /*------------------------------------------------------*/
  /*                                                      */
  /* Function:  SendCommand                               */
  /* Purpose:   Send a command via the specified socket   */
  /*            and return the full response to caller.   */
  /* Arguments: Socket - active socket number             */
  /*            Command - command string                  */
  /* Returns:   Response from server or empty string if   */
  /*            failed.                                   */
  /*                                                      */
  /*------------------------------------------------------*/
SendCommand:
  Parse Arg Socket, Command

  /* append CRLF to end the command string */
  ftp_cmd = Command || cr_lf

  so_txt = Socket('Write', c_d,ftp_cmd)
  parse var so_txt s_rc s_results
  if s_rc <> 0 then,
    do
      call error 'E', 230, 'SOCKET(WRITE) rc='s_rc
    end
  else,
    Do
      c_data_len = s_results
      if c_data_len < 1 then say "Writing nothing?" c_data_len
    End
  return so_txt

  /*------------------------------------------------------*/
  /*                                                      */
  /* Function:  Read_From_Socket                          */
  /* Purpose:   Retrieve the results of a command or      */
  /*            socket call.                              */
  /* Arguments: Socket - active socket number             */
  /* Returns:   Response from server or empty string if   */
  /*            failed.                                   */
  /*                                                      */
  /*------------------------------------------------------*/
Read_from_socket:
  parse arg my_d
  read_lines = ""
  so_txt = Socket('Recvfrom', my_d)
  parse var so_txt s_rc s_results
  if s_rc >< 0 then,
    do
      call error 'E', 240, 'SOCKET(RecvFrom) rc='s_rc
    end
  Return so_txt

  /*------------------------------------------------------*/
  /* Syntax error routine                                 */
  /*------------------------------------------------------*/
syntax:
  xrc = rc
  signal off syntax
  say "xrc="xrc
  sigl_record = sigl
  MY_DATA=SOURCELINE(SIGL_RECORD)
  say sigl_record my_data
  call error 'E', rc, '==> REXX Error No.' xrc '@ line',
    sigl_record
  signal on syntax
  return

  /*------------------------------------------------------*/
  /* Halt   error routine                                 */
  /*------------------------------------------------------*/
halt:
  call error 'E', 220, '==> REXX Interrupted'
  return

  /*------------------------------------------------------*/
  /* Common error routine                                 */
  /*------------------------------------------------------*/
error:
  type = arg(1)
  retc = arg(2)
  text = arg(3)
  ecretc = right(retc,3,'0')
  ectype = translate(type)
  ecfull = uc_exec_name || ecretc || ectype
  say '===> 'type":" ecfull text
  if type <> 'E' then return
  if (initialized = 0) then,
    do
      so_txt = Socket('SocketSetStatus')
      parse var so_txt s_rc s_severreason
      if (s_rc <> 'Connected') then,
        say 'The status of the socket set is' s_rc s_severreason
    end
  else,
    do
      so_txt = Socket('SocketSetStatus')
      parse var so_txt s_rc s_severreason
      if (s_rc <> 'Connected') then,
        say 'The status of the socket set is' s_rc s_severreason
    end
  so_txt = Socket('Terminate')
  exit retc

 /*-------------------------------------------------------*/
 /* Terminate the socket and exit                         */
 /*-------------------------------------------------------*/
Terminate_TCPIP_Services:
  Call Close_Socket
  so_txt = Socket('Terminate')
  initialize = 0
  Return

shut_rtn:
  say "Done."
  Return

analyze_rtn:       /* Per RFC-959 */
  parse var one_line,
            ftp_resp +3 ftp_cont +1 ftp_text,
            0 ,
            ftprx +1 ftpry +1 ftprz +1 .
  select
    when (ftp_resp = 110) then, /* Restart marker                    */
      do
        ftp_action = "soso"
      end
    when (ftp_resp = 120) then, /* Service ready in nnn minutes      */
      do
        ftp_action = "soso"
      end
    when (ftp_resp = 125) then, /* Data connection already open, xfr */
      do
        ftp_action = "soso"
        o_d = f_d
        call get_response
      end
    when (ftp_resp = 150) then, /* file status okay;about to open    */
      do
        ftp_action = "soso"
      end
    when (ftp_resp = 200) then, /* Command okay                      */
      do
        ftp_action = "okay"
      end
    when (ftp_resp = 202) then, /* Command not implemented, superflu */
      do
        ftp_action = "okay"
      end
    when (ftp_resp = 211) then, /* System status or system help reply*/
      do
        ftp_action = "okay"
      end
    when (ftp_resp = 212) then, /* Directory status                  */
      do
        ftp_action = "okay"
      end
    when (ftp_resp = 213) then, /* File status                       */
      do
        ftp_action = "okay"
      end
    when (ftp_resp = 214) then, /* Help message                      */
      do
        ftp_action = "okay"
      end
    when (ftp_resp = 215) then, /* NAME system type                  */
      do
        ftp_action = "okay"
      end
    when (ftp_resp = 220) then, /* Service ready for new user        */
      do
        ftp_action = "okay"
        if (ftp_cont = " ") then,
          call send_USER
      end
    when (ftp_resp = 221) then, /* Service closing control connection*/
      do
        ftp_action = "okay"
      end
    when (ftp_resp = 225) then, /* Data connection open, no xfr      */
      do
        ftp_action = "okay"
      end
    when (ftp_resp = 226) then, /* Closing data connection, OK       */
      do
        ftp_action = "okay"
      end
    when (ftp_resp = 227) then, /* Entering Passive Mode             */
      do
        parse var ftp_text . "(" i.1 "," i.2 "," i.3 "," i.4,
          "," i.5 "," i.6 ")" .
        n_port =  ((i.5*256)+i.6)
        say "Now I should start using port" n_port"."
        call connect_new_port n_port
        ftp_action = "okay"
      end
    when (ftp_resp = 230) then, /* User logged in, proceed           */
      do
        ftp_action = "okay"
      end
    when (ftp_resp = 250) then, /* Requested file action okay        */
      do
        ftp_action = "okay"
        o_d = c_d
      end
    when (ftp_resp = 257) then, /* "Pathname" created                */
      do
        ftp_action = "okay"
      end
    when (ftp_resp = 331) then, /* User name ok, need password       */
      do
        call send_PASS
        ftp_action = "more"
      end
    when (ftp_resp = 332) then, /* Need account for login            */
      do
        ftp_action = "more"
      end
    when (ftp_resp = 350) then, /* Req file action pending           */
      do
        ftp_action = "more"
      end
    when (ftp_resp = 421) then, /* Service not available, closing    */
      do
        ftp_action = "iffy"
      end
    when (ftp_resp = 425) then, /* Can't open data connection        */
      do
        ftp_action = "iffy"
      end
    when (ftp_resp = 426) then, /* Closing data connection, aborted  */
      do
        ftp_action = "iffy"
      end
    when (ftp_resp = 450) then, /* Req file action not taken, busy   */
      do
        ftp_action = "iffy"
      end
    when (ftp_resp = 451) then, /* Req action aborted, local error   */
      do
        ftp_action = "iffy"
      end
    when (ftp_resp = 452) then, /* Req action not taken, S80A abend  */
      do
        ftp_action = "iffy"
      end
    when (ftp_resp = 500) then, /* Syntax error, command unrecognized*/
      do
        ftp_action = "failed"
      end
    when (ftp_resp = 501) then, /* Syntax error  in parameters or arg*/
      do
        ftp_action = "failed"
      end
    when (ftp_resp = 502) then, /* Command not implemented           */
      do
        ftp_action = "failed"
      end
    when (ftp_resp = 503) then, /* Bad sequence of commands          */
      do
        ftp_action = "failed"
      end
    when (ftp_resp = 504) then, /* Command not implemented for parm  */
      do
        ftp_action = "failed"
      end
    when (ftp_resp = 530) then, /* Lot logged in                     */
      do
        ftp_action = "failed"
      end
    when (ftp_resp = 532) then, /* need account for storing files    */
      do
        ftp_action = "failed"
      end
    when (ftp_resp = 550) then, /* Req action not taken, notfound    */
      do
        ftp_action = "failed"
      end
    when (ftp_resp = 551) then, /* Req action aborted, page type err */
      do
        ftp_action = "failed"
      end
    when (ftp_resp = 552) then, /* Req file action aborted, Sx37     */
      do
        ftp_action = "failed"
      end
    when (ftp_resp = 553) then, /* Req action not taken, not allowed */
      do
        ftp_action = "failed"
      end
    otherwise
      ftp_action = ""
    say uc_exec_name "doesn't know what ("ftprx||ftpry||ftprz") means."
  end
  if (ftp_action >< "") then return
  select
    when (ftprx = 1) then,      /* positive preliminary reply        */
      do
        try_again = "hopefully"
      end
    when (ftprx = 2) then,      /* positive completion reply         */
      do
        try_again = "okay"
      end
    when (ftprx = 3) then,      /* positive intermediate reply       */
      do
        try_again = "more to come."
      end
    when (ftprx = 4) then,      /* transient negative completion     */
      do
        try_again = "try, try, again"
      end
    when (ftprx = 5) then,      /* permanent negative completion     */
      do
        try_again = "not at all"
      end
    otherwise
      try_again = ""
    say uc_exec_name "doesn't know what ("ftprx")"ftpry||ftprz "means."
  end
  if (try_again = "") then return

  select
    when (ftpry = 0) then,      /* syntax                            */
      do
        try_type = "syntax"
      end
    when (ftpry = 1) then,      /* information                       */
      do
        try_type = "info"
      end
    when (ftpry = 2) then,      /* connections                       */
      do
        try_type = "conn"
      end
    when (ftpry = 3) then,      /* authentication and accounting     */
      do
        try_type = "auth"
      end
    when (ftpry = 4) then,      /* reserved                          */
      do
        try_type = "file"
      end
    when (ftpry = 5) then,      /* file system                       */
      do
        try_type = "file"
      end
    otherwise
    say uc_exec_name "doesn't know what "ftprx"("ftpry")"ftprz "means."
  end
  if (try_type = "") then return
  return

/*

EZY2640I Using dd:SYSFTPD=DATA(FTPCLNT) for local site configuration
         n parameters.
EZA1450I IBM FTP CS V1R7
EZA1554I Connecting to:   192.168.2.22 port: 21.
220-FTPD1 IBM FTP CS V1R7 at ZOSJES2, 17:06:25 on 2007-01-19.
220 Connection will close if idle for more than 5 minutes.
EZA1701I >>> USER ktomiak
331 Send password please.
EZA1789I PASSWORD:

EZA1701I >>> PASS
501 password missing from PASS command
EZA1460I Command:
EZA1619I For a list of the available commands, say HELP
EZA1460I Command:

*/
send_USER:
  say uc_exec_name ">> USER" net_user
  Command = "USER" net_user
  sendrc = SendCommand(Socket, Command)
  call get_response
  call analyze_rtn
  return

send_NAME:                 /* I have no idea why I was trying this. */
  say uc_exec_name ">> NAME"
  Command = "NAME"
  sendrc = SendCommand(Socket, Command)
  call get_response
  call analyze_rtn
  return

send_PASS:
  say uc_exec_name ">> PASS"
  Command = "PASS" net_pswd
  sendrc = SendCommand(Socket, Command)
  call get_response
  call analyze_rtn
  return

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
__DATA__
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
./ ADD NAME=REXTIAR  0666-07212-07212-2025-00001-00001-00000-DIR2UPDT
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
/* Show all the SQL Control Area fields.                             */
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
show_sqlca:
  Say TIME() ">>ERROR>>",
      "sqlcode="sqlcode,
      "sqlerrmc="sqlerrmc,
      "sqlerrp="sqlerrp
      Say TIME() ">>ERROR>>",
      "sqlerrd.1="sqlerrd.1,
      "  .2="sqlerrd.2,
      "  .3="sqlerrd.3,
      "  .4="sqlerrd.4,
      "  .5="sqlerrd.5,
      "  .6="sqlerrd.6
  Say TIME() ">>ERROR>>",
      "sqlwarn.0="sqlwarn.0,
      "  .1="sqlwarn.1,
      "  .2="sqlwarn.2,
      "  .3="sqlwarn.3,
      "  .4="sqlwarn.4,
      "  .5="sqlwarn.5,
      "  .6="sqlwarn.6,
      "  .7="sqlwarn.7,
      "  .8="sqlwarn.8,
      "  .9="sqlwarn.9,
      "  .10="sqlwarn.10
  Say TIME() ">>ERROR>>",
      "sqlstate="sqlstate

  SQL_ERRD = ""
  Do I = 1 To 6
    SQL_ERRD = SQL_ERRD||D2C(SQLERRD.I,4)
  End
  SQL_WARN = ""
  Do I = 0 To 10
    SQL_WARN = SQL_WARN||LEFT(SQLWARN.I,1)
  End
  SQLCA = 'SQLCA   '||D2C(136,4)||D2C(SQLCODE,4)||D2C(70,2),
    ||LEFT(SQLERRMC,70)||'DSN     '||,
    SQL_ERRD||SQL_WARN||LEFT(SQLSTATE,5)
/*   If the length is beyond DSNTIAR possible values (72-240), reset */
  If MSG_LEN < 72 | MSG_LEN > 240 Then,
    MSG_LEN = 120  /* Outside scope */
  If MSG_LEN = "MSG_LEN" Then,
    MSG_LEN = 120  /* Default msg length 120 */
  DB2_ERR_MSG = D2C(MSG_LEN * 12,2) || COPIES(' ',MSG_LEN * 12)
  DB2_ERR_LEN = D2C(MSG_LEN,4)
                     /* Execute DSNTIAR program with SQLCA/Parm data */
  Address LINKPGM "DSNTIAR SQLCA DB2_ERR_MSG DB2_ERR_LEN"
  If RC < 5 Then,
    Do
      If RC = 4 Then Say "DSNTIAR RC=4 Message Area Truncated"
      S_POS = 3           /* Bypass the length bytes in Message Area */
      Do I = 1 to 12            /* Loop through all lines of message */
        MSG_TEXT = Substr(DB2_ERR_MSG,S_POS,MSG_LEN) /* Pick out text */
        MSG_TEXT = Strip(MSG_TEXT,T," ")   /* Remove trailing blanks */
        If MSG_TEXT > " " Then Say MSG_TEXT  /* Echo msg to terminal */
        Else            Iterate    /* Some msg lines are blank, skip */
        S_POS = S_POS + MSG_LEN   /* Skip to next "line" of MSG data */
     End I
    End
  Else,
    Do   /* If DSNTIAR fails for any reason, print SQLCA info anyway */
      Say "Call to DSNTIAR - Failed. RC=" RC
      Say 'SQLCODE ='SQLCODE; Say 'SQLERRM ='SQLERRMC
      Say 'SQLERRP ='SQLERRP; Say 'SQLSTATE='SQLSTATE
      XX = "SQLERRD ="
      Do I = 1 to 6 ; XX = XX||SQLERRD.I||',';End;Say XX
      XX = "SQLWARN ="
      Do I = 0 to 10; XX = XX||SQLWARN.I||',';End;Say XX
    End
  Return
./ ADD NAME=REXUPDTE 0666-07213-07213-1937-00001-00001-00000-DIR2UPDT
rexx_REXUPDTE: /* We still need rexx in comment if read from SYSPROC */
  rexxpgm_version = "01.01"
/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

 Dataset:  REXX(REXUPDTE)
 Author:   "Kenneth Tomiak"<CBT_Ken@KTomiak.org>
 Syntax:   REXUPDTE {}
 Overview: Read an IEBUPDTE stream and update a PDS.
           Look for ISPF statistics in either of these formats:

./ ADD NAME=INITISYS 0101-06333-06333-1235-00358-00359-00000-SOMEUID
./N3 ADD NAME=BIORYTHM 33 2002/08/15 08:34
./N0020 ADD NAME=ALCSEQ       0 2000/11/01 13:39 01.00 OTHERID

=======================================================================

 History of Modifications
 ------------------------
  When     Who      What you did
  -------- -------- ---------------------------------------------------
  20070729 KTomiak  01.01 Standardizing Rexx_Initialize routine
  20070621 KTomiak  01.00 Original code.

=======================================================================

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */

  Parse Arg all_my_arguments
  Numeric Digits 12

rexx_Main_REXUPDTE:
  return_code = rexx_Initialize()
  If (return_code = 0) then,
    Do
      return_code = rexx_Process()
    End
  return_code = rexx_Termination()
  Return 0

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
 In this routine we open any files and initialize any
 constants we might need.
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
rexx_Initialize:
  PARSE VERSION,
    version_rexx_name,
    version_rexx_version,
    version_rexx_date
  PARSE SOURCE,
    source_host_env,
    source_call_type,
    source_uc_exec_name,
    source_hostdd,
    source_hostdsn,
    source_nf_exec_name,
    source_initial_cmd_env,
    source_asid_name,
    source_char8_user_token,
    source_hostother
  Address_Environment = Address()
  job_specs = rexx_jobspecs()
  say ""
  say Copies("=",55)
  say left("=" source_uc_exec_name rexxpgm_version,53) "="
  say left("=" "executing under" source_host_env,53) "="
  say left("=" "as a" source_call_type,53) "="
  say left("=  on" date() "at" time()".",53) "="
  say Copies("=",55)
  say ""
  return_code = 16

  sysvar_sysuid = SYSVAR("SYSUID")
  sysvar_sysenv = SYSVAR("SYSENV")
  If (source_host_env >< "TSO") Then,        /* ARE WE UNDER TSO?    */
    Do                                       /* NOT UNDER TSO        */
      Say "Wrong host environment" source_host_env
      Return return_code
    End

  allcblk = ddbycblk()
  call parse_allcblk

  If (SYSVAR("SYSISPF") >< "ACTIVE") Then,   /* IS ISPF ACTIVE?      */
    Do                                       /* ISPF IS NOT ACTIVE   */
      Say "Check that the ISPF required DD statements are",
        "allocated."
      Return return_code
    End
  Address ISPEXEC 'CONTROL ERRORS RETURN'
  return_code = RC
  If (return_code >< 0) Then,
    Do
      Say "ISPF environment is not established."
      Return return_code
    End

  SYSIN = "SYSIN"
  read_rc = read_any_ddname("SYSIN")
  if (read_rc >< 0) then,
    do
      say "Read error on" SYSIN", RC("read_rc")"
      Return return_code
    end
  if (SYSIN_record.0 = 0) then,
    do
      say "Nothing to do!"
      Return return_code
    end
  Else,
    Do
      found_dsns = dd_dsname.found_dd.0
      Say "SYSIN allocated to:"
      Do ox = 1 to dd_dsname.found_dd.0
        say "  DSN:"dd_dsname.found_dd.ox
      End
    End

  my_ddname = "SYSUT2"
  found_dd = tiotddnm.my_ddname
  If (found_dd = "") Then,
    Do
      Say "Missing DD("my_ddname"), can not continue."
      return_code = 16
      return return_code
    End
  Else,
    Do
      Say "SYSUT2 allocated to:"
      found_dsns = dd_dsname.found_dd.0
      Do ox = 1 to dd_dsname.found_dd.0
        say "  DSN:"dd_dsname.found_dd.ox
      End
    End
  Address IspExec,
    "Lminit DATAID(DATAID2) DDNAME("my_ddname")",
    "ENQ(SHR)",
    "ORG(dsorg)"
  return_code = RC
  If (return_code >< 0) Then,
    Do
      Say "LMINIT failed for" my_ddname", RC("return_code")."
      Return return_code
    End
  If (dsorg >< "PO") Then,
    Do
      Say my_ddname "must be DSORG(PO), DSORG("dsorg") is no good."
      Return return_code
    End

  return_code = 0
  Return return_code

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
 In this routine we do our processing.
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
rexx_Process:
  endup_found = 0
  member_open = 0
  do dx = 1 to SYSIN_record.0
    Select
      When (left(SYSIN_record.dx,2) = "./") Then,
        Do
          Call parse_control_card
        End
      Otherwise
        outrec = Left(SYSIN_record.dx,lrecl)
        Address IspExec,
          "Lmput DATAID("DATAID2") MODE(INVAR)",
          "DATALOC(outrec) DATALEN("lrecl")"
        return_code = RC
        If (return_code >< 0) Then,
          Do
            Say "LMPUT failed for" member_name", RC("return_code")."
            Say "Bailing out at record("dx")."
            dx = SYSIN_record.0
          End
    End
  End
  Return return_code

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
 In this routine we close files and finish up.
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
rexx_Termination:
  If (member_open = 1) Then,
    Do
      Call close_member
    End
  If (endup_found = 0) Then,
    Do
      Say "Poorly coded IEBUPDTE stream, ./ ENDUP is missing."
    End
  Address IspExec,
    "Lmclose DATAID("DATAID2")"
  say ""
  say Copies("=",55)
  say left("= DONE.",53) "="
  say Copies("=",55)
  say ""
  Return return_code

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
 Place any of your subroutines and procedures below this.
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
rexx_jobspecs:
  /*---------------------------------------------------------------*/
  /* ADDRESSABILITY TO CVT FROM PSA                                */
  /*---------------------------------------------------------------*/
  PTR2PSA = 0
  CVTPTR = STORAGE(D2X(PTR2PSA + 16),4)
  /*---------------------------------------------------------------*/
  /* ADDRESSABILITY TO SMCA, THEN GET SMF SYSTEM ID                */
  /*---------------------------------------------------------------*/
  CVTSMCA = STORAGE(D2X(C2D(CVTPTR)+197),3)
  SMFID = STORAGE(D2X(C2D(CVTSMCA)+16),4)
  /*---------------------------------------------------------------*/
  /* GET JOBNAME, STEP, AND PROCEDURE                              */
  /*---------------------------------------------------------------*/
  PSATOLD  = STORAGE(21C,4)                    /* POINTER TO TCB   */
  PTRTIOT  = STORAGE(D2X(C2D(PSATOLD)+12),4)   /* POINTER TO TIOT  */
  JOBNAME  = STORAGE(D2X(C2D(PTRTIOT)),8)
  STEPNAME = STORAGE(D2X(C2D(PTRTIOT)+8),8)
  PROCNAME = STORAGE(D2X(C2D(PTRTIOT)+16),8)
  Tcbjscbb = Storage(D2x(C2d(Psatold)+181),3)              /* jscb */
  jscbssib = STORAGE(D2X(C2D(tcbjscbb)+316),4)      /* Ptr to SSIB */
  ssibjbid = STORAGE(D2X(C2D(jscbssib)+12),8)    /* job identifier */
  Return JOBNAME SSIBJBID STEPNAME PROCNAME

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
 Make sure the DD is allocated, then read everything
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
read_any_ddname:
  parse UPPER arg my_ddname
  found_dd = tiotddnm.my_ddname
  if (found_dd = "") then,
    do
      Say "Missing DD("my_ddname"), can not continue."
      return_code = 16
      return return_code
    end
  else,
    do
      found_dsns = dd_dsname.found_dd.0
    end
  trap_msg = OutTrap("io_msgs.")
  quietly = Msg("OFF")
  Address MVS "EXECIO",
    "* DISKR" my_ddname "0 (FINIS STEM" my_ddname"_record.)"
  read_rc = rc
  trap_msg = OutTrap("OFF")
  noisily = Msg("ON")
  if (read_rc >< 0) then,
    do
      return read_rc
    end
  return 0

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
 parse the stream of ddname information
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
/* #dds;dd#;ddname;#dsn;dsn#;dsname;...                              */
parse_allcblk:
  allofit = allcblk
  tiotddnm. = ""
  tiotddnm.0 = 0
  parse var allofit nbr_dds ";" allofit
  do dd_x = 1 to nbr_dds
    parse var allofit dd_nbr ";" dd_name ";" nbr_dsns ";" allofit
    tiotddnm.dd_name = dd_x
    dd_dsname.dd_x. = ""
    do ds_x = 1 to nbr_dsns
      parse var allofit ds_nbr ";" ds_name ";" allofit
      dd_dsname.dd_x.ds_x = ds_name
    end
    dd_dsname.dd_x.0 = ds_x - 1
  end
  tiotddnm.0 = dd_x - 1
  return

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
 Parse the control card and any ISPF statistics.
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
parse_control_card:
  If (member_open = 1) Then,
    Do
      Call close_member
    End
  Parse Var SYSIN_record.dx,
    dot_slash " ",
    verb      " ",
    operands  " ",
    stats
  ispf_stats = 0
  Select
    When (verb = "ENDUP") Then,
      Do
        Call close_member
        endup_found = 1
      End
    When (verb = "ALIAS") Then,
      Do
        Say "No support for ALIAS entries at this time."
      End
    When (verb = "CHANGE") Then,
      Do
        Say "No support for CHANGE control cards, use IEBUPDTE."
      End
    Otherwise
      Call parse_operands
      Call parse_stats
      Call open_member
  End
  Return

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
 Parse operands to get just the member name.
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
parse_operands:
  Parse Var operands,
    . "NAME=" member_name "," .
  member_name = space(member_name)
  Return

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
 Parse stats and figure out if there are any, and if so, which.
./ ADD NAME=INITISYS 0101-06333-06333-1235-00358-00359-00000-SOMEUID
./N3 ADD NAME=BIORYTHM 33 2002/08/15 08:34
./N0020 ADD NAME=ALCSEQ       0 2000/11/01 13:39 01.00 OTHERID
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
parse_stats:
  stats = Space(stats)
  If (Length(stats) < 8) Then,
    Do
      Say "No statistics" member_name
      Return
    End
  Select
    When (Pos("-",stats) > 0) Then,
      Do
        ispf_stats = 1
        Parse Var stats,
          vv_mm,
          cre_jdate,
          mod_jdate,
          mod_time,
          initl,
          curl,
          modl,
          z4muser,
          .
        Parse Var vv_mm zlvers +2 zlmod +2 .
        Parse Var modtime mbr_hr +2 mbr_mn +2 .
        zm4time = mbr_hr":"mbr_mn
      End
    When (Pos("/",stats) > 0) Then,
      Do
        ispf_stats = 2
        Parse Var stats,
          initl,
          z4mdate,
          z4mtime,
          vv_dot_mm,
          z4muser,
          .
        Parse Var vv_dot_mm zlvers +2 . +1 zlmod .
        If (DataType(zlvers) >< "NUM") Then,
          Do
            zlvers = "01"
            zlmod  = "00"
            z4muser = Left(source_uc_exec_name,7)
          End
        If (DataType(zlmod) >< "NUM") Then,
          Do
            zlmod  = "00"
          End
        If (z4muser = "") Then,
          Do
            z4muser = Left(source_uc_exec_name,7)
          End
        z4cdate = z4mdate
        curl = initl
        modl = 0
        initl = 1
      End
    Otherwise
      Say "Unknown format, ignoring ("Length(stats)")=",
        "="stats"=."
  END
  Return

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
 Open the member.
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
open_member:
  Address IspExec,
    "Lmopen DATAID("DATAID2") OPTION(OUTPUT)",
    "RECFM(recfm) LRECL(lrecl)"
  return_code = RC
  If (return_code >< 0) Then,
    Do
      Say "LMOPEN failed for" my_ddname", RC("return_code")."
      Return return_code
    End
  member_open = 1
  Return

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
 Close the member and update the ISPF statistics.
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
close_member:
  Address IspExec,
    "LMMADD DATAID("DATAID2") MEMBER("member_name")"
  member_open = 0
  Address IspExec,
    "Lmclose DATAID("DATAID2")"
  return_code = RC
  If (return_code >< 0) Then,
    Do
      Say "LMCLOSE failed for" my_ddname", RC("return_code")."
      Return return_code
    End
  If (ispf_stats > 0) Then,
    Do
      Call update_ispf_stats
    End
  Return

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
 Set the statistics per the control card.
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
update_ispf_stats:
  Address IspExec,
    "LMMSTATS DATAID("DATAID2") MEMBER("member_name")",
    "VERSION("zlvers")",
    "MODLEVEL("zlmod")",
    "INITSIZE("initl")",
    "CURSIZE("curl")",
    "MODRECS("modl")",
    "CREATED4("z4cdate")",
    "MODDATE4("Z4MDATE")",
    "MODTIME("Z4MTIME")",
    "USER("z4muser")",
    ""
  return_code = RC
  If (return_code >< 0) Then,
    Do
      Say "Could not set statistics, RC("return_code")."
      Say "MEMBER("member_name")",
        "VERSION("zlvers") MODLEVEL("zlmod")",
        "INITSIZE("initl") CURSIZE("curl") MODRECS("modl")",
        "CREATED4("z4cdate")",
        "MODDATE4("Z4MDATE") MODTIME("Z4MTIME")",
        "USER("z4muser")"
    End
  ispf_stats = 0
  Return

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
__DATA__
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
./ ADD NAME=REXXUSS  0666-07194-07194-2148-00001-00001-00000-DIR2UPDT
rexx_rexxuss: /* rexx */
  on_off = syscalls("ON")
  if (on_off > 4) then,
    Do
      say 'SYSCALLs(ON) failure. Please correct and resubmit.',
        "RC("on_off")."
      exit 16
    End
  $root = '/tmp'
  address syscall 'getuid'
  myuid=retval
  say sysvar('SYSUID') "is uid("myuid")"
  address syscall 'geteuid'
  myeuid=retval
  say sysvar('SYSUID') "is euid("myeuid")"
  say "Try to be superuser!"
  If (myeuid >< 0) then,             /* be 0 since invoker should    */
    Do                               /* be part of the BPX.SUPERUSER */
      address syscall 'seteuid 0'    /* facility class               */
      anddidit = retval
      say "su return value("anddidit")"
      address syscall 'seteuid' myuid   /* back to who I am, really  */
      anddidit = retval
      say "ru return value("anddidit")"
    End

  address syscall 'readdir' $root 'mylist. fstats.'
  fd=retval
  if (fd=-1)   then,
    do
      say 'readdir failed, error codes' errno errnojr
    end
  else,
    do
      say "readdir retval("fd"), codes" errno errnojr
    end
  signal off NOVALUE
  say "MYLIST("mylist.0") fstats("fstats.1.0")"
  maxstrt = 1
  maxlist = mylist.0
  if maxlist > 4 then,
    do
      maxstrt = 2
      maxlist = 4
    end
  do rx = maxstrt to maxlist
    say mylist.rx
    if (fstats.rx.0 = 32) then,
      call print_fmt_stats
  end
  signal on NOVALUE
  address syscall
  'writefile /tmp/ktomiak_readdir.txt 777 mylist.'
  path = '/tmp/ktomiak_readdir.txt'
  'open  (path)',
       O_rdonly,
       000
  if retval=-1 then,
    do
      say 'rdonly file not opened, error codes' errno errnojr
      signal no_uss
    end
  fd=retval
  'read' fd 'bytes 80'
  if retval=-1 then
    say 'bytes not read, error codes' errno errnojr
  else
    say "Bytes("bytes")"
  do while bytes >< ""
    parse var bytes subbytes '15'x bytes
    say "  "subbytes
  end
  'close' fd
  path='/tmp/ktomiak_my.file'
  'open' path,
         O_rdwr+O_creat+O_trunc,
         660
  if retval=-1 then
    do
      say 'rdwr file not opened, error codes' errno errnojr
      signal no_uss
     end
  fd=retval
  rec='hello world' || esc_n
  'write' fd 'rec' length(rec)
  if retval=-1 then
    say 'record not written, error codes' errno errnojr
  'close' fd
  call syscalls 'OFF'

  address TSO

  "alloc file(filein)",
    "path('/tmp/ktomiak_readdir.txt')",
    "PATHOPTS(ORDONLY)",
    "PATHMODE(SIRUSR,SIWUSR,SIRGRP,SIWGRP)"
  "execio * diskr filein (finis stem hfsline."
  if (hfsline.0 > 5) then,
    hfsmax = 5
  else
    hfsmax = hfsline.0
  if (hfsline.0 > 0) then,
  do ix = 1 to hfsmax
    say left(hfsline.ix,79)
  end
  "alloc file(fileot)",
    "path('/tmp/ktomiak_readdir.copy')",
    "PATHOPTS(OWRONLY,OCREAT,OTRUNC)",
    "PATHMODE(SIRUSR,SIWUSR,SIRGRP,SIWGRP)"
  "execio * diskw fileot (finis stem hfsline."
  "free file(filein)"
  "free file(fileot)"
  exit
no_uss:
  say "Either there is no USS for you or some other error went down."
  exit 4
print_fmt_stats:
  say "     1=Type     ("fstats.rx.st_type")"
  say "     2=MODE     ("fstats.rx.st_mode")"
  say "     3=INO      ('"c2x(fstats.rx.st_ino)"')"
  say "     4=DEV      ('"c2x(fstats.rx.st_dev)"')"
  say "     5=NLINK    ("fstats.rx.st_nlink")"
  if (rx = 3) then,
    do
      say "     6=UID      ("fstats.rx.st_uid")"
      say "     7=GID      ("fstats.rx.st_gid")"
      say "     8=SIZE     ("fstats.rx.st_size")"
      say "     9=ATIME    ("fstats.rx.st_atime")"
      say "    10=MTIME    ("fstats.rx.st_mtime")"
      say "    11=CTIME    ("fstats.rx.st_ctime")"
      say "    12=SETUID   ("fstats.rx.st_setuid")"
      say "    13=SETGID   ("fstats.rx.st_setgid")"
      say "    14=MAJOR    ("fstats.rx.st_major")"
      say "    15=MINOR    ("fstats.rx.st_minor")"
      say "    16=AAUDIT   ("fstats.rx.st_aaudit")"
      say "    17=UAUDIT   ("fstats.rx.st_uaudit")"
      say "    18=BLKSIZE  ("fstats.rx.st_blksize")"
      say "    19=CRTIME   ("fstats.rx.st_crtime")"
      say "    20=AUDITID  ("fstats.rx.st_auditid")"
      say "    21=CCSID    ("fstats.rx.st_ccsid")"
      say "    22=BLOCKS   ("fstats.rx.st_blocks")"
      say "    23=STICKY   ("fstats.rx.st_sticky")"
      say "    24=EXTLINK  ("fstats.rx.st_extlink")"
      say "    25=GENVALUE ("c2d(fstats.rx.st_genvalue)")"
      say "    26=RTIME    ("fstats.rx.st_rtime")"
      say "    27=FID      ("c2d(fstats.rx.st_fid)")"
      say "    28=FILEFMT  ("fstats.rx.st_filefmt")"
      say "    29=ACCESSACL("fstats.rx.st_accessacl")"
      say "    30=FMODELACL("fstats.rx.st_fmodelacl")"
      say "    31=DMODELACL("fstats.rx.st_dmodelacl")"
      say "    32=?????????("fstats.rx.32")"
    end
  return
./ ADD NAME=SDSFDISK 0666-07213-07213-1938-00001-00001-00000-DIR2UPDT
rexx_SDSFDISK: /* We still need rexx in comment if read from SYSPROC */
  rexxpgm_version = "01.01"
/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

 Dataset:  KET2812.COR.REXX(SDSFDISK)
 Author:   KTomiak
 Contact:  "Kenneth Tomiak"<KenTomiak@KTomiak.org>
 Syntax:   SDSFDISK {dsn_hlq jobname jobnumber}
 Overview: (tell us about the code)

=======================================================================

 History of Modifications
 ------------------------
  When     Who      What you did
  -------- -------- ---------------------------------------------------
  20070729 KTomiak  01.01 Standardizing Rexx_Initialize routine
  20050202 KTomiak  01.00 Original code.

=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */

  Parse Arg all_my_arguments
  Numeric Digits 12

rexx_Main_SDSFDISK:
  return_code = rexx_Initialize()
  If (return_code = 0) then,
    Do
      return_code = rexx_Process()
    End
  return_code = rexx_Termination()
  Return 0

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
 In this routine we open any files and initialize any
 constants we might need.
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
rexx_Initialize:
  PARSE VERSION,
    version_rexx_name,
    version_rexx_version,
    version_rexx_date
  PARSE SOURCE,
    source_host_env,
    source_call_type,
    source_uc_exec_name,
    source_hostdd,
    source_hostdsn,
    source_nf_exec_name,
    source_initial_cmd_env,
    source_asid_name,
    source_char8_user_token,
    source_hostother
  Address_Environment = Address()
  job_specs = rexx_jobspecs()
  say ""
  say Copies("=",55)
  say left("=" source_uc_exec_name rexxpgm_version,53) "="
  say left("=" "executing under" source_host_env,53) "="
  say left("=" "as a" source_call_type,53) "="
  say left("=  on" date() "at" time()".",53) "="
  say Copies("=",55)
  say ""
  return_code = 0
  sysvar_sysuid = SYSVAR("SYSUID")
  sysvar_sysenv = SYSVAR("SYSENV")
  If (source_host_env >< "TSO") Then,
    Do
      Say "Wrong host environment" source_host_env
      return_code = 16
    End
  parse var all_my_arguments,
    dsn_hlq jobname jobnumber otherjunk
  if (jobnumber = "") then,
    do
      say ""
      say "Syntax:"
      say "tso %"source_uc_exec_name "hlq jobname jobnumber"
      say ""
      jobnumber = jobname
      jobname = dsn_hlq
      dsn_hlq = Sysvar("SYSUID")
    end
  no_msg = Outtrap("NOMSGS.")
  "FREE FILE(ISFIN)"
  "DELETE SDSF.ISFIN"
  "ALLOC FILE(ISFIN) DATASET(SDSF.ISFIN)",
    "NEW CATALOG UNIT(SYSALLDA)",
    "RECFM(F B) BLKSIZE(0) LRECL(80)",
    "TRACKS SPACE(1 1)"
  musthave = rc
  if (musthave <> 0) then,
    do
  say "dsn_hlq("dsn_hlq") Jobname("jobname") jobnumber("jobnumber")"
        say "Shucks, alloc ISFIN failed, rc("musthave")"
      return 12
    end
  "FREE FILE(ISFOUT)"
  "DELETE SDSF.ISFOUT"
  "ALLOC FILE(ISFOUT) DATASET(SDSF.ISFOUT)",
    "NEW CATALOG UNIT(SYSALLDA)",
    "RECFM(V B A) BLKSIZE(0) LRECL(255)",
    "TRACKS SPACE(1 1)"
  musthave = rc
  if (musthave <> 0) then,
    do
  say "dsn_hlq("dsn_hlq") Jobname("jobname") jobnumber("jobnumber")"
      say "Shucks, ISFOUT alloc failed, rc("musthave")"
      return 12
    end
  "FREE FILE(DDOUT)"
  jobout = "'"dsn_hlq".$JOBOUT."jobname"."jobnumber"'"
   "DELETE" jobout
  "ALLOC FILE(DDOUT) DATASET("JOBOUT")",
    "NEW CATALOG UNIT(SYSALLDA)",
    "RECFM(V B A) BLKSIZE(27998) LRECL(255)",
    "TRACKS SPACE(45 45)"
  musthave = rc
  if (musthave <> 0) then,
    do
  say "dsn_hlq("dsn_hlq") Jobname("jobname") jobnumber("jobnumber")"
      say "Shucks, DDOUT  alloc failed, rc("musthave")"
      return 12
    end
  Return return_code

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
 In this routine we do our processing.
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
rexx_Process:
  no_msg = Outtrap("OFF")
  Queue 'PRE' jobname
  Queue 'OWNER *'
  Queue 'ST'
  Queue 'S' jobname jobnumber
  Queue 'F' jobname
  Queue '++S'
  Queue 'PRINT FILE DDOUT'
  Queue 'PRINT'
  Queue 'PRINT CLOSE'
  Queue 'END'
  nq = Queued()
  "EXECIO" nq "DISKW ISFIN (FINIS"
      problems = 0
/*"CALL 'SYS1.ISF.SISFLOAD(SDSF)' ''" */
  address AttchPgm "SDSF"
  view_rc = rc
  if (view_rc >< 0) then,
    do
      say "Shucks, AttachPgm SDSF failed, rc("view_rc")"
      problems = 1
    end
  Return return_code

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
 In this routine we close files and finish up.
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
rexx_Termination:
  no_msg = Outtrap("NOMSGS.")
  "FREE FILE(ISFIN)"
  "DELETE SDSF.ISFIN"
  "EXECIO * DISKR ISFOUT (FINIS Stem fromsdsf."
  "FREE FILE(ISFOUT)"
  "FREE FILE(DDOUT)"
  if (sysvar_sysenv = "FORE") then,
    do
      address ispexec "Control Errors Return"
      if (problems = 1) then,
        address ispexec "View Dataset(sdsf.isfout)"
      address ispexec "View Dataset("jobout")"
      view_rc = rc
      if (view_rc >< 0) then,
        do
          say "Shucks, View failed, rc("view_rc")"
          exit 12
        end
    end
  "DELETE SDSF.ISFOUT"
  no_msg = Outtrap("OFF")
  Return return_code

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
 Place any of your subroutines and procedures below this.
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
rexx_jobspecs:
  /*---------------------------------------------------------------*/
  /* ADDRESSABILITY TO CVT FROM PSA                                */
  /*---------------------------------------------------------------*/
  PTR2PSA = 0
  CVTPTR = STORAGE(D2X(PTR2PSA + 16),4)
  /*---------------------------------------------------------------*/
  /* ADDRESSABILITY TO SMCA, THEN GET SMF SYSTEM ID                */
  /*---------------------------------------------------------------*/
  CVTSMCA = STORAGE(D2X(C2D(CVTPTR)+197),3)
  SMFID = STORAGE(D2X(C2D(CVTSMCA)+16),4)
  /*---------------------------------------------------------------*/
  /* GET JOBNAME, STEP, AND PROCEDURE                              */
  /*---------------------------------------------------------------*/
  PSATOLD  = STORAGE(21C,4)                    /* POINTER TO TCB   */
  PTRTIOT  = STORAGE(D2X(C2D(PSATOLD)+12),4)   /* POINTER TO TIOT  */
  JOBNAME  = STORAGE(D2X(C2D(PTRTIOT)),8)
  STEPNAME = STORAGE(D2X(C2D(PTRTIOT)+8),8)
  PROCNAME = STORAGE(D2X(C2D(PTRTIOT)+16),8)
  Tcbjscbb = Storage(D2x(C2d(Psatold)+181),3)              /* jscb */
  jscbssib = STORAGE(D2X(C2D(tcbjscbb)+316),4)      /* Ptr to SSIB */
  ssibjbid = STORAGE(D2X(C2D(jscbssib)+12),8)    /* job identifier */
  Return JOBNAME SSIBJBID STEPNAME PROCNAME

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
 describe your routines here
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
__DATA__
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */

./ ADD NAME=SNIPADDR 0666-07210-07210-0835-00001-00001-00000-DIR2UPDT
  Address_Environment = Address()
  say ""
  say Copies("=",55)
  say left("=" "Environment:" Address_Environment,53) "="
  say Copies("=",55)
  say ""
./ ADD NAME=SNIPSRCE 0666-07210-07210-0826-00001-00001-00000-DIR2UPDT

show_source_information:
  rexxpgm_version = "01.00"
  Parse SOURCE,
    source_host_env,
    source_call_type,
    source_uc_exec_name,
    source_hostdd,
    source_hostdsn,
    source_nf_exec_name,
    source_initial_cmd_env,
    source_asid_name,
    source_char8_user_token,
    source_hostother
  say left("= Host    :" source_host_env,53) "="
  say left("= Calltype:" source_call_type,53) "="
  say left("= ExecName:" source_uc_exec_name,53) "="
  say left("= HostDD  :" source_hostdd,53) "="
  say left("= HostDSN :" source_hostdsn,53) "="
  say left("= nfExec  :" source_nf_exec_name,53) "="
  say left("= CMD Env :" source_initial_cmd_env,53) "="
  say left("= ASIDname:" source_asid_name,53) "="
  say left("= UsrToken:" source_char8_user_token,53) "="
  say left("= HostOthr:" source_hostother,53) "="
  say ""
  say Copies("=",55)
  say left("=" source_uc_exec_name rexxpgm_version,53) "="
  say left("=" "executing under" source_host_env,53) "="
  say left("=" "as a" source_call_type,53) "="
  say left("=  on" date() "at" time()".",53) "="
  say Copies("=",55)
  say ""
  return
./ ADD NAME=SNIPVRSN 0666-07210-07210-0900-00001-00001-00000-DIR2UPDT
  PARSE VERSION,
    version_rexx_name,
    version_rexx_version,
    version_rexx_date
./ ADD NAME=SORTBYHX 0666-07213-07213-1814-00001-00001-00000-DIR2UPDT
rexx_sortbyhx:                /* rexx */
  Address IsrEdit "MACRO (args)"
  Address IspExec "CONTROL ERRORS RETURN"
  Address IsrEdit "CAPS OFF"
  Address IsrEdit "(mbrname) = MEMBER"
  Address IsrEdit "(dsname,lib,volume) = DATASET"
  sys_sysuid    = SYSVAR("sysuid")               /*  who am i?  */
  arg.0 =  Words(args)
  do wx = 1 to arg.0
    arg.wx = Word(args,wx)
  end
  if (datatype(arg.1) >< "NUM") then begin_col = 1
  else begin_col = arg.1
  if (datatype(arg.2) >< "NUM") then span = 4
  else span = arg.2
  TSO_RC = LISTDSI("'"dsname"'" DIRECTORY SMSINFO)
  If (TSO_RC > 4)  then,        /* RETURN CODES                     */
                                /*  4 - Some info not returned      */
                                /*      Do not use directory info   */
                                /* 16 - Not successful, no data     */
                                /*      is returned.                */
    do
      say "LISTDSI of" dsname "failed, rc="tso_rc
      exit tso_rc
    end
  "ISREDIT (LASTLN) = LINENUM .ZLAST"
  if (lastln > 1) then,
    do
     call mysort
    end
  exit

mysort:
  X=OUTTRAP("ON")
  "FREE FI(SORTIN,SORTOUT,SORTMSG,SYSIN)"
  "FREE DDNAME(SYSIN,SORTIN,SORTOUT,SORTWK01)"
  if (datatype(sysused) >< "NUM") then,
    sysused = sysalloc
  "ALLOC FILE(SORTWK01) UNIT(SYSDA) SPACE("sysused",10) cylinders"
  X=OUTTRAP("OFF")
  recfml = length(sysrecfm)
  myrecfm = ""
  do rx = 1 to recfml
    one = substr(sysrecfm,rx,1)
    myrecfm = myrecfm||one" "
  end
  if (left(myrecfm,1) = "V") then begin_col = begin_col + 4
  if (sysunits = "BLOCK") then sysunits = "TRACK"
  "ALLOC FI(SORTIN) NEW reuse LRECL("syslrecl")",
    sysunits"S space("sysused") recfm("myrecfm")",
    "BLKSIZE(0)"

  cx = 1
  DO WHILE cx <= LASTLN
    "ISREDIT (SORTIN) = LINE "cx
     RCC = RC
     cx = cx + 1
     IF RCC = 0 THEN QUEUE SORTIN
  END

  QUEUE

  "EXECIO * DISKW SORTIN (FINIS"

  DELSTACK

  "ALLOC DD(SYSIN) NEW REUSE",
    "RECFM(F B) BLKSIZE(0) LRECL(80) tracks SPACE(1)"

  QUEUE ' SORT FIELDS=('begin_col','SPAN||,
    ',AC,A),DYNALLOC=(SWORK,3)'
  QUEUE ' END '
  QUEUE
  "EXECIO * DISKW SYSIN (FINIS"

  DELSTACK

  "ALLOC FI(SORTOUT) NEW reuse LRECL("syslrecl")",
    sysunits"S space("sysused") recfm("myrecfm")",
    "BLKSIZE(0)"
  "ALLOC FI(SORTMSG) sysout(1)"
  nomsgs = Outtrap("alcmsgs.")
  "ALLOC FI(SYSOUT) sysout(1)"
  nomsgs = Outtrap("OFF")

  "CALL *(SORT)"
  sort_rc = rc
  if (sort_rc >< 0) then,
    do
      say "GO TELL IT ON THE MOUNTAIN."
  "FREE DDNAME(SYSIN,SORTIN,SORTOUT,SORTWK01,SYSOUT)"
      return
    end

  "ISREDIT DELETE 1 .ZLAST"   /* CLEAN THE EDIT SLATE */
   "EXECIO *  DISKR SORTOUT (STEM SRT. FINIS"

    cx = 1
    DO WHILE cx >< SRT.0 + 1
      SORTOUT = SRT.cx
      Lcx = RIGHT(cx-1,6,0)
     "ISREDIT LINE_AFTER "Lcx" = (SORTOUT)"
      cx = cx + 1
    END

   "FREE DDNAME(SYSIN,SORTIN,SORTOUT,SORTWK01,SYSOUT)"
   X=OUTTRAP(OFF)
   return

./ ADD NAME=TXT2STEM 0666-07194-07194-2148-00001-00001-00000-DIR2UPDT
rexx_txt2stem: /* rexx */
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
/* Routine to parse text delimited by spaces into stem variables     */
/* literals.0 contains the number of variables.                      */
/* Add to your code and then use it:                                 */
/* ok_rc = text2stem("'This is my test.' okay")                      */
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
text2stem:
  procedure expose literals.
  parse arg text

  text = strip(text,"B"," ")
  textlen=length(text)
  fieldstart = 1
  fieldend   = 1
  fieldno = 0
  literals.0 = 0
  literals.  = ""
  string_state = "on"
  apostrophe_state = "off"
  quote_state = "off"
  pb = " "

/*  trace ?ilrs */

  do ts_cx = 1 to textlen
    cb = substr(text,ts_cx,1)
    nx = ts_cx + 1
    nb = substr(text,nx,1)

    Select
/*                                        check blanks           */
      when ((cb = " ") & ,
        (apostrophe_state = "off") &,
        (quote_state = "off") &,
        (string_state = "off")) then,
        do
          NOP
        end
      when ((cb = " ") & ,
        (apostrophe_state = "off") &,
        (quote_state = "off") &,
        (string_state = "on")) then,
        do
          fieldend = ts_cx
          fieldno = fieldno + 1
          literals.0 = fieldno
          fieldlength = fieldend - fieldstart + 1
          some_text = substr(text,fieldstart,fieldlength)
          literals.fieldno = strip(some_text,"T"," ")
          string_state = "off"
        end
      when ((cb = " ") & ,
        ((apostrophe_state = "on") |,
         (quote_state = "on")) &,
        (string_state = "on")) then,
        do
          NOP
        end
/*                                        check apostrophe       */
      when ((cb = "'") & ,
        (apostrophe_state = "off") &,
        (quote_state = "off") &,
        (string_state = "off")) then,
        do
          apostrophe_state = "on"
          string_state = "on"
          fieldstart = ts_cx
        end
      when ((cb = "'") & ,
        (apostrophe_state = "off") &,
        (quote_state = "off") &,
        (string_state = "on")) then,
        do
          apostrophe_state = "on"
        end
      when ((cb = "'") & ,
        (apostrophe_state = "off") &,
        (quote_state = "on") &,
        (string_state = "off")) then,
        do
          NOP
        end
      when ((cb = "'") & ,
        (nb = "'") & ,
        (apostrophe_state = "on") &,
        (quote_state = "off") &,
        (string_state = "on")) then,
        do
          NOP
        end
      when ((cb = "'") & ,
        (pb = "'") & ,
        (apostrophe_state = "on") &,
        (quote_state = "off") &,
        (string_state = "on")) then,
        do
          NOP
        end
      when ((cb = "'") & ,
        (apostrophe_state = "on") &,
        (quote_state = "off") &,
        (string_state = "on")) then,
        do
          apostrophe_state = "off"
        end
/*                                        check quote            */
      when ((cb = '"') & ,
        (apostrophe_state = "off") &,
        (quote_state = "off") &,
        (string_state = "off")) then,
        do
          quote_state = "on"
          string_state = "on"
          fieldstart = ts_cx
        end
      when ((cb = '"') & ,
        (apostrophe_state = "off") &,
        (quote_state = "off") &,
        (string_state = "on")) then,
        do
          quote_state = "on"
        end
      when ((cb = '"') & ,
        (apostrophe_state = "on") &,
        (quote_state = "off") &,
        (string_state = "off")) then,
        do
          NOP
        end
      when ((cb = '"') & ,
        (nb = '"') & ,
        (apostrophe_state = "off") &,
        (quote_state = "on") &,
        (string_state = "on")) then,
        do
          NOP
        end
      when ((cb = '"') & ,
        (pb = '"') & ,
        (apostrophe_state = "off") &,
        (quote_state = "on") &,
        (string_state = "on")) then,
        do
          NOP
        end
      when ((cb = '"') & ,
        (apostrophe_state = "off") &,
        (quote_state = "on") &,
        (string_state = "on")) then,
        do
          quote_state = "off"
        end
/*                                        end of the text        */
      when (ts_cx = textlen) then,
        do
          if (string_state = "on") then,
            do
              fieldend = ts_cx
              fieldno = fieldno + 1
              literals.0 = fieldno
              fieldlength = fieldend - fieldstart + 1
              some_text = substr(text,fieldstart,fieldlength)
              literals.fieldno = some_text
              string_state = "off"
            end
          else
            do
              string_state = "on"
              fieldstart = ts_cx
            end
        end
      when ((cb >< " ") & ,
        (apostrophe_state = "off") &,
        (quote_state = "off") &,
        (string_state = "off")) then,
        do
          string_state = "on"
          fieldstart = ts_cx
        end
      otherwise,
        do
        if ts_cx < 45 then,
          s = ts_cx "PB("pb") CB("cb") NB("nb") S="string_state,
            "Q="quote_state,
            "A="apostrophe_state
          string_state = "on"
        end
    End
    px = ts_cx
    pb = cb
  end
  if (string_state = "on") then,
    do
      fieldend = ts_cx
      fieldno = fieldno + 1
      literals.0 = fieldno
      fieldlength = fieldend - fieldstart + 1
      some_text = substr(text,fieldstart,fieldlength)
      literals.fieldno = some_text
    end

  return literals.0
./ ADD NAME=UPDREFDT 0666-07210-07210-0855-00001-00001-00000-DIR2UPDT
/* REXX                                                               */00010000
/* ****************************************************************** */00020000
/*                                                                    */00030000
/* LIB: REXX(UPDREFDT)                                                */00040000
/* GDE: KENNETH E. TOMIAK                                             */00050000
/* DOC: USE ISPF SERVICES TO GET A LIST OF DATASETS AND READ EACH.    */00060000
/*      Effectively causes the last-reference date to be updated.     */00070000
/*                                                                    */00070000
/* ****************************************************************** */00080000
/*  TRACE Result                                                      */00090000
arg uid                                                                 00100000
if (uid = '') then,                                                     00110000
  do                                                                    00120000
    say 'Must have a userid or can not do a list'                       00130000
    exit 8                                                              00140000
  end                                                                   00150000
say 'Allocating data sets for' uid                                      00160000
/* ****************************************************************** */00170000
/* Setup ISPF services.                                               */00180000
/* ****************************************************************** */00190000
"ISPEXEC CONTROL ERRORS RETURN";                                        00200000
/* ****************************************************************** */00210000
/* Initialize  a data set list.                                       */00220000
/* ****************************************************************** */00230000
"ISPEXEC LMDINIT LISTID(DSNLIST)",                                      00240000
               "LEVEL("uid")"                                           00250000
RCSAVE = RC                                                             00260000
IF (RCSAVE \= 0) THEN                                                   00270000
  do                                                                    00280000
    SAY 'LMDINIT DSNLIST RC=' RCSAVE;                                   00290000
    exit(4)                                                             00300000
  end                                                                   00310000
/* ****************************************************************** */00320000
/* Obtain the dslist list one entry at a time.                        */00330000
/* ****************************************************************** */00340000
DSNID = ' '                                                             00350000
rclist = 0                                                              00360000
say 'Dataset volume dsorg last-ref-date'                                00370000
DO while RCLIST = 0                                                     00380000
  "ISPEXEC LMDLIST LISTID("DSNLIST"),                                   00390000
                   OPTION(LIST),                                        00400000
                   DATASET(DSNID),                                      00410000
                   STATS(YES)"                                          00420000
  RCLIST = RC                                                           00430000
  IF (RCLIST \= 0) THEN                                                 00440000
    do                                                                  00450000
      "ISPEXEC LMDLIST LISTID(&DSNLIST) OPTION(FREE)"                   00460000
    end                                                                 00470000
  else                                                                  00480000
    do                                                                  00490000
      say DSNID zdlvol zdldsorg zdlrdate                                00500000
      if (left(zdlvol,6) = "MIGRAT") then,                              00501001
        do                                                              00502001
          "HRECALL ('"dsnid"') WAIT"                                    00503002
        end                                                             00504001
      SELECT                                                            00510000
        when (zdlvol = "*ALIAS") then,                                  00511003
          do                                                            00512003
            say "We do not migrate ALIASES."                            00513003
          end                                                           00514003
        WHEN ZDLDSORG = 'PO-E' THEN                                     00520004
          DO                                                            00530000
            ADDRESS ISPEXEC,                                            00540000
             "LMINIT DATAID(DATIDVR)",                                  00550000
             "DATASET('"DSNID"') ENQ(SHR)"                              00560000
            RCTEMP = RC                                                 00570000
            IF (RCTEMP \= 0) THEN                                       00580000
              do                                                        00590000
                say 'PO LMINIT failed rc='RCTEMP                        00600003
              end                                                       00610000
            ADDRESS ISPEXEC,                                            00620000
             "LMOPEN DATAID("DATIDVR") OPTION(INPUT)"                   00630000
            RCTEMP = RC                                                 00640000
            IF (RCTEMP \= 0) THEN                                       00650000
              do                                                        00660000
                if (zdlrecfm \= 'U') then,                              00670000
                say 'PO LMOPEN failed rc='RCTEMP                        00680003
              end                                                       00690000
            ADDRESS ISPEXEC,                                            00700000
             "LMCLOSE DATAID("DATIDVR")"                                00710000
            ADDRESS ISPEXEC,                                            00720000
             "LMFREE DATAID(DATIDVR)"                                   00730000
          END                                                           00740000
        WHEN ZDLDSORG = 'PO' THEN                                       00741004
          DO                                                            00742004
            ADDRESS ISPEXEC,                                            00743004
             "LMINIT DATAID(DATIDVR)",                                  00744004
             "DATASET('"DSNID"') ENQ(SHR)"                              00745004
            RCTEMP = RC                                                 00746004
            IF (RCTEMP \= 0) THEN                                       00747004
              do                                                        00748004
                say 'PO LMINIT failed rc='RCTEMP                        00749004
              end                                                       00749104
            ADDRESS ISPEXEC,                                            00749204
             "LMOPEN DATAID("DATIDVR") OPTION(INPUT)"                   00749304
            RCTEMP = RC                                                 00749404
            IF (RCTEMP \= 0) THEN                                       00749504
              do                                                        00749604
                if (zdlrecfm \= 'U') then,                              00749704
                say 'PO LMOPEN failed rc='RCTEMP                        00749804
              end                                                       00749904
            ADDRESS ISPEXEC,                                            00750004
             "LMCLOSE DATAID("DATIDVR")"                                00750104
            ADDRESS ISPEXEC,                                            00750204
             "LMFREE DATAID(DATIDVR)"                                   00750304
          END                                                           00750404
        WHEN ZDLDSORG = 'PS' THEN                                       00751004
          DO                                                            00760000
            ADDRESS ISPEXEC,                                            00770000
             "LMINIT DATAID(DATIDVR)",                                  00780000
             "DATASET('"DSNID"') ENQ(SHR)"                              00790000
            RCTEMP = RC                                                 00800000
            IF (RCTEMP \= 0) THEN                                       00810000
              do                                                        00820000
                say 'PS LMINIT failed rc='RCTEMP                        00830003
              end                                                       00840000
            ADDRESS ISPEXEC,                                            00850000
             "LMOPEN DATAID("DATIDVR") OPTION(INPUT)"                   00860000
            RCTEMP = RC                                                 00870000
            IF (RCTEMP \= 0) THEN                                       00880000
              do                                                        00890000
                if (zdllrecl < 255) then,                               00900000
                say 'PS LMOPEN failed rc='RCTEMP                        00910003
              end                                                       00920000
            ADDRESS ISPEXEC,                                            00930000
             "LMCLOSE DATAID("DATIDVR")"                                00940000
            ADDRESS ISPEXEC,                                            00950000
             "LMFREE DATAID(DATIDVR)"                                   00960000
          END                                                           00970000
        WHEN ZDLVOL = '*VSAM*' THEN                                     00980003
          DO                                                            00990000
            "VERIFY dataset('"DSNID"')"                                 01000003
            RCTEMP = RC                                                 01010003
            IF (RCTEMP \= 0) THEN                                       01020003
              do                                                        01030003
                say 'Verify failed rc='RCTEMP                           01040003
              end                                                       01050003
          END                                                           01060000
        WHEN ZDLDSORG = 'VS' THEN                                       01061004
          DO                                                            01062003
            say 'We do not touch vsam components'                       01062103
          END                                                           01063003
        OTHERWISE                                                       01070000
          DO                                                            01080000
            ADDRESS ISPEXEC,                                            01090000
             "LMINIT DATAID(DATIDVR)",                                  01100000
             "DATASET('"DSNID"') ENQ(SHR)"                              01110000
            RCTEMP = RC                                                 01120000
            IF (RCTEMP \= 0) THEN                                       01130000
              do                                                        01140000
                say 'otherwise LMINIT failed rc='RCTEMP                 01150003
              end                                                       01160000
            ADDRESS ISPEXEC,                                            01170000
             "LMOPEN DATAID("DATIDVR") OPTION(INPUT)"                   01180000
            RCTEMP = RC                                                 01190000
            IF (RCTEMP \= 0) THEN                                       01200000
              do                                                        01210000
                if (zdllrecl < 255) then,                               01220000
                  say 'otherwise LMOPEN failed rc='RCTEMP',',           01230003
                    'lrecl='zdllrecl                                    01231003
              end                                                       01240000
            ADDRESS ISPEXEC,                                            01250000
             "LMCLOSE DATAID("DATIDVR")"                                01260000
            ADDRESS ISPEXEC,                                            01270000
             "LMFREE DATAID(DATIDVR)"                                   01280000
          END                                                           01290000
      END                                                               01300000
      /* zdlvol    - volume */                                          01310000
      /* zdldev    - device type */                                     01320000
      /* zdldsorg  - dsorg  */                                          01330000
      /* zdlrecfm  - recfm  */                                          01340000
      /* zdllrecl  - lrecl  */                                          01350000
      /* zdlblksz  - blksize */                                         01360000
      /* zdlsize   - size in tracks */                                  01370000
      /* zdlused   - used tracks */                                     01380000
      /* zdlnext   - number of extents */                               01390000
      /* zdlcdate  - create date */                                     01400000
      /* zdledate  - expiration date */                                 01410000
      /* zdlrdate  - referenced last date */                            01420000
      /* zdlpages  - pdse pages allocated or blank */                   01430000
      /* zdldtype  - dsname type pds, library, or blank */              01440000
      /* zdlpused  - percent used if pdse or blank */                   01450000
    end                                                                 01460000
end                                                                     01470000
"ISPEXEC LMDFREE DATAID(&DSNLIST)"                                      01480000
EXIT                                                                    01490000
./ ADD NAME=URLCHECK 0666-07210-07210-0832-00001-00001-00000-DIR2UPDT
rexx_URLCHECK: /* URLCHECK.rex - IBM REXX Sample Program             */
  rexxpgm_version = "02.00"
  /*------------------------------------------------------*/
  /*                                                      */
  /* Program:   URLCHECK                                  */
  /* Purpose:   Check the modification dates of all URLs  */
  /* Input:     URLList - ddname of urls to check         */
  /*            HTMLFile - ddname for output              */
  /* Returns:   HTML showing last modified dates.         */
  /*                                                      */
  /*------------------------------------------------------*/
  /* URLList:                                             */
  /*   http://www.sitename.com                            */
  /*   http://www.sitename.com/doclib/filename.doc        */
  /*   #http://www.sitename.com                           */
  /*------------------------------------------------------*/
URLCheck:
  Parse Arg URLList HTMLFile
  signal on halt
  signal on syntax

  Call Program_Initiation
  Call Initialize_TCPIP_Services

  Call CheckURLs URLList
  Call WriteHTML HTMLFile, Changed, Unchanged, Commented

  Call Terminate_TCPIP_Services
  Exit
  Call Shut_the_socket

  /*------------------------------------------------------*/
  /*                                                      */
  /* Procedure: Program initiation                        */
  /* Purpose:   Initialize variables.                     */
  /* Arguments: None                                      */
  /* Returns:   Nothing                                   */
  /*                                                      */
  /*------------------------------------------------------*/
Program_Initiation:
  call WHERE_AM_I_STORED
  Say "Input comes from ddname="URLList
  Say "Output goes to ddname="HTMLFile

  URLS.0 = 0
  Changed = ''
  Unchanged = ''
  Commented = ''
  CRLF = x2c('0D25')
  CR   = x2c('0D')
  LF   = x2c('25')
  Return

  /*------------------------------------------------------*/
  /*                                                      */
  /* Procedure: Establish_A_Socket                        */
  /* Purpose:   Get the TCP/IP socket primed.             */
  /* Arguments: None                                      */
  /* Returns:   rc                                        */
  /*                                                      */
  /*------------------------------------------------------*/
Initialize_TCPIP_Services:

 /*----------------------------------------------------------------*/
 /* Initialize the Socket                                          */
 /*----------------------------------------------------------------*/
  so_txt = Socket('Initialize', 'URLCHECK', 20)
  parse var so_txt s_rc s_subtask s_maxdesc s_servicename
  socket_rc = s_rc
  if s_rc = 0 then,
    Do
      initialized = 1
      Say s_servicename":"s_subtask "initialized" s_maxdesc "sockets"
    End
  else,
    call error 'E', 40, 'Unable to initialize SOCKET URLCheck' s_rc
  Return

  /*------------------------------------------------------*/
  /*                                                      */
  /* Procedure: Establish_A_Socket                        */
  /* Purpose:   Get the TCP/IP socket primed.             */
  /* Arguments: None                                      */
  /* Returns:   rc                                        */
  /*                                                      */
  /*------------------------------------------------------*/
Establish_A_Socket:
 /*----------------------------------------------------------------*/
 /* Establish a socket                                             */
 /*----------------------------------------------------------------*/
  so_txt = Socket('Socket', 'AF_INET', 'STREAM', 'TCP')
  parse var so_txt s_rc s_results
  if s_rc <> 0 then,
    do
      call error 'E', 60, 'SOCKET(SOCKET) rc='s_rc
    end
  else,
    Do
      say "Socket(STREAM)="so_txt
      s_d = s_results
      say 'socket descriptor='s_d
      socket_rc = 0
    End

 /*----------------------------------------------------------------*/
 /* Turn  on               EBCDIC-Ascii conversion                 */
 /*----------------------------------------------------------------*/
  so_txt = Socket('SetSockOpt',s_d,'SOL_SOCKET','SO_ASCII','On')
  parse var so_txt s_rc s_results
  if s_rc = 0 then,
    Do
      Say "'Socket' So_ASCII" so_txt
    End
  else,
    call error 'W', 70, 'Unable to set SOCKET So_ASCii' s_rc
  Return

  /*------------------------------------------------------*/
  /*                                                      */
  /* Procedure: CheckURLs                                 */
  /* Purpose:   Check the modification dates of all URLs  */
  /*            listed in the specified file. If the date */
  /*            has changed, update the list file with    */
  /*            the new date.                             */
  /* Arguments: URLFile - file containing URL list        */
  /* Returns:   nothing                                   */
  /*                                                      */
  /*------------------------------------------------------*/
CheckURLs:
  Parse Arg URLFile

  If socket_rc <> 0 then exit socket_rc
  Index = 0
  Do forever
    /* read line with URL and last modification date    */
    inline  = LineIn(URLFile)
    parse var inline readrc URLLine
    if readrc <> 0 then leave
    say "========================================================"
    say 'inline='inline'='

    /* remember line for later update of file           */
    Index = Index + 1
    URLS.0 = Index
    URLS.Index = URLLine

    /* if first character is not a '#' then process URL */
    If SubStr(URLLine, 1, 1) \= '#' Then
     Do
       /* retrieve header for specified URL             */
       Parse Var URLLine URL ' ' ModDate
       Header = GetHeader(URL)

       If Length(Header) \= 0 Then
        Do
          /* header could be read, find date            */
          DocDate = GetModificationDate(Header)
         say 'moddate='moddate 'docdate='docdate

 /*       If Length(ModDate) = 0 | ModDate \= DocDate Then    */
          If ModDate \= DocDate Then,
           Do
             /* this URL has been changed, add to list  */
             /* of changed URLs and update the date     */
             Changed = Changed Index
             URLS.Index = URL DocDate
           End
          Else,
            /* add index to list of unchanged URLs     */
            Unchanged = Unchanged Index
        End
       Else,
         /* add index to list of unchanged URLs        */
         Unchanged = Unchanged Index
     End
    Else
      /* add index to list of all commented out URLs   */
      Commented = Commented Index
  End

  /* close input stream, erase it and then rewrite it   */
  "EXECIO 0 DISKR" URLFile "(Finis"

  url_end = urls.0
  say url_end 'urls in' URLFile
  Do Index = 1 To URL_END
    say 'dd='URLFile  URLS.Index
    Call LineOut URLFile, URLS.Index
  End

  "EXECIO 0 DISKW" URLFile "(Finis"
  Return

  /*------------------------------------------------------*/
  /*                                                      */
  /* Procedure: WriteHTML                                 */
  /* Purpose:   Create a new HTML document with links to  */
  /*            the input URLs grouped by modification.   */
  /* Arguments: HTML - output filename                    */
  /*            Changed - list of changed URL indices     */
  /*            Unchanged - list of unchanged URL indices */
  /*            Commented - list of commented URL indices */
  /* Returns:   nothing                                   */
  /*                                                      */
  /*------------------------------------------------------*/
WriteHTML:
  Parse Arg HTMLFile, Changed, Unchanged, Commented

  /* write new HTML document with links to URLs         */

  Call LineOut HTMLFile, '<html><head>'
  Call LineOut HTMLFile, '<title>My link list</title>'
  Call LineOut HTMLFile, '</head><body>'
  Call LineOut HTMLFile, ' '
  Call LineOut HTMLFile, '<h1>Changed documents</h1>'
  Call FormatURLList HTMLFile, Changed
  Call LineOut HTMLFile, '<br><hr><br>'
  Call LineOut HTMLFile, ' '
  Call LineOut HTMLFile, '<h1>Unchanged documents</h1>'
  Call FormatURLList HTMLFile, Unchanged
  Call LineOut HTMLFile, '<br><hr><br>'
  Call LineOut HTMLFile, ' '
  Call LineOut HTMLFile, '<h1>Commented documents</h1>'
  Call FormatURLList HTMLFile, Commented
  Call LineOut HTMLFile, '<br><hr><br>'
  Call LineOut HTMLFile, ' '
  Call LineOut HTMLFile, '<p><i>Documents checked at',
               Date() 'on' Time() '</i>'
  Call LineOut HTMLFile, '</body></html>'
  Return

  /*------------------------------------------------------*/
  /*                                                      */
  /* Procedure: FormatURLList                             */
  /* Purpose:   Format a list of URL indices into a HTML  */
  /*            formatted list with links to the URLs.    */
  /* Arguments: HTML - output filename                    */
  /*            List - list of indices                    */
  /* Returns:   nothing                                   */
  /*                                                      */
  /*------------------------------------------------------*/
FormatURLList:
  Parse Arg HTMLFile, List

  /* are there any indices in the list?                 */
  If Words(List) > 0 Then
   Do
    Do Index = 1 To Words(List)
      Idx = Word(List, Index)
      Parse Var URLS.Idx URL ModDate
      URL = Strip(URL, 'L', '#')

      last_moddate =  '<br><a href=''' || URL || '''>',
                             URL || '</a>'
      If Length(ModDate) > 0 Then
        last_moddate = last_moddate||', last modified at' ModDate
      Call LineOut HTMLFile, last_ModDate
    End
   End
  Else
    Call LineOut HTMLFile, '<p><i>No documents in list</i>     '
  Return

  /*------------------------------------------------------*/
  /*                                                      */
  /* Procedure: LineOut                                   */
  /* Purpose:   Output the line using EXECIO.             */
  /* Arguments: ddname                                    */
  /*            TextString                                */
  /* Returns:   rc                                        */
  /*                                                      */
  /*------------------------------------------------------*/
LineOut:
  outddname = arg(1)
  TextString = arg(2)
  say 'ddname='outddname 'txt='textstring
  push TextString
  "EXECIO 1 DISKW" outddname
  Return

  /*------------------------------------------------------*/
  /*                                                      */
  /* Procedure: LineIn                                    */
  /* Purpose:   Read a record using EXECIO.               */
  /* Arguments: ddname                                    */
  /* Returns:   rc                                        */
  /*            TextString                                */
  /*                                                      */
  /*------------------------------------------------------*/
LineIn:
  parse arg inddname
  "EXECIO 1 DISKR" inddname "(stem indata."
  read_rc = rc
  inline = strip(indata.1,"T"," ")
  if read_rc <> 0 then inline = "<EOF>"
  Return read_rc inline

  /*------------------------------------------------------*/
  /*                                                      */
  /* Function:  Connect                                   */
  /* Purpose:   Create a socket and connect it to server. */
  /* Arguments: Server - server name, may contain port no.*/
  /* Returns:   Socket number if successful, -1 otherwise */
  /*                                                      */
  /*------------------------------------------------------*/
Connect:
  Parse Arg Server

  /* if the servername has a port address specified     */
  /* then use this one, otherwise use the default http  */
  /* port 80                                            */
  Parse Var Server Server ':' Port
  If Port = '' Then
    Port = 80

  if this_is_real  = 1 then,
    do
  /* resolve server name alias to dotted IP address     */
  so_txt = Socket('Gethostbyname', server)
  parse var so_txt s_rc s_results
  if s_rc <> 0 then,
    do
      call error 'I', 80, 'GetHostByName for',
        server 'failed' s_rc
     Return -1
    end
    end

 /*----------------------------------------------------------------*/
 /* Connect the socket                                             */
 /*----------------------------------------------------------------*/
  so_txt = Socket('Connect', s_d, 'AF_INET' port server)
  parse var so_txt s_rc s_results
  if s_rc <> 0 then,
    do
      call error 'W', 120, 'SOCKET(CONNECT) rc='s_rc
    end
  else,
    Do
      say "Connected to" server s_results
    End
  Return 0

  /*------------------------------------------------------*/
  /*                                                      */
  /* Function:  Read_From_Socket                          */
  /* Purpose:   Retrieve the results of a command or      */
  /*            socket call.                              */
  /* Arguments: Socket - active socket number             */
  /* Returns:   Response from server or empty string if   */
  /*            failed.                                   */
  /*                                                      */
  /*------------------------------------------------------*/
read_from_socket:
  Response = ''
  Do Forever
    so_txt = peek_at_socket()
    if s_rc <> 0 then,
      do
        say 'I tried to peek but had a problem:'s_rc
        say '::'so_txt'::'
        Leave
      end
    if s_data_len = 0 then,
      do
        say "I peeked and found nothing more to read."
        Leave
      end
    BytesRcvd = Socket('Recvfrom', s_d, 1024)
    parse var bytesrcvd s_rc RcvData
    If s_rc <  0 Then
      do
        say  s_rc '<= 0 so i am leaving read_from_socket' rcvdata
        Leave
      end
    if s_rc <> 0 then,
      do
        call error 'I', 242, 'SOCKET(RecvFrom) rc='s_rc
      end
    Response = Response || RcvData
  End
  Return Response

 /*----------------------------------------------------------------*/
 /* Hear what the server has to say                                */
 /*----------------------------------------------------------------*/
Peek_at_socket:
  so_txt = Socket('Recv', s_d, 1024, 'PEEK')
  parse var so_txt s_rc s_type s_port s_ip s_results
  parse var so_txt s_rc s_data_len s_data_text
  if s_rc <> 0 then,
    do
      call error 'W', 250, 'SOCKET(Peek) rc='s_rc
    end
  Return so_txt

  /*------------------------------------------------------*/
  /*                                                      */
  /* Procedure: Close_Socket                              */
  /* Purpose:   Close the socket                          */
  /* Arguments: Socket - active socket number             */
  /* Returns:   nothing                                   */
  /*                                                      */
  /*------------------------------------------------------*/
Close_socket:
  so_txt = Socket('Close', s_d)
  parse var so_txt s_rc s_results
  if s_rc <> 0 then,
    do
      call error 'W', 234, 'Close rc='s_rc
    end
  Return

  /*------------------------------------------------------*/
  /*                                                      */
  /* Function:  GetHeader                                 */
  /* Purpose:   Request the header for the specified URL  */
  /*            from the network.                         */
  /* Arguments: URL - fully specified document locator    */
  /* Returns:   Full header of specified document or      */
  /*            empty string if failed (also if no header */
  /*            exists).                                  */
  /*                                                      */
  /*------------------------------------------------------*/
GetHeader:
  Parse Arg URL

  /* Isolate server name and document name, document    */
  /* name is always preceded with a slash               */
  Parse Var URL 'http://' Server '/' Document
  Document = '/' || Document

  socket_rc = -1
  Call Establish_A_Socket
  Socket = Connect(Server)
  If Socket = -1 Then
    Return ''

  Command = 'HEAD' Document 'HTTP/1.0'
  sendrc = SendCommand(Socket, Command)
  Command = ''
  sendrc = SendCommand(Socket, Command)
  Header  = read_from_socket()
  Call Close_Socket
  Return Header

  /*------------------------------------------------------*/
  /*                                                      */
  /* Function:  SendCommand                               */
  /* Purpose:   Send a command via the specified socket   */
  /*            and return the full response to caller.   */
  /* Arguments: Socket - active socket number             */
  /*            Command - command string                  */
  /* Returns:   Response from server or empty string if   */
  /*            failed.                                   */
  /*                                                      */
  /*------------------------------------------------------*/
SendCommand:
  Parse Arg Socket, Command
  call check_ops

  /* append two pairs of CRLF to end the command string */
  Command = Command || crlf
  say 'cmd='command'=cmd'

  so_txt = Socket('Write', s_d,Command)
  parse var so_txt s_rc s_results
  if s_rc <> 0 then,
    do
      call error 'E', 230, 'SOCKET(WRITE) rc='s_rc
    end
  else,
    Do
      s_data_len = s_results
      if s_data_len < 1 then say "Writing nothing?" s_data_len
    End
  return so_txt

 /*----------------------------------------------------------------*/
 /* See if I should read                                           */
 /*----------------------------------------------------------------*/
check_ops:
  so_txt = Socket('Select', 'Read' '*' 'Write' '*' 'Exception' '*', 2)
  parse var so_txt s_rc s_results
  if s_rc <> 0 then,
    do
      call error 'W', 210, 'SOCKET(Select) rc='so_txt
    end
  else,
    Do
      say "Select shows" so_txt
    End
  return

  /*------------------------------------------------------*/
  /*                                                      */
  /* Procedure: Shutdown_the_socket                       */
  /* Purpose:   Shutdown the socket                       */
  /* Arguments: Socket - active socket number             */
  /* Returns:   nothing                                   */
  /*                                                      */
  /*------------------------------------------------------*/
Shut_the_socket:
  Parse Arg Socket
  so_txt = Socket('Shutdown', s_d, 'BOTH')
  parse var so_txt s_rc s_results
  if s_rc <> 0 then,
    do
      call error 'W', 232, 'Shutdown rc='s_rc
    end
  Return

  /*------------------------------------------------------*/
  /*                                                      */
  /* Function:  GetModificationDate                       */
  /* Purpose:   Find the last-modified date in the passed */
  /*            header and return just the date.          */
  /* Arguments: Header - full header of document          */
  /* Returns:   Date string when document was last        */
  /*            modified or empty string if date was not  */
  /*            found.                                    */
  /*                                                      */
  /*------------------------------------------------------*/
GetModificationDate:
  Parse Arg Header

  /* isolate date string and strip all unwanted chars   */
  Parse Upper Var Header 'LAST-MODIFIED:' HeadDate '25'x
  HeadDate = Strip(HeadDate)
  HeadDate = Strip(HeadDate,,'0D'x)
  Return HeadDate

  /*------------------------------------------------------*/
  /* Find out who I am and then show it.                  */
  /*------------------------------------------------------*/
WHERE_AM_I_STORED:
  myexitrc = 0
  Parse VERSION,
    version_rexx_name,
    version_rexx_version,
    version_rexx_date
  Parse SOURCE,
    source_host_env,
    source_call_type,
    source_uc_exec_name,
    source_hostdd,
    source_hostdsn,
    source_nf_exec_name,
    source_initial_cmd_env,
    source_asid_name,
    source_char8_user_token,
    source_hostother
  Address_Environment = Address()
  Select
    When (version_rexx_name = "REXX-ooRexx_3.1(MT)") Then,
      REXX_ENVIR = "PC/ooREXX"
    When ((version_rexx_name = "REXXSAA") & ,
          (source_initial_cmd_env = "DOS")) Then,
      REXX_ENVIR = "PC/IBM_PC_DOS"
    When ((version_rexx_name = "REXXSAA") & ,
          (source_initial_cmd_env = "OS2")) Then,
      REXX_ENVIR = "PC/IBM_OS/2"
    When ((version_rexx_name = "REXX370") & ,
          (source_initial_cmd_env = "CMS")) Then,
      REXX_ENVIR = "VM/CMS"
    When ((source_asid_name = "MVS") & ,
          (source_initial_cmd_env = "MVS")) Then,
      REXX_ENVIR = "MVS/Batch"
    When ((version_rexx_name = "REXX370") & ,
          (source_initial_cmd_env = "TSO")) Then,
      REXX_ENVIR = "MVS/TSO"
    When ((version_rexx_name = "REXX370") & ,
          (source_initial_cmd_env = "ISPF")) Then,
      REXX_ENVIR = "MVS/TSO/ISPF"
    When ((version_rexx_name = "REXX/2") & ,
          (source_initial_cmd_env = "WINDOWS")) Then,
      REXX_ENVIR = "PC/SPFPC"
    When (Address_Environment = "COMMAND") Then,      /* PC/DOS 7.0 */
      REXX_ENVIR = "PC/DOS7.0"
    When (Address_Environment = "SYSTEM") Then,       /* Regina Rexx */
      REXX_ENVIR = "PC/REGINA"
    Otherwise
      REXX_ENVIR = "UNKNOWN"
  End
  say ""
  say Copies("=",55)
  say left("=" source_uc_exec_name dir2updt_version,53) "="
  say left("=" "executing under" source_host_env,53) "="
  say left("=" "as a" source_call_type,53) "="
  say left("=  on" date() "at" time()".",53) "="
  say Copies("=",55)
  say ""
  RETURN


  /*------------------------------------------------------*/
  /* Syntax error routine                                 */
  /*------------------------------------------------------*/
syntax:
  xrc = rc
  say "xrc="xrc
  sigl_record = sigl
  MY_DATA=SOURCELINE(SIGL_RECORD)
  say sigl_record my_data
  call error 'E', rc, '==> REXX Error No.' xrc '@ line',
    sigl_record
  return

  /*------------------------------------------------------*/
  /* Halt   error routine                                 */
  /*------------------------------------------------------*/
halt:
  call error 'E', 220, '==> REXX Interrupted'
  return

  /*------------------------------------------------------*/
  /* Common error routine                                 */
  /*------------------------------------------------------*/
error:
  type = arg(1)
  retc = arg(2)
  text = arg(3)
  ecretc = right(retc,3,'0')
  ectype = translate(type)
  ecfull = 'URLCheck' || ecretc || ectype
  say '===> 'type":" ecfull text
  if type <> 'E' then return
  if (initialized = 0) then,
    do
      so_txt = Socket('SocketSetStatus')
      parse var so_txt s_rc s_severreason
      if (s_rc <> 'Connected') then,
        say 'The status of the socket set is' s_rc s_severreason
    end
  else,
    do
      so_txt = Socket('SocketSetStatus')
      parse var so_txt s_rc s_severreason
      if (s_rc <> 'Connected') then,
        say 'The status of the socket set is' s_rc s_severreason
    end
  so_txt = Socket('Terminate')
  exit retc

Terminate_TCPIP_Services:
  *-------------------------------------------------------*/
  * Terminate the socket and exit                         */
  *-------------------------------------------------------*/
  so_txt = Socket('Terminate')
  Return

  /*------------------------------------------------------

     The HEAD command can be sent in two formats: the simple request or
the full request. The full request format of the HEAD command is defined
as follows:

    HEAD documentname HTTP/1.0<CRLF>
    request header<CRLF>

For our purpose we don't need to pass additional options in the request
header field so we can leave this field blank. However we may not omit
the closing CRLF character pair terminating the request header field
otherwise the server would not accept it as a valid command. The full
request sent to a server will return a full response in the format:

    HTTP/1.0 statuscode reasonphrase<CRLF>
    response body<CRLF>

The HTTP specification lists several information fields for the
response body that can appear in any order. Currently we are only
interested in the Last-Modified field and ignore all other fields.

     The following line shows a sample HEAD command sent to a server
with the appropriate response:

    HEAD / HTTP/1.0<CRLF><CRLF>

Response from server:

    HTTP/1.0 200 OK<CRLF>
    Server: GoServe/2.45<CRLF>
    Date: Thu, 18 Jul 1996 15:40:47 GMT<CRLF>
    Content-Type: text/html<CRLF>
    Content-Length: 1081<CRLF>
    Content-Transfer-Encoding: binary<CRLF>
    Last-Modified: Thu, 19 Oct 1995 16:27:52 GMT<CRLF>

Since we are only interested in the date when the document has been
last modified we have to search the response for this keyword. During
development of this sample I discovered that most web servers use the
exact string as shown above to identify this field, some other servers
however don't. To be able to find  the date in responses from all
servers we can simply uppercase the whole string before searching the
last-modified field.

     This is already everything we need to know for our program.

      ------------------------------------------------------*/
./ ADD NAME=VIEWHELP 0666-07208-07208-2151-00001-00001-00000-DIR2UPDT
rexx_VIEWHELP: /* We still need rexx in comment if read from SYSPROC */
/*---------REXX viewhelp ------------------------------*/
/*                                                     */
/* LIB: REXX(viewhelp)                                 */
/* DOC: THIS REXX EXEC Captures the output of the      */
/*      help command and then invokes view.            */
/*                                                     */
/*---------REXX viewhelp ------------------------------*/
PARSE ARG full_cmd
/*                                                                 */
  bulk_dd = "BULK"RIGHT("0000"RANDOM(99999),4)
  "ALLOC FILE("bulk_dd") SPACE(5 5) RECFM(F B)",
    "BLKSIZE(0) LRECL(80) DSORG(PS) NEW DELETE",
    "UNIT(SYSALLDA) DIR(0)"
  quiet = Outtrap("HLP.")
  "help" full_cmd
  quiet = Outtrap("OFF")
  "EXECIO" HLP.0 "DISKW" bulk_dd "(FINIS STEM HLP."
  "ISPEXEC CONTROL ERRORS RETURN"
  "ISPEXEC LMINIT DATAID(PNLID) DDNAME("bulk_dd")"
  "ISPEXEC VIEW DATAID("PNLID")"
  "ISPEXEC LMCLOSE DATAID("PNLID")"
  "ISPEXEC LMFREE DATAID("PNLID")"
  "FREE FILE("bulk_dd")"
EXITIT:
  EXIT
./ ADD NAME=XMIT2PDS 0666-07208-07208-2242-00001-00001-00000-DIR2UPDT
rexx_XMIT2PDS: /* REXX -
 +------------------------------------------------------------------+
 | Name:       XMIT2PDS                                             |
 | Type:       REXX exec                                            |
 | Purpose:    Convert sequential data set to a PDS.                |
 | Release:    1.0                                                  |
 | Programmer: Kenneth E. Tomiak                                    |
 | Date:       1999-11-04  1999.308                                 |
 | Abstract:   Use the TSO receive command to convert a sequential  |
 |             data set back to its original format.                |
 |                                                                  |
 | Call Format:  %XMIT2PDS dsname                                   |
 |                                                                  |
 +------------------------------------------------------------------+ */

/* +-----------------------------------------+
   | Procedures and functions defined below. |
   +-----------------------------------------+ */

    Parse upper arg dsn newname

    sysuid = SYSVAR("SYSUID")
    memlist = ""
    if members >< "" then,
      memlist = "MEMBERS("members")"

    say 'dsn='dsn

    ndsn = strip(dsn,"B","'")
    newname = "'"ndsn".pds'"
    call test_if_pds
    Say "Attempting to store" dsn "as" newname
    xc = PROMPT("ON")
    Queue "Dataset("newname")"
    Queue "end"
    "RECEIVE",
      "INDATASET("dsn")"

    xmit_rc = RC
    if xmit_rc > 0 then,
      Say "RECEIVE returned =" xmit_rc"."

    exit

test_if_pds:
    openparen = pos("(",ndsn)
    if openparen = 0 then return
    ndsn = strip(dsn,"B","'")
    parse var ndsn justdsn '(' justmbr ')' .
    newname = "'"justdsn".PDSMBR."justmbr"'"
    return
./ ADD NAME=XYGRID   0666-07208-07208-2329-00001-00001-00000-DIR2UPDT
rexx_xygrid:
  xygrid_version = "01.00"
  call grid_init
  call grid_plot
  call grid_display
  exit 0

grid_init:

  max_length = 2    /* maximum cell length           */
  max_xdepth = 10   /* the x-axis runs left to right */
  max_ydepth = 5    /* the y-axis runs up to down    */
  max_growth = "N"  /* "Y" allows grid to extend     */

  grid. = "  "
  return

grid_plot:
  myrc = plot(0, 0, "00")
  if (myrc >< 0) then say "Plot error, depth("myrc")"
  plt_xdepth = -3
  plt_ydepth = -4
  plt_data   = "LL-lower left"
  myrc = plot(plt_xdepth, plt_ydepth, plt_data)
  if (myrc >< 0) then say "Plot error, depth("myrc")"
  plt_xdepth =  3
  plt_ydepth =  5
  plt_data   = "UR-upper right"
  myrc = plot(plt_xdepth, plt_ydepth, plt_data)
  if (myrc >< 0) then say "Plot error, depth("myrc")"
  return

plot:
  p_x = arg(1)
  p_y = arg(2)
  p_d = arg(3)
  n_x = p_x
  n_y = p_y
  if (n_x < 0) then n_x = n_x * -1
  if (n_y < 0) then n_y = n_y * -1
  if (max_growth = "Y") then
    do
      if (n_x > max_xdepth) then max_xdepth = n_x
      if (n_y > max_ydepth) then max_ydepth = n_y
    end
  else,
    do
      if (n_x > max_xdepth) then return max_xdepth
      if (n_y > max_ydepth) then return max_ydepth
    end
  grid.p_x.p_y = p_d
  return 0

grid_display:
  min_xdepth = max_xdepth * -1
  min_ydepth = max_ydepth * -1
  xdash = copies("-",((max_ydepth*((max_length+1)*2))*2)+max_length+2)
  say xdash
  do plt_ydepth = max_ydepth to min_ydepth by -1
    plot_line = ""
    do plt_xdepth = min_xdepth to max_xdepth
      plot_line = plot_line"|"||,
        left(grid.plt_xdepth.plt_ydepth,max_length)
    end
    say plot_line"|"
    say xdash
  end
  return

./ ENDUP
