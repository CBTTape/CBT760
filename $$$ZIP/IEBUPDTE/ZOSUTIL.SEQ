./ ADD NAME=$$$INDEX 0666-07209-07209-1503-00001-00001-00000-DIR2UPDT

This dataset (sub-directory) contains the beginning of a project to
have some useful samples showing how to use various utilities.

Member   Purpose of the member
-------- --------------------------------------------------------------
$$$INDEX This member
ADRDSSU  DFSMSdss - DATA SET SERVICES
AMASPZAP Super Zap for wizards only - you break it you fired
AMBLIST  List lmod, obj, lpa
BATCH    Ways to run TSO, ISPF, and USS as batch jobs
BMC4DB2  BMC DB2 Utilities
CPPUPDTE The supported IPOUPDTE, mass JCL changer
CUNMITG1 UNICODE translation services
DFHCSDUP CICS CSD Update
DITTO    Add on data duplication utility
DSNTEP2  DB2 Dynamic SQL - DML
DSNTIAD  DB2 Dynamic SQL - DDL
DSNTIAUL DB2 Dynamic Unload
EDGINERS DFHRMM (IBM TAPE SUBSYSTEM SOFTWARE)
FDR      Innovations Fast Dump Restore solution
FTP      File Transfer Programs - TCP/IP, Direct Connect, Netview/FTP
HCD      Hardware Configuration Dialog and HCM setup jobs
ICKDSF   Device Support Facilities
IDCAMS   Access Method Services
IEBCOMPR Compare data
IEBCOPY  Library Copy
IEBDG    Test Data Generator
IEBEDIT  Edit Job Stream
IEBGENER Sequential Copy/Generate Data Set
IEBIMAGE Create Printer Image
IEBPTPCH Print-Punch
IEBUPDTE Update Data Set
IEFBR14  And why you shouldn't be using it
IEHATLAS See ICKDSF instead
IEHINITT Initialize Tape
IEHLIST  List System Data
IEHMOVE  Move System Data
IEHPROGM Program Maintenance
IEWBLINK Linkage Editor
IFASMFDP System Management Facilities Dump Program
IFHSTATR List ESV Data
IPCS     Interactive Problem Control System (SVC dump processor)
ISRSUPC  ISPF SuperC Compare
IXCMIAPU Couple data set utility
JOBCARD  JOBCARD sample
RACF     RACF data base unload
SDSF     Spool Display and Search Facility
SMPE     System Maintenance Program/ Extended
SORT     IBM SORT, SYNCSORT
SRCHFOR  Finds strings in members of a PDS
TRSMAIN  TRSMAIN for compressing and uncompressing


=======================================================================

The original concept was good, the design was left unassigned, the
contributions were few, and the bulk of the samples come from the
outdated UTILITIES manual. I have been updating them to work in
an SMS environment and with how z/OS works these days.

  Know how and where to look for samples and examples:

  - SYS1.SAMPLIB
  - Other products hlq.**.*samp
  - In manuals
      SC26-7414-02 z/OS DFSMSdfp Utilities
  - On the web (see below)

  Know the difference between a sample and an example.

  - A sample is complete code that worked somewhere at sometime.

  - An example is a theoretical snippet that may not work as shown
    and may never have ever been in any running code.

The organization (naming standards) of the members is still undergoing
a trial and error process to come up with a way to quickly identify
the utility and the purpose. I had been leaning towards many members,
using the first three characters of the utility name and up to five
characters to show a minor characteristic. Dan Denver, a co-worker,
shared his HSM hints member with me and I am now of the belief I should
have one member per component.

And even this design may change if I get around to writing the
%UTILITY edit macro to embed a utility STEP, similar to how the
MODEL command works.

On the web:
===========
In addition to making softcopy documents available on CD-ROM, IBM
provides access to unlicensed z/OS softcopy documents on the Internet.
To find z/OS documents on the Internet, first go to the z/OS home page:
http://www.ibm.com/servers/eserver/zseries/zos

Now in knowing how to look, start at the beginning:

On January 16th, 2007 I was able to navigate to books this way
http://www.ibm.com
(I was redirected to http://www.ibm.com/us)
Find the 'Products' link under the IBM logo
Find the 'system z (Mainframe)' link under Systems & Servers
Find the 'Operating systems' link under Mainframe servers
Find the /z/OS' link
Find the 'Library' link
Find the VxRy link for the level of the system you are using.
Find the Element or feature you need (MVS)

Brought me to:
http://www-03.ibm.com/servers/eserver/zseries/zos/bkserv/r7pdf/mvs.html
and for the JCL User's Guide:
http://publibz.boulder.ibm.com/epubs/pdf/iea2b540.pdf
and under DFSMS for the DFSMSdfp Utilities Manual:
http://publibz.boulder.ibm.com/epubs/pdf/dgt2u120.pdf

Since websites and their links change, it is more important to
know how to find them than to rely on a static link off some other
web site's page. Even the instructions above may now be out of date.
The point of having the instructions above is to show how one might
go about finding information.

=======================================================================

./ ADD NAME=ADRDSSU  0666-07209-07209-1504-00001-00001-00000-DIR2UPDT
>< ADD NAME=SSU      0108-07003-07165-0055-00008-00011-00000-KTOMIAK

SSU$01    ADRDSSU LOGICAL DUMP
SSU$02    ADRDSSU LOGICAL RESTORE WITH RENAMEUNC
SSU$03    ADRDSSU COPY
SSU$04    ADRDSSU COMPRESS DSORG=PO
SSU$05    ADRDSSU RELEASE UNUSED SPACE
SSU$06    ADRDSSU DEFRAG - YOU BETTER KNOW WHAT YOU ARE DOING
SSU$07    ADRDSSU DUMP AN HFS AND THEN RESTORE WITH A NEWNAME
SSU$08    ADRDSSU DELETE MATCHING DATASETS
SSU$09    ADRDSSU PRINT CONTENTS ON TRACK

>< ADD NAME=SSU$01   0100-07003-07003-2114-00106-00106-00000-KTOMIAK
//*                                                                     00040000
//* SOURCE: DSN=SHARE.MVSSCP.UTL.CNTL(SSU#01)                           00050000
//* AUTHOR: YOUR NAME <YOUREMAIL@YOURDOMAIN>                            00060000
//* REMARK: THIS JOB SHOWS how to do a logical backup.                  00070003
//*
//RESTART EXEC PGM=IDCAMS
//SYSPRINT DD  SYSOUT=*
//SYSIN    DD  *
  LISTCAT ENTRY('SHARE##.S2820LAB.BACKUP') NONVSAM
  IF LASTCC = 0 THEN +
    DO
      DELETE 'SHARE##.S2820LAB.BACKUP' NONVSAM
    END
  ELSE +
    DO
      SET MAXCC = 0     /* OKAY TO FAIL */
    END
/*
//IFREST   IF  (RC = 0) THEN
//BKUP    EXEC PGM=ADRDSSU,PARM='UTILMSG=YES'  ,TYPRUN=NORUN'
//SYSPRINT DD  SYSOUT=*
//BKUP     DD  DISP=(NEW,CATLG),DSN=SHARE##.S2820LAB.BACKUP,
//             UNIT=SYSDA,SPACE=(CYL,(40,10),RLSE)
//*            DCB=(DSORG=PS,RECFM=U,BLKSIZE=27998,LRECL=0)
//SYSIN    DD *
  DUMP  -
    ALLDATA(*)           /* ALL ALLOCATED SPACE :ALMOST */ -
    ALLEXCP              /* ALL ALLOCATED SPACE :ALMOST */ -
    DATASET(             /* LOGICAL DATASET DUMP        */ -
      INCLUDE(           /* WHAT YOU DO WANT            */ -
        SHARE##.** -
      ) -
      BY(                /* IF IT MATCHES THIS AS WELL  */ -
        (CREDT GE *,-4) -
        (DSORG EQ (SAM,PDS,PDSE)) -
      ) -
      EXCLUDE(           /* WHAT YOU DO NOT WANT        */ -
        SHARE##.HCD.** -
      ) -
        /* KEYWORD,OPERATOR,ARGUMET                     */ -
        /*         OPERATOR:                            */ -
        /*           EQ OR =                            */ -
        /*           LE OR <=                           */ -
        /*           LT OR <                            */ -
        /*           GT OR >                            */ -
        /*           GE OR >=                           */ -
        /*           NE OR ^=  (NOTSIGN IS X'5F')       */ -
        /* KETWORD:                                     */ -
        /* ALLOC              ALLOCATION TYPE           */ -
        /*                      CYL    -CYLINDER        */ -
        /*                      TRK    -TRACK           */ -
        /*                      BLK    -BLKSIZE         */ -
        /*                      ABSTR  -ABSOLUTE TRACK  */ -
        /*                      MOV    -MOVABLE         */ -
        /* CATLG              CATALOGUED                */ -
        /*                      0 = NO                  */ -
        /*                      1 = YES                 */ -
        /* CREDT              CREATE DATE               */ -
        /*                      YYYYDDD                 */ -
        /*                      *    = TODAY            */ -
        /*                      *,-DDDD = TODAY-DAYS    */ -
        /* DSCHA              DATASET CHANGED FLAG      */ -
        /*                      0 = NO                  */ -
        /*                      1 = YES                 */ -
        /* DSORG              DATA SET ORGANIZATION     */ -
        /*                      SAM                     */ -
        /*                      PAM                     */ -
        /*                      PDS                     */ -
        /*                      PDSE                    */ -
        /*                      BDAM                    */ -
        /*                      HFS                     */ -
        /*                      EXCP                    */ -
        /*                      ISAM                    */ -
        /*                      VSAM                    */ -
        /* EXPDT              EXPIRATION DATE           */ -
        /*                      YYYYDDD                 */ -
        /*                      NEVER                   */ -
        /*                      *    = TODAY            */ -
        /*                      *,-DDDD = TODAY-DAYS    */ -
        /*                      *,+DDDD = TODAY+DAYS    */ -
        /* EXTNT              NUMBER OF EXTENTS         */ -
        /* FSIZE              FILE SIZE IN TRACKS       */ -
        /* MULTI              MULTI-VOLUME INDICATOR    */ -
        /*                      0 = NO                  */ -
        /*                      1 = YES                 */ -
        /* REFDT              LAST-REFERENCE DATE       */ -
        /*                      YYYYDDD                 */ -
        /*                      *    = TODAY            */ -
        /*                      *,-DDDD = TODAY-DAYS    */ -
        /*                      *,+DDDD = TODAY+DAYS    */ -
        /* DATACLAS           SMS DATA CLASS NAME       */ -
        /* MGMTCLAS           SMS MANAGEMENT CLASS NAME */ -
        /* STORCLAS           SMS STORAGE CLASS NAME    */ -
    ) -
    OPTIMIZE(4)          /* READ 1 CYLINDER AT A TIME   */ -
       /*   (1)             READ 1 TRACK    AT A TIME   */ -
       /*   (2)             READ 2 TRACKS   AT A TIME   */ -
       /*   (3)             READ 5 TRACKS   AT A TIME   */ -
    OUTDDNAME(BKUP) -
    SHARE                /* ALLOW OTHER USERS           */ -
    SPHERE               /* PLUS VSAM AIX AND PATHS     */ -
    TOLERATE(ENQFAILURE) /* EVEN IF IN USE :ALMOST      */
/*
//*
//IFREST ENDIF
//
>< ADD NAME=SSU$02   0100-07003-07003-2114-00020-00020-00000-KTOMIAK
//*                                                                     00040000
//* SOURCE: DSN=SHARE.MVSSCP.UTL.CNTL(SSU#02)                           00050000
//* AUTHOR: YOUR NAME <YOUREMAIL@YOURDOMAIN>                            00060000
//* REMARK: THIS JOB SHOWS HOW TO DO A LOGICAL RESTORE.                 00070003
//*
//REST    EXEC PGM=ADRDSSU,PARM='UTILMSG=YES'  ,TYPRUN=NORUN'
//SYSPRINT DD  SYSOUT=*
//BKUP     DD  DISP=(OLD),DSN=SHARE##.S2820LAB.BACKUP
  RESTORE -
    CATALOG -
    DATASET(             /* LOGICAL DATASET RESTORE     */ -
      INCLUDE(           /* WHAT YOU DO WANT            */ -
        SHARE##.S2820LAB.** -
      ) -
    ) -
    INDDNAME(BKUP)       /* WHERE THEY COME FROM        */ -
    RENAMEUNC(           /* WHAT TO NAME THEM           */ -
      (SHARE##.S2820LAB.**,SHARE##.S2820RST.**) -
    )
/*
>< ADD NAME=SSU$03   0100-07003-07003-2114-00017-00017-00000-KTOMIAK
//*
//COPY    EXEC PGM=ADRDSSU,PARM='UTILMSG=YES,TYPRUN=NORUN'
//SYSPRINT DD  SYSOUT=*
//SYSIN    DD *
  COPY  -
    ALLDATA(*) -
    ALLEXCP -
    CATALOG -
    DATASET( -
      INCLUDE( -
        HLQ.MLQ*.** -
      ) -
    ) -
    RENUNC((HLQ.**,NEWHLQ.**)) -
    TOLERATE(ENQF)
/*
//*
>< ADD NAME=SSU$04   0101-07003-07003-2114-00014-00014-00014-KTOMIAK
//DSSUCMP EXEC PGM=ADRDSSU,REGION=3072K,                                00010001
//             PARM='UTILMSG=YES,TYPRUN=NORUN'                          00020001
//SYSPRINT DD  SYSOUT=*                                                 00030001
//YURVOL   DD  DISP=SHR,UNIT=SYSDA,VOL=SER=YURVOL                       00040001
//SYSIN    DD    *                                                      00050001
 COMPRESS -                                                             00060001
   BY(DSORG EQ PDS) -                                                   00070001
   DDNAME(YURVOL) -                                                     00080001
   INCLUDE( -                                                           00090001
     HLQ.** -                                                           00100001
   ) -                                                                  00110001
   WAIT(2,2)                                                            00120001
/*                                                                      00130001
//                                                                      00140001
>< ADD NAME=SSU$05   0101-07003-07003-2114-00013-00013-00013-KTOMIAK
//DSSUREL EXEC PGM=ADRDSSU,REGION=3072K,                                00010001
//             PARM='UTILMSG=YES,TYPRUN=NORUN'                          00020001
//SYSPRINT DD  SYSOUT=*                                                 00030001
//YURVOL   DD  DISP=SHR,UNIT=SYSDA,VOL=SER=YURVOL                       00040001
//SYSIN    DD    *                                                      00050001
 RELEASE -                                                              00060001
   DDNAME(YURVOL) -                                                     00070001
   INCLUDE( -                                                           00080001
     HLQ.** -                                                           00090001
   ) -                                                                  00100001
   WAIT(2,2)                                                            00110001
/*                                                                      00120001
//                                                                      00130001
>< ADD NAME=SSU$06   0100-07003-07003-2114-00008-00008-00000-KTOMIAK
//STEP001 EXEC PGM=ADRDSSU,PARM='UTILMSG=YES,TYPRUN=NORUN'
//SYSPRINT DD  SYSOUT=*
//SYSIN    DD  *
  DEFRAG -
    DDNAME(YURVOL) -
    BY(LIST(REFDT LT *,-1))  /* DATE LAST REF LT RUN DATE -1 */
/*
//YURVOL   DD  DISP=SHR,UNIT=SYSALLDA,VOL=SER=YURVOL
>< ADD NAME=SSU$07   0100-07055-07055-2142-00046-00046-00000-RJAHMAD

If you are not sharing your HFS datasets then run this on the DUMP on
the system that owns it. The RESTORE step canbe run on any system.
Mount the new dataset where you want to use it.

//*-------------------------------------------------------------------*
//* STEP TO DUMP A HFS TO A DASD DATA SET
//*-------------------------------------------------------------------*
//DUMP    EXEC PGM=ADRDSSU
//SYSPRINT DD  SYSOUT=*
//TEMPSEQ  DD  DISP=(NEW,CATLG),DSN=yourid.HFS.DUMP,
//             UNIT=SYSALLDA,
//             SPACE=(CYL,(20,5),RLSE)    <== SIZE FOR YOUR FILESPACE
//SYSIN    DD  *
  DUMP -
    DATASET( -
      INCLUDE( -
         OEHFS.ZOS1.ETC.HFS -
      ) -
    ) -
    OUTDD(TEMPSEQ) -
    TOL(ENQF)
/*
//*
//*-------------------------------------------------------------------*
//* STEP TO RESTORE A HFS TO A NEWNAME
//*-------------------------------------------------------------------*
//RESTORE EXEC PGM=ADRDSSU,REGION=0M
//OUT      DD  DISP=SHR,UNIT=SYSALLDA,VOL=SER=volser  <== Change this
//IN       DD  DISP=SHR,DSN=yourid.HFS.DUMP
//SYSPRINT DD  SYSOUT=*
//SYSIN    DD  *
  RESTORE -
    INDDNAME(IN) -
    OUTDDNAME(OUT) -
    CANCELERROR  -
    DATASET( -
      INCLUDE(OEHFS.**) -
    )  -
    NULLMGMTCLAS  -
    RENAMEU(OEHFS.**,OEHFS.SYSD.ETC.HFS) -
    TOL(ENQF) -
    REPLACE
/*
//

>< ADD NAME=SSU$08   0100-07055-07055-2239-00015-00015-00000-KTOMIAK
//*
//DELETE  EXEC PGM=ADRDSSU,PARM='UTILMSG=YES,TYPRUN=NORUN'
//OUTDD    DD  DUMMY
//SYSPRINT DD  SYSOUT=*
//SYSIN    DD *
  DUMP  -
    DELETE -
    DATASET( -
      INCLUDE( -
        HLQ*.MLQ*.** -
      ) -
    ) -
    OUTDD(DUMMY)
/*
//*
>< ADD NAME=SSU$09   0100-07165-07165-0055-00022-00022-00000-KTOMIAK

//* GUIDE:  THIS JOB WILL print the contents of a data set.
//*
//PRINT   EXEC PGM=ADRDSSU,PARM='UTILMSG=YES'  ,TYPRUN=NORUN'
//SYSPRINT DD  SYSOUT=*
//SEQ      DD  DISP=OLD,DSN=KTOMIAK.CLIST.BAC
//*            DCB=(DSORG=PS,RECFM=VS,BLKSIZE=32740,LRECL=32736)
//SYSIN    DD *
  /* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
  /* Print the contents of the dataset                               */
  /* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
  PRINT DATASET('KTOMIAK.CLIST.BAC') -
    INDDNAME(SEQ)
  /* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
  /* Print the contents of the VTOC?                                 */
  /* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
  PRINT -
    INDDNAME(SEQ)
/*
//*
//

./ ADD NAME=AMASPZAP 0666-07209-07209-1508-00001-00001-00000-DIR2UPDT
>< ADD NAME=ZAP      0103-07062-07062-2209-00004-00010-00000-KTOMIAK

ZAP$01 ABSDUMPT DUMP TRACKS OF A PDS
ZAP$02 VER A FORMAT4 ENTRY
ZAP$03 ADD IMS TO 'TERMINATION RECOVERY MANAGER LIST'
ZAP$04 ABSDUMPT DUMP A PDS MEMBER

                                                                        00060001
    EVEN A SIMPLE 'VER' ASSUMES AN UPDATE WILL FOLLOW:                  00060001
    004 AMA117D REPLY Y OR N TO UPDATE VTOC  SHTSO4 A03D  KTOMIAKH      00060001
    R 4,N         <==== TO BE SAFE                                      00060001
>< ADD NAME=ZAP$01   0102-07062-07062-2052-00010-00012-00000-KTOMIAK
                                                                        00010000
//*                                                                     00060001
/*JOBPARM LINES=9999     <=== The bigger the dataset the more lines     00060001
//*                                                                     00060001
//ZAP$01  EXEC PGM=AMASPZAP
//SYSPRINT DD  SYSOUT=*
//SYSLIB   DD  DISP=SHR,DSN=some.dataset.name
//SYSIN    DD  *
 ABSDUMPT ALL
/*
//

>< ADD NAME=ZAP$02   0101-07062-07062-2051-00012-00017-00000-KTOMIAK
//*                                                                     00060001
//* EVEN A SIMPLE 'VER' ASSUMES AN UPDATE WILL FOLLOW:                  00060001
//* 004 AMA117D REPLY Y OR N TO UPDATE VTOC  SHTSO4 A03D  KTOMIAKH      00060001
//* R 4,N         <==== TO BE SAFE                                      00060001
//*                                                                     00060001
//ZAP$02  EXEC PGM=AMASPZAP
//SYSPRINT DD  SYSOUT=*
//SYSLIB   DD  DISP=SHR,DSN=FORMAT4.DSCB,
//             UNIT=SYSALLDA,vol=SER=SHTSO4,
//             DCB=KEYLEN=44
//SYSIN    DD  *
*                 CCCCHHHHRR
         CCHHR    0000000101
         VER      0000 04040404
         ABSDUMPT ALL
/*
//
>< ADD NAME=ZAP$03   0101-07062-07062-2109-00000-00022-00000-KTOMIAK

  YOU MAY HAVE TO DUMPT THE MODULE AND SEE WHERE THE ENXT
  FREE ENTRY IS.

//*                                                                     00060001
//ZAP$03  EXEC PGM=AMASPZAP
//SYSPRINT DD  SYSOUT=*
//SYSLIB   DD  DISP=SHR,DSN=SYS1.LPALIB
//*
//*  OFFSET X'0000' MAY NOT BE AVAILABLE IN YOUR SYSTEM.
//*
//*  REFER TO THE MVS INTERFACE SECTION IN THE IMS INSTALLATION
//*  GUIDE FOR ADDITIONAL INFORMATION.
//*
//SYSIN    DD *
  NAME IGC0001C IEAVTRML
  VER 0000 000000000000000000000000
  VER 0000 C4C6E2D4D9C3D3F000000000
*          D F S M R C L 0
/*
//

>< ADD NAME=ZAP$04   0100-07062-07062-2107-00010-00010-00000-KTOMIAK

//*
//ZAP$04  EXEC PGM=AMASPZAP,REGION=1024K,TIME=30
//SYSPRINT DD  SYSOUT=*
//SYSLIB   DD  DISP=SHR,DSN=PDS.DATASET.NAME     <== CHANGE THIS
//SYSIN    DD  *
 ABSDUMPT MBRNAME
/*
//*

./ ADD NAME=AMBLIST  0666-07209-07209-1448-00001-00001-00000-DIR2UPDT
>< ADD NAME=AMB      0103-07016-07155-2106-00003-00004-00000-KTOMIAK

AMB$01    LIST load module, object
AMB$02    LIST LPA

>< ADD NAME=AMB$01   0100-07003-07003-2113-00021-00021-00000-KTOMIAK
                                                                        00010000
//*                                                                     00020000
//STEP010 EXEC PGM=AMBLIST                                              00030000
//SYSPRINT DD  SYSOUT=*                                                 00040000
//OBJLIB   DD  DISP=SHR,DSN=KTOMIAK.SHR.OBJLIB                          00050000
//LOADLIB  DD  DISP=SHR,DSN=KTOMIAK.SHR.LOADLIB                         00051000
//SYSIN    DD  *                                                        00060000
 LISTOBJ DDN=OBJLIB,MEMBER=PDSUPDTE                                     00071000
 LISTIDR DDN=LOADLIB,MEMBER=PDSUPDTE                                    00071100
 LISTLOAD DDN=LOADLIB,MEMBER=PDSUPDTE                                   00072000
 LISTLPA FLPA                                                           00073000
 LISTLPA MLPA                                                           00074000
 LISTLPA PLPA                                                           00075000
/*                                                                      00080000
//* Other options:                                                      00090000
//* LISTIDR DDN=LOADLIB,MEMBER=COBTEST                                  00100000
//* LISTLOAD DDN=LOADLIB,MEMBER=COBTEST                                 00110000
//* LISTOBJ DDN=LOADLIB,MEMBER=COBTEST                                  00120000
//* LISTLPA FLPA|MLPA|PLPA                                              00130000
//*                                                                     00140000
                                                                        00150000
>< ADD NAME=AMB$02   0100-07155-07155-2106-00018-00018-00000-KTOMIAK
                                                                        00010000
//*                                                                     00020000
//STEP010 EXEC PGM=AMBLIST                                              00030000
//SYSPRINT DD  SYSOUT=*                                                 00040000
//OBJLIB   DD  DISP=SHR,DSN=KTOMIAK.SHR.OBJLIB                          00050000
//LOADLIB  DD  DISP=SHR,DSN=KTOMIAK.SHR.LOADLIB                         00051000
//SYSIN    DD  *                                                        00060000
 LISTLPA FLPA                                                           00073000
 LISTLPA MLPA                                                           00074000
 LISTLPA PLPA                                                           00075000
/*                                                                      00080000
//* Other options:                                                      00090000
//* LISTIDR DDN=LOADLIB,MEMBER=COBTEST                                  00100000
//* LISTLOAD DDN=LOADLIB,MEMBER=COBTEST                                 00110000
//* LISTOBJ DDN=LOADLIB,MEMBER=COBTEST                                  00120000
//* LISTLPA FLPA|MLPA|PLPA                                              00130000
//*                                                                     00140000
                                                                        00150000
./ ADD NAME=BATCH    0666-07209-07209-1451-00001-00001-00000-DIR2UPDT
>< ADD NAME=BATCH    0100-07016-07016-2155-00011-00011-00000-KTOMIAK

BATCH$01 BATCHBPX - Runs UNIX System Services scripts from BPXBATCH
BATCH$02 BATCHIRX - Runs rexx without TSO overhead
BATCH$03 BATCHISP - Runs TSO and then invokes ISPF
BATCH$04 BATCHREX - Runs TSO and your application
BATCH$05 BATCHTSO - Various ways to run TSO
BATCH$06 BATCHT01 - Various ways to run TSO
BATCH$07 BATCHT1A - Various ways to run TSO
BATCH$08 BATCHT1B - Various ways to run TSO
BATCH$09 BATCHUSS - Runs scripts using UNIX System Services

>< ADD NAME=BATCH$01 0100-07010-07010-2332-00029-00029-00000-KTOMIAK

//*
//MYPROC JCLLIB ORDER=(&SYSUID..MVSSCPU.CNTL,SYS1.PROCLIB)
//*
//MYUID   SET SYSUID='WHOAREU'
//*
//STEP001 EXEC PGM=BPXBATCH,
//             PARM='SH /tmp/&SYSUID._sp /shareuser/compton'
//STDOUT   DD  PATH='/tmp/&SYSUID._s8324_.OUT',
//             PATHOPTS=(OCREAT,OTRUNC,OWRONLY),PATHMODE=SIRWXU
//STDERR   DD  PATH='/tmp/&SYSUID._s8324_.ERR',
//             PATHOPTS=(OCREAT,OTRUNC,OWRONLY),PATHMODE=SIRWXU
//*
//STEP002 EXEC PGM=IKJEFT1A
//JESOUT   DD  SYSOUT=*,DCB=(RECFM=V,LRECL=256)
//JESERR   DD  SYSOUT=*,DCB=(RECFM=V,LRECL=256)
//STPOUT   DD  PATH='/tmp/&SYSUID._s8324_.OUT',
//             PATHOPTS=ORDONLY
//STPERR   DD  PATH='/tmp/&SYSUID._s8324_.ERR',
//             PATHOPTS=ORDONLY
//SYSTSPRT DD  DUMMY
//SYSTSIN  DD  *
  PROF  MSGID WTPMSG
  OCOPY INDD(STPOUT) OUTDD(JESOUT)
  OCOPY INDD(STPERR) OUTDD(JESERR)
  BPXBATCH SH rm /tmp/&SYSUID._s8324_.ERR
  BPXBATCH SH rm /tmp/&SYSUID._s8324_.OUT
/*

>< ADD NAME=BATCH$02 0100-07010-07010-2332-00008-00008-00000-KTOMIAK

//*
//STEP001 EXEC PGM=IRXJCL,
// PARM='PAGE12 ''THIS IS MY FIRST VARIABLE''. THIS IS ANOTHER.'
//SYSTSPRT DD  SYSOUT=*
//SYSTSIN  DD  *
//SYSEXEC  DD  DISP=SHR,DSN=&SYSUID..REXX

>< ADD NAME=BATCH$03 0100-07010-07010-2332-00090-00090-00000-KTOMIAK

  The IEBUPDTE step is here merely to provide a sample rexx
  routine that launches ISPF and your application.



//*
//STEP000 EXEC PGM=IEBUPDTE,PARM=NEW
//SYSPRINT DD  SYSOUT=*
//SYSUT2   DD  DISP=(NEW,PASS),DSN=&&REXXLIB,
//             UNIT=SYSDA,SPACE=(TRK,(2,1,1)),
//             DCB=(DSORG=PO,RECFM=FB,BLKSIZE=0,LRECL=80)
//SYSIN    DD  DATA
><M1     ADD    NAME=BATCHISP
rexx_batchisp:    /* rexx  */
PARSE ARG PARMS
newstack
trap = Outtrap("mycrud.")
SAY "BATCHISP INVOKING" PARMS
SIGNAL OFF ERROR
"ISPSTART CMD("PARMS")"
STARTRC =  RC
SAY 'ISPFSTRT COMPLETED WITH RC='STARTRC'.'
trap = Outtrap("OFF")
do while queued() > 0
  parse pull crud
  say "CRUD:" crud
end
delstack
do tx = 1 to mycrud.0
  say "TRAP:" mycrud.tx
end
SAY "BATCHISP EXITING:" startrc
EXIT STARTRC
><M2     ADD    NAME=PAGE12
rexx_page12:    /* rexx  */
  parse arg var1 var2
  say 'ARG from command line:'
  call show_vars
  exit 0

show_vars:
  say 'v1='var1'.'
  say 'v2='var2'.'
  say 'v3='var3'.'
  say 'v4='var4'.'
  say ''
  return
>< ENDUP
/*
//*
//STEP001 EXEC PGM=IKJEFT1B
//SYSTSPRT DD  SYSOUT=*
//SYSTSIN  DD  *
%batchisp %page12 'This is one string.' These are words.
/*
//SYSEXEC  DD  DISP=SHR,DSN=&&REXXLIB
//*
//*
//* <==== ISPF related datasets follow ====>
//*
//ISPMLIB  DD  DISP=SHR,DSN=ISP.SISPMENU
//ISPPLIB  DD  DISP=SHR,DSN=ISP.SISPPENU
//ISPPROF  DD  DSN=&&ISPPROF,
//             DISP=(NEW,PASS),UNIT=SYSALLDA,
//             SPACE=(TRK,(5,1,10)),
//             DSORG=PO,RECFM=FB,LRECL=80,BLKSIZE=0
//ISPSLIB  DD  DISP=SHR,DSN=ISP.SISPSENU
//         DD  DISP=SHR,DSN=ISP.SISPSLIB
//ISPTABL  DD  DSN=&&TABLES,
//             DISP=(NEW,PASS),UNIT=SYSALLDA,
//             SPACE=(TRK,(5,1,10)),
//             DSORG=PO,RECFM=FB,LRECL=80,BLKSIZE=0
//ISPTLIB  DD  DISP=(OLD,PASS),DSN=&&TABLES,
//             VOL=REF=*.STEP001.ISPTABL
//         DD  DISP=SHR,DSN=ISP.SISPTENU
//ISPLST   DD  DISP=(NEW,DELETE),UNIT=SYSALLDA,SPACE=(CYL,(1,1)),
//         DCB=(LRECL=121,BLKSIZE=1210,RECFM=FBA),DSN=&&LST
//ISPLST1  DD  DISP=(NEW,DELETE),UNIT=SYSALLDA,SPACE=(CYL,(1,1)),
//         DCB=(LRECL=121,BLKSIZE=1210,RECFM=FBA),DSN=&&LST1
//ISPLST2  DD  DISP=(NEW,DELETE),UNIT=SYSALLDA,SPACE=(CYL,(1,1)),
//         DCB=(LRECL=121,BLKSIZE=1210,RECFM=FBA),DSN=&&LST2
//ISPLOG   DD  DISP=(NEW,DELETE),UNIT=SYSALLDA,SPACE=(CYL,(1,1)),
//         DCB=(LRECL=121,BLKSIZE=1210,RECFM=FBA),DSN=&&LOG
//ISPLOG1  DD  DISP=(NEW,DELETE),UNIT=SYSALLDA,SPACE=(CYL,(1,1)),
//         DCB=(LRECL=121,BLKSIZE=1210,RECFM=FBA),DSN=&&LOG1
//ISPLOG2  DD  DISP=(NEW,DELETE),UNIT=SYSALLDA,SPACE=(CYL,(1,1)),
//         DCB=(LRECL=121,BLKSIZE=1210,RECFM=FBA),DSN=&&LOG2
//

>< ADD NAME=BATCH$04 0100-07010-07010-2332-00008-00008-00000-KTOMIAK

//*
//STEP001 EXEC PGM=IKJEFT1B,PARM='%REXXPGM'
//SYSTSPRT DD  SYSOUT=*
//SYSTSIN  DD  DUMMY
//SYSEXEC  DD  DISP=SHR,DSN=&SYSUID..REXX
//

>< ADD NAME=BATCH$05 0100-07010-07010-2333-00009-00009-00000-KTOMIAK

//*
//STEP001 EXEC PGM=IKJEFT1B
//SYSTSPRT DD  SYSOUT=*
//SYSTSIN  DD  *
%page12   'This is one string.' These are words.
/*
//SYSEXEC  DD  DISP=SHR,DSN=&SYSUID..REXX

>< ADD NAME=BATCH$06 0100-07010-07010-2333-00031-00031-00000-KTOMIAK

//*
//* THIS SHOWS THAT COMMANDS KEEP EXECUTING
//* THE FINAL COMMAND AFFECTS THE STEP COND CODE.
//*
//STEP001 EXEC PGM=IKJEFT01
//SYSTSPRT DD  SYSOUT=*
//SYSTSIN  DD  *
%PAGE12 'THIS IS MY FIRST VARIABLE'. THIS IS ANOTHER.
%OOPS
%OOPS
%PAGE12 'THIS IS MY FIRST VARIABLE'. THIS IS ANOTHER.
%WOWZA #0
%WOWZA #1
%WOWZA #2
%WOWZA #3
%WOWZA #4
%PAGE12 'THIS IS MY FIRST VARIABLE'. THIS IS ANOTHER.
%WOWZA #5
%WOWZA #6
%WOWZA #7
%WOWZA #8
%WILL  #9
/*
//SYSEXEC  DD  DISP=SHR,DSN=&SYSUID..REXX
//SYSPROC  DD  DISP=SHR,DSN=&SYSUID..CLIST
//SYSPRINT DD  SYSOUT=*
//SYSOUT   DD  SYSOUT=*
//CEEDUMP  DD  SYSOUT=*
//SYSUDUMP DD  SYSOUT=*

>< ADD NAME=BATCH$07 0100-07010-07010-2333-00023-00023-00000-KTOMIAK

//*
//* THIS SHOWS THAT COMMANDS KEEP EXECUTING
//* THE FINAL COMMAND AFFECTS THE STEP COND CODE.
//*
//STEP001 EXEC PGM=IKJEFT1A
//SYSTSPRT DD  SYSOUT=*
//SYSTSIN  DD  *
%PAGE12 'THIS IS MY FIRST VARIABLE'. THIS IS ANOTHER.
%OOPS
%OOPS
%PAGE12 'THIS IS MY FIRST VARIABLE'. THIS IS ANOTHER.
%WOWZA
%WOWZA
/*
//STEPLIB  DD  DISP=SHR,DSN=&SYSUID..SHR.LOADLIB
//SYSEXEC  DD  DISP=SHR,DSN=&SYSUID..REXX
//SYSPROC  DD  DISP=SHR,DSN=&SYSUID..CLIST
//SYSPRINT DD  SYSOUT=*
//SYSOUT   DD  SYSOUT=*
//CEEDUMP  DD  SYSOUT=*
//SYSUDUMP DD  SYSOUT=*

>< ADD NAME=BATCH$08 0100-07010-07010-2334-00023-00023-00000-KTOMIAK

//*
//* THIS SHOWS THAT COMMANDS KEEP EXECUTING
//* THE FINAL COMMAND AFFECTS THE STEP COND CODE.
//*
//STEP001 EXEC PGM=IKJEFT1B
//SYSTSPRT DD  SYSOUT=*
//SYSTSIN  DD  *
%PAGE12 'THIS IS MY FIRST VARIABLE'. THIS IS ANOTHER.
%OOPS
%OOPS
%PAGE12 'THIS IS MY FIRST VARIABLE'. THIS IS ANOTHER.
%WOWZA
%WOWZA
/*
//STEPLIB  DD  DISP=SHR,DSN=&SYSUID..SHR.LOADLIB
//SYSEXEC  DD  DISP=SHR,DSN=&SYSUID..REXX
//SYSPROC  DD  DISP=SHR,DSN=&SYSUID..CLIST
//SYSPRINT DD  SYSOUT=*
//SYSOUT   DD  SYSOUT=*
//CEEDUMP  DD  SYSOUT=*
//SYSUDUMP DD  SYSOUT=*

>< ADD NAME=BATCH$09 0100-07010-07010-2334-00041-00041-00000-KTOMIAK

//&SYSUID.B  JOB (0700,MID),'KET.SHARE.MVSE',
//             CLASS=A,MSGCLASS=T,MSGLEVEL=(1,1),
//             NOTIFY=&SYSUID,REGION=6M,TIME=400
//*
//* CODE DSN=&SYSUID..REXX(BPXTREE)
//*
//STEP001 EXEC PGM=IKJEFT1B
//SYSTSPRT DD  SYSOUT=*
//SYSTSIN  DD  *
%BPXTREE /samples/pe
/*
//STEPLIB  DD  DISP=SHR,DSN=&SYSUID..SHR.LOADLIB
//SYSEXEC  DD  DISP=SHR,DSN=&SYSUID..REXX
//SYSPROC  DD  DISP=SHR,DSN=&SYSUID..CLIST
//         DD  DISP=SHR,DSN=SYS1.SBPXEXEC
//SYSPRINT DD  SYSOUT=*
//SYSOUT   DD  SYSOUT=*
//CEEDUMP  DD  SYSOUT=*
//SYSUDUMP DD  SYSOUT=*
//STDOUT   DD  PATH='/tmp/&SYSUID._s8324_.OUT',
//             PATHOPTS=(OCREAT,OTRUNC,OWRONLY),PATHMODE=SIRWXU
//STDERR   DD  PATH='/tmp/&SYSUID._s8324_.ERR',
//             PATHOPTS=(OCREAT,OTRUNC,OWRONLY),PATHMODE=SIRWXU
//*
//STEP002 EXEC PGM=IKJEFT1A
//JESOUT   DD  SYSOUT=*,DCB=(RECFM=V,LRECL=256)
//JESERR   DD  SYSOUT=*,DCB=(RECFM=V,LRECL=256)
//STPOUT   DD  PATH='/tmp/&SYSUID._s8324_.OUT',
//             PATHOPTS=ORDONLY
//STPERR   DD  PATH='/tmp/&SYSUID._s8324_.ERR',
//             PATHOPTS=ORDONLY
//SYSTSPRT DD  DUMMY
//SYSTSIN  DD  *
  PROF  MSGID WTPMSG
  OCOPY INDD(STPOUT) OUTDD(JESOUT)
  OCOPY INDD(STPERR) OUTDD(JESERR)
  BPXBATCH SH rm /tmp/&SYSUID._s8324_.ERR
  BPXBATCH SH rm /tmp/&SYSUID._s8324_.OUT
/*

./ ADD NAME=BMC4DB2  0666-07209-07209-1352-00001-00001-00000-DIR2UPDT
>< ADD NAME=BMC4DB2

BMCTERMU - Terminate failed utility

>< ADD NAME=BMCTERMU

//*
//        SET  DB2ID='DSN'
//        SET  UTILID='BMCREORG.TSNAME'
//*
//*
//* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
//* Terminate the named utility-identifier in the named subsystem.
//* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//BMCTERM EXEC PGM=ARUUMAIN,REGION=4M,
//             PARM='&DB2ID,&UTILID,TERM,,MSGLEVEL(1)'
//STEPLIB  DD  DISP=SHR,DSN=&DB2ID...REORGPLS.LOAD
//         DD  DISP=SHR,DSN=&DB2ID..SDSNLOAD
//SYSPRINT DD  SYSOUT=*
//SYSIN    DD  DUMMY
//*
//
//             PARM='&DB2ID,&UTILID,TERM/RESET,,MSGLEVEL(1)'
//*

./ ADD NAME=CPPUPDTE 0666-07209-07209-1453-00001-00001-00000-DIR2UPDT
>< ADD NAME=CPP      0102-07010-07016-2326-00003-00004-00000-KTOMIAK

CPP$01   CPPUPDTE used by server pac to update an entire PDS
CPP$02   IPOUPDTE used by CBPDO to update an entire PDS

>< ADD NAME=CPP$01   0100-07010-07010-2310-00023-00023-00000-KTOMIAK

//* CPPUPDTE
//CPAC    SET CPAC='some.hlq'  <== Your HLQ
//*
//STEP001 EXEC PGM=CPPUPDTE,PARM='CHECK'       PARM='UPDATE'
//STEPLIB  DD  DISP=SHR,DSN=&CPAC..OS290338.LOADLIB
//SYSPRINT DD  SYSOUT=*
//DD2      DD  DISP=SHR,DSN=<==this.pds.is.not.used
//@DD1     DD  DISP=SHR,DSN=<==a.pds.of.JCL.CNTL
//@DD3     DD  DISP=SHR,DSN=<==another.pds.of.JCL.CNTL
//SYSIN    DD  *
old.string<new.string<if.this.exists<
old.string<+
new.string<+
if.this.exists<
CICS.DEVL.SDFHLOAD<CICS.OLD.LOADLIB<<
SYS2.LOADLIB<SYS2.OUTDATED.LOADLIB<+
DSN=<
/*
//

Beware what you ask for. DSN= is not the same as DSNAME=.

>< ADD NAME=CPP$02   0100-07010-07010-2313-00007-00007-00000-KTOMIAK

IOUPDTE is Deprecated!

If you still have the loadlib, get rid of it. Switch over to
CPPUPDTE.

./ ADD NAME=CUNMITG1 0666-07209-07209-1506-00001-00001-00000-DIR2UPDT
>< ADD NAME=UNI      0100-07021-07021-2310-00003-00003-00000-KTOMIAK

UNI$01  shows mapping for common mainframe unicode types

>< ADD NAME=UNI$01   0100-07021-07021-2311-00051-00051-00000-KTOMIAK

//*******************************************************************
//*                                                                 *
//* ...EXEC  PGM=CUNMITG1,PARM='FROM-CCSID,TO-CCSID,TECHNIQUE'      *
//*                                                                 *
//*                                                                 *
//* NOTE THAT VALID KNOWLEDGE BASE ENTRIES MUST EXIST FOR BOTH      *
//* FROM-CCSID AND TO-CCSID                                         *
//*                                                                 *
//* THE TABLE MUST BE PRESENT AS A MEMBER OF THE TABIN DD           *
//* CONCATENATION. THE SAME NAMING CONVENTIONS APPLY AS FOR JOB     *
//* CUNJIUTL                                                        *
//*                                                                 *
//* THE CHARACTER MAP IS WRITTEN TO CHAROUT WHICH MUST BE A FB 80   *
//* DATASET.                                                        *
//*******************************************************************



//*
//STEP001 EXEC PGM=CUNMITG1,PARM=(37,850,R)
//SYSPRINT DD  DUMMY
//TABIN    DD  DISP=SHR,DSN=SYS1.SCUNTBL
//CHAROUT  DD  SYSOUT=*
//*******************************************************************
//STEP002 EXEC PGM=CUNMITG1,PARM=(850,1047,R)
//SYSPRINT DD  DUMMY
//TABIN    DD  DISP=SHR,DSN=SYS1.SCUNTBL
//CHAROUT  DD  SYSOUT=*
//*******************************************************************
//STEP003 EXEC PGM=CUNMITG1,PARM=(1047,37,R)
//SYSPRINT DD  DUMMY
//TABIN    DD  DISP=SHR,DSN=SYS1.SCUNTBL
//CHAROUT  DD  SYSOUT=*
//
















./ ADD NAME=DFHCSDUP 0666-07209-07209-1454-00001-00001-00000-DIR2UPDT
>< ADD NAME=DUP      0102-07021-07021-2248-00005-00009-00000-KTOMIAK

DUP$01    Allocate and initialize a csd
DUP$02    LIST contents of the csd
DUP$03    Add a console
DUP$04    Add a tso userid for console commands
DUP$05    Copy groups from one csd to another
DUP$06    Add group to initial list
DUP$07    Change an existing FILE entry, TDQUEUE

>< ADD NAME=DUP$01   0100-07021-07021-2234-00037-00037-00000-KTOMIAK

//*
//* ALLOCATE A NEW CLUSTER FOR THE CSD
//*
//DEFCSD  EXEC PGM=IDCAMS,REGION=1M
//SYSPRINT DD  SYSOUT=*
//SYSIN    DD  *
  DEFINE CLUSTER( -
    NAME(CICSHLQ.DFHCSD) -
      INDEXED -
      CYL(20 2) -
      RECORDSIZE(100 500) -
      FREESPACE(5 5) -
      VOLUME(CICVOL) -
      SHR(2)) -
    DATA(NAME(CICSHLQ.DFHCSD.DATA) -
      UNIQUE -
      KEYS(22 0)) -
    INDEX(NAME(CICSHLQ.DFHCSD.INDEX) -
      UNIQUE)
/*
//*
//IFCSD    IF  (DEFCSD.RC = ) THEN
//*
//* INITIALIZE THE CSD
//*
//INITCSD EXEC PGM=DFHCSDUP,REGION=1M
//STEPLIB  DD  DISP=SHR,DSN=CICS530.SDFHLOAD
//DFHCSD   DD  DISP=SHR,DSN=CICSHLQ.DFHCSD
//SYSUT1   DD  UNIT=SYSDA,SPACE=(1024,(100,100))
//SYSPRINT DD  SYSOUT=*
//SYSIN    DD  *
  INITIALIZE
/*
//IFCSD  ENDIF
//

>< ADD NAME=DUP$02   0100-07021-07021-2236-00011-00011-00000-KTOMIAK

//*
//CONSDEF EXEC PGM=DFHCSDUP
//STEPLIB  DD  DISP=SHR,DSN=CICS530.SDFHLOAD
//DFHCSD   DD  DISP=SHR,DSN=CICSHLQ.DFHCSD
//SYSPRINT DD  SYSOUT=*
//SYSIN    DD  *
  LIST ALL OBJECT
/*
//

>< ADD NAME=DUP$03   0102-07021-07021-2244-00018-00018-00000-KTOMIAK

//*
//CONSDEF EXEC PGM=DFHCSDUP
//STEPLIB  DD  DISP=SHR,DSN=CICS530.SDFHLOAD
//DFHCSD   DD  DISP=SHR,DSN=CICSHLQ.DFHCSD
//SYSPRINT DD  SYSOUT=*
//SYSIN    DD  *
*
* DEFINE A CONSOLE FOR CICS
*
  DEFINE   TERMINAL(MVKX)
           GROUP(TECHGRP)
           TYPETERM(DFHCONS)
           CONSNAME(MVSCICS1)
           DESCRIPTION(MVS CONSOLE CONSNAME)
/*
//

>< ADD NAME=DUP$04   0103-07021-07021-2245-00019-00036-00000-KTOMIAK

//*
//USERDEF EXEC PGM=DFHCSDUP
//STEPLIB  DD  DISP=SHR,DSN=CICS530.SDFHLOAD
//DFHCSD   DD  DISP=SHR,DSN=CICSHLQ.DFHCSD
//SYSPRINT DD  SYSOUT=*
//SYSIN    DD  *
*
* DEFINE A TSO USER AS A CONSOLE DEVICE FOR CICS
*
  DEFINE   TERMINAL(TRMIDNT)
           GROUP(GRPNAME)
           TYPETERM(DFHCONS)
           CONSNAME(TSOUSER)
           DESCRIPTION(TSO USER TSOUSER)
           USERID(TSOUSER)
/*
//

*
*
*
  DEFINE   TERMINAL(KTOC)
           GROUP(MDLCONS)
           TYPETERM(DFHCONS)
           AUTINSTMODEL(NO)
           NETNAME(KTOMIAK)
           CONSNAME(KTOMIAK)
           NATLANG(E)
           DESCRIPTION(TSO USER KEN TOMIAK)
           USERID(KTOMIAK)
*




>< ADD NAME=DUP$05   0101-07021-07021-2247-00013-00013-00000-KTOMIAK

//*
//CPYCSD  EXEC PGM=DFHCSDUP
//STEPLIB  DD  DISP=SHR,DSN=CICS530.SDFHLOAD
//DFHCSD   DD  DISP=SHR,DSN=C530HLQ.DFHCSD
//OLDCSD   DD  DISP=SHR,DSN=C530HLQ.OLD.DFHCSD
//SYSPRINT DD  SYSOUT=*
//SYSIN    DD  *
  COPY GROUP(TECHGRP ) TO(TECHGRP ) FROM(OLDCSD)
  COPY GROUP(MDLCONS ) TO(MDLCONS ) FROM(OLDCSD)
/*
//

>< ADD NAME=DUP$06   0101-07021-07021-2246-00012-00013-00000-KTOMIAK

//*
//CPYCSD  EXEC PGM=DFHCSDUP
//STEPLIB  DD  DISP=SHR,DSN=CICS530.SDFHLOAD
//DFHCSD   DD  DISP=SHR,DSN=C530HLQ.DFHCSD
//SYSPRINT DD  SYSOUT=*
//SYSIN    DD  *
  ADD GROUP(TECHGRP ) LIST(STRTLTS)
  ADD GROUP(MDLCONS ) LIST(STRTLTS)
/*
//

  REMOVE GROUP(MDLCONS ) LIST(STRTLTS)
>< ADD NAME=DUP$07   0102-07021-07021-2250-00012-00023-00000-KTOMIAK

//*
//ALTFILE EXEC PGM=DFHCSDUP
//STEPLIB  DD  DISP=SHR,DSN=CICS530.SDFHLOAD
//DFHCSD   DD  DISP=SHR,DSN=C530HLQ.DFHCSD
//SYSPRINT DD  SYSOUT=*
//SYSIN    DD  *
*
* ALTER THE DATASET NAME OF A FILE
  ALTER FILE(MYAPPFLE) GROUP(TECHGRP)
    DSNAME(NEWHLQ.MYAPP.VSAMFILE)
*
* FIX ATTRIBUTES OF A TDQUEUE
*
  ALTER
    TDQUEUE(JESO)
    GROUP(TECHDCTP)
    RECORDSIZE(147)
    RECORDFORMAT(VARIABLE)
    BLOCKFORMAT(BLOCKED)
/*
//

./ ADD NAME=DITTO    0666-07209-07209-1402-00001-00001-00000-DIR2UPDT
>< ADD NAME=DIT

DIT$01 - Copy an entire tape to another tape

>< ADD NAME=DIT$01

//STEP010 EXEC PGM=DITTO
//SYSPRINT DD  SYSOUT=*
//IN       DD  DISP=OLD,DSN=ANY1,
//             UNIT=cart,VOL=SER=input1,
//             LABEL=(1,BLP)
//OUT      DD  DISP=(NEW,KEEP),DSN=ANY2,
//             UNIT=cart,VOL=SER=output,
//             LABEL=(1,BLP)
//SYSIN    DD  *
$$DITTO TT  INPUT=IN,OUTPUT=OUT,NFILES=EOT
/*
//*
//
./ ADD NAME=DSNTEP2  0666-07209-07209-1505-00001-00001-00000-DIR2UPDT
>< ADD NAME=TEP2     0102-07003-07021-2253-00004-00005-00000-KTOMIAK

TEP2$01  A simple SELECT using defaults
TEP2$02  A complex CREATE overriding defaults
TEP2$03  Some tips for writing SQL

>< ADD NAME=TEP2$01  0100-07003-07003-2114-00026-00026-00000-KTOMIAK

Example 1: A simple SELECT using defaults

//*
//STEP001 EXEC PGM=IKJEFT1B,PARM='',
//             REGION=18M,TIME=1400
//SYSTSPRT DD  SYSOUT=*
//SYSTSIN  DD  *
  DSN SYSTEM(DB2D)
    RUN PROGRAM(DSNTEP2) PLAN(DSNTEP2) +
      LIB('DSN1.RUNLIB.LOAD') +
      PARMS('ALIGN(MID)')
    END
/*
//SYSIN    DD  *
-- a comment
*  another comment
  SELECT SUBSTR(
    STRIP(CREATOR) || '.' || NAME,1,27)
    FROM SYSIBM.SYSTABLES TB
    WHERE TB.TYPE = 'V'
  ;
//SYSPRINT DD  DISP=(MOD,CATLG),DSN=&SYSUID..DSN1.DSNTEP2.OUT,
//             UNIT=SYSALLDA,SPACE=(TRK,(15,15),RLSE),
//             DCB=(DSORG=PS,RECFM=FBA,BLKSIZE=0,LRECL=133)

>< ADD NAME=TEP2$02  0100-07003-07003-2114-00033-00033-00000-KTOMIAK

Example 2: A complex CREATE overriding defaults

//*
//STEP001 EXEC PGM=IKJEFT1B,PARM='',
//             REGION=18M,TIME=1400
//SYSTSPRT DD  SYSOUT=*
//SYSTSIN  DD  *
  DSN SYSTEM(DB2D)
    RUN PROGRAM(DSNTEP2) PLAN(DSNTEP2) +
      LIB('DSN1.RUNLIB.LOAD') +
      PARMS('ALIGN(LHS)')
    END
/*
//SYSIN    DD  *
-- a comment
*  another comment
--#SET TERMINATOR #
    CREATE TRIGGER NEW_HIRE
      AFTER INSERT ON EMP
      FOR EACH ROW MODLE DB2SQL
      BEGIN ATOMIC
        UPDATE COMPANY_STATS SET NBEMP = NBEMP + 1 ;
    END#
--#SET ROWS_FETCH 12
    Select * from SYSIBM.SYSCOLUMNS #
--#SET ROWS_OUT 10
--#SET TERMINATOR ;
    Select * from SYSIBM.SYSCOLUMNS ;
//SYSPRINT DD  DISP=(MOD,CATLG),DSN=&SYSUID..DSN1.DSNTEP2.OUT,
//             UNIT=SYSALLDA,SPACE=(TRK,(15,15),RLSE),
//             DCB=(DSORG=PS,RECFM=FBA,BLKSIZE=0,LRECL=133)

>< ADD NAME=TEP2$03  0100-07021-07021-2252-00018-00018-00000-KTOMIAK

COUNT(*) returns a count of all rows that qualify against the WHERE
clause.

COUNT(colname) returns a count of all rows that qualify against the
WHERE clause, with null occurrences of colname removed.

COUNT(DISTINCT colname) counts distinct occurrences of colname, with
nulls removed.

Comparison operators:
 <>
 <=
 =>
 =
 LIKE
 IN

./ ADD NAME=DSNTIAD  0666-07209-07209-1506-00001-00001-00000-DIR2UPDT
>< ADD NAME=TIAD     0101-07003-07017-0016-00003-00003-00000-KTOMIAK

TIAD$01  Update a table

>< ADD NAME=TIAD$01  0100-07003-07003-2114-00020-00020-00000-KTOMIAK

Example 1: Update a table

//*   PARMS=('RC0') ALLOWS IT TO KEEP RUNNING IF ERRORS OCCUR
//*
//STEP001 EXEC PGM=IKJEFT1B,PARM='',
//             REGION=18M,TIME=1400
//SYSTSPRT DD  SYSOUT=*
//SYSTSIN  DD  *
  DSN SYSTEM(DSN1)
    RUN PROGRAM(DSNTIAD) PLAN(DSNTIAD) +
      LIB('DSN1.RUNLIB.LOAD') PARMS('RC0')
    END
/*
//SYSPRINT DD  SYSOUT=*
//SYSIN    DD  *
UPDATE DSN8710.PROJECT SET DEPTNO='J01' WHERE DEPTNO='A01';
UPDATE DSN8710.PROJECT SET DEPTNO='K01' WHERE DEPTNO='B01';
/*

./ ADD NAME=DSNTIAUL 0666-07209-07209-1506-00001-00001-00000-DIR2UPDT
>< ADD NAME=TIAUL    0101-07003-07017-0017-00005-00005-00000-KTOMIAK

TIAUL$01  Unload one table
TIAUL$02  Unload two tables
TIAUL$03  Unload data from an SQL select

>< ADD NAME=TIAUL$01 0100-07003-07003-2114-00024-00024-00000-KTOMIAK

Example 1: Unload one table

//*
//STEP001 EXEC PGM=IKJEFT1B,PARM='',
//             REGION=18M,TIME=1400
//SYSTSPRT DD  SYSOUT=*
//SYSTSIN  DD  *
  DSN SYSTEM(DSN1)
    RUN PROGRAM(DSNTIAUL) PLAN(DSNTIAUL) +
      LIB('DSN1.RUNLIB.LOAD')
    END
/*
//SYSPRINT DD  SYSOUT=*
//SYSIN    DD  *
DSN8710.PROJ ;
DSN8710.EMP
/*
//SYSPUNCH DD  DISP=(NEW,CATLG,DELETE),DSN=&SYSUID..LOAD.PROJ,
//             UNIT=disk,SPACE=(TRK,(750,75),RLSE),
//             DCB=(RECFM=FB,BLKSIZE=0,LRECL=80)
//SYSREC00 DD  DISP=(NEW,CATLG,DELETE),DSN=&SYSUID..UNLOAD.PROJ,
//             UNIT=disk,SPACE=(TRK,(750,75),RLSE)

>< ADD NAME=TIAUL$02 0100-07003-07003-2114-00031-00031-00000-KTOMIAK

Example 2: Unload two tables

//*
//STEP001 EXEC PGM=IKJEFT1B,PARM='',
//             REGION=18M,TIME=1400
//SYSTSPRT DD  SYSOUT=*
//SYSTSIN  DD  *
  DSN SYSTEM(DSN1)
    RUN PROGRAM(DSNTIAUL) PLAN(DSNTIAUL) +
      LIB('DSN1.RUNLIB.LOAD')
    END
/*
/*
//SYSPRINT DD  SYSOUT=*
//SYSIN    DD  *   DISP=SHR,DSN=&SYSUID..$SQL.TEXT(TIAUL001)
DSN8710.PROJ ;
DSN8710.EMP
/*
//SYSPUNCH DD  DISP=(NEW,CATLG,DELETE),DSN=&SYSUID..LOAD.PROJ,
//             FREE=CLOSE,
//             UNIT=disk,SPACE=(TRK,(750,75),RLSE),
//             DCB=(RECFM=FB,BLKSIZE=0,LRECL=80)
//SYSREC00 DD  DISP=(NEW,CATLG,DELETE),DSN=&SYSUID..UNLOAD.PROJ,
//             UNIT=disk,SPACE=(TRK,(750,75),RLSE)
//SYSPUNCH DD  DISP=(NEW,CATLG,DELETE),DSN=&SYSUID..LOAD.EMP,
//             UNIT=disk,SPACE=(TRK,(750,75),RLSE),
//             DCB=(RECFM=FB,BLKSIZE=0,LRECL=80)
//SYSREC01 DD  DISP=(NEW,CATLG,DELETE),DSN=&SYSUID..UNLOAD.EMP,
//             UNIT=disk,SPACE=(TRK,(750,75),RLSE)

>< ADD NAME=TIAUL$03 0100-07003-07003-2114-00036-00036-00000-KTOMIAK

Example 3: Unload data from an SQL select

As long as you don't select more than 254 characters you will
create a record with just your data. Reach 255 or more characters
and DB2 treats it as a variable length field, inserting a two
byte field with the data length ahead of the actual data.

//*
//STEP001 EXEC PGM=IKJEFT1B,PARM='',
//             REGION=18M,TIME=1400
//SYSTSPRT DD  SYSOUT=*
//SYSTSIN  DD  *
  DSN SYSTEM(DSN1)
    RUN PROGRAM(DSNTIAUL) PLAN(DSNTIAUL) +
      LIB('DSN1.RUNLIB.LOAD') PARMS('SQL')
    END
/*
//SYSPRINT DD  SYSOUT=*
//SYSIN    DD  *
  SELECT SUBSTR(
    STRIP(CREATOR) || '.' || NAME,1,27)
    FROM SYSIBM.SYSTABLES TB
    WHERE TB.TYPE = 'V'
  ;
  SELECT CHAR('SELECT * FROM ' ||
    CREATOR || NAME || ' ;')
    FROM SYSIBM.SYSTABLES TB
    WHERE TB.TYPE = 'V'
  ;
/*
//SYSPUNCH DD  DUMMY
//SYSREC00 DD  DISP=(NEW,CATLG,DELETE),
//             DSN=&SYSUID..DSNTIAUL.SELECT.SYSTABLS,
//             UNIT=disk,SPACE=(TRK,(750,75),RLSE)

./ ADD NAME=EDGINERS 0666-07209-07209-1457-00001-00001-00000-DIR2UPDT
>< ADD NAME=INERS    0101-07003-07016-2346-00007-00007-00000-KTOMIAK

The EDGINERS utility of DFSMSrmm is recommended instead of IEHINITT for
labeling tapes that reside both inside and outside IBM TotalStorage
Enterprise Automated Tape Library (3495)s.

INERS$01  Write EBCDIC Labels on Three Tapes

>< ADD NAME=INERS$01 0100-07003-07003-2114-00012-00012-00000-KTOMIAK

//*
//S01#01  EXEC PGM=EDGINERS
//SYSPRINT DD  SYSOUT=*
//SYSUT2   DD  SYSOUT=*
//TAPE     DD  UNIT=207
//SYSIN    DD  *
         INIT VOLUME(C10269) LABEL(SL)
         INIT VOLUME(C10270) LABEL(SL)
         INIT VOLUME(C10271) LABEL(SL)
/*

./ ADD NAME=FDR      0666-07209-07209-1455-00001-00001-00000-DIR2UPDT
>< ADD NAME=FDR      0101-07010-07016-2327-00027-00027-00000-KTOMIAK

Innovation: FDR

Simulation
It is possible and advisable to test all jobs by using
the SIM statement. This will run through the  process
and report on what action would be taken, without moving any
data. To simulate a compakt job you simply replace the CPK
statement with SIM, so in the example below:

CPK DUMP=YES,VOL=V03904,SIZEKEEP=0,
would become
SIM DUMP=YES,VOL=V03904,SIZEKEEP=0,


FDR$01  Disk mapping
FDR$02  Compacting
FDR$03  Fast compact
FDR$04  Mess with VTOC, VTOIX, VVDS using data from a backup
FDR$05  Reports
FDR$06  ABR Reports
FDR$07  Backup by using DFSMS Storagepools
FDR$08  Move entire volume
FDR$09  Copy datasets
FDR$10  Move datasets


>< ADD NAME=FDR$01   0100-07010-07010-1842-00033-00033-00000-KTOMIAK
Disk mapping
The MAP statement will map out the track locations on disk volumes,
or from full FDR backups of disk volumes. You can either map individual
volumes, or all the volumes in an SMS storage pool with a single control
statement. These reports were very useful if you had a faulty track on
an old disk and you wanted to know exactly which dataset was goosed.
A CPK MAP will report on any VTOC errors or inconsistencies that it
finds. Also the summary report provides some useful information on
the state of the disks and the datasets thereon. Sample JCL is


Map using a live dasd volume

//STEP1    EXEC PGM=FDRCPK
//SYSPRINT DD SYSOUT=*
//SYSUDUMP DD SYSOUT=*
//SYSIN    DD *
  MAP   VOL=volser
or
 STORGRP=poolname


Map using a backup as input


//STEP1    EXEC PGM=FDRCPK
//SYSPRINT DD SYSOUT=*
//TAPE1    DD DISP=OLD,DSN=FDRABR.Vvolser.C1014200
//SYSUDUMP DD SYSOUT=*
//SYSIN    DD *
  MAP   FROMDD=TAPE1
/*

>< ADD NAME=FDR$02   0100-07010-07010-1844-00017-00017-00000-KTOMIAK


This sample JCL will leave 10% of free space in all files for growth
and release the rest, unless the file is allocated without secondary
extents, in which case it is not processed

//CPKRLSE EXEC PGM=FDRCPK,REGION=0M
//SYSPRINT DD SYSOUT=*
//SYSMAP DD SYSOUT=*
//SYSSUMM DD SYSOUT=*
//SYSUDUMP DD SYSOUT=*
//SYSIN DD *
COMPAKT TYPE=RLSE,VOL=(TSO*,TEST*),
PSRLSE=ALL,PORLSE=ALL,VSRLSE=ALL,NOSECOND=NORLSE,%FREE=10
/*
//

>< ADD NAME=FDR$03   0100-07010-07010-1844-00044-00044-00000-KTOMIAK

A FASTCPK of a disk should take less than 3 minutes, compared to the
10 minutes for the full CPK. With FASTCPK you are processing active
volumes. FASTCPK works and is very effective, but you need to make
sure you understand the implications of working on active volumes
before you start. Be aware that some system utilities read the VTOC
once to find their data, then access that data directly from its
track location. This means that if you move the datasets with the
utility active, it loses its files and crashes. Utilities that
spring to mind are IMS and CICS. I tend to be nervous about the
entire utility, but it is probably just the journals that are the
problem. In this example, LOG=YES means that FDRCPK will issues
messages to the SYSLOG to keep the operators informed of progress.
FASTCPK will always write a recovery log so you can recover
automatically from operating system or the job fails.
UNABLE=IGNORE means ignore recoverable errors. The
SELECT DSN=..,POS=KEEP
statements mean that FDRCPK will not attempt to move files fitting
these patterns. This is one way to avoid unmovable datasets.
By default, a FASTCPK will use DSNENQ=USE, which means that it
will attempt to get exclusive use of all files on the disk, and
will exclusively hold those files it gets until the end of the
job. Compaktor will not try to move files that are in use. You
may think that this will resolve issues with direct access files,
because if those files were in use then they would be ENQd and
Compaktor could not move them. However, applications like IMS
and CICS have a habit of holding journal files without an ENQ,
so this is not an assured way to avoid problems. You need to
ensure that Compakt does not move these files as shown in the
example below. Some sample JCL for a compakt of a single volume

//STEP1    EXEC PGM=FDRCPK
//SYSPRINT DD SYSOUT=*
//SYSUDUMP DD SYSOUT=*
//SYSIN    DD *
  CPK   TYPE=FASTCPK,VOL=volser,
     LOG=YES,UNABLE=IGNORE
  SELECT   DSN=CICP.**,POS=KEEP
  SELECT   DSN=HSM.**,POS=KEEP
  SELECT   DSN=MVS.**,POS=KEEP




>< ADD NAME=FDR$04   0100-07010-07010-1846-00045-00045-00000-KTOMIAK

If you have errors in your VTOC then FDRCPK will automatically
fix them. You can also use FDRCPK to increase the size of the
VTOC, VVDS or VTOC Index, but you need a full dump compakt for
this so you must specify DUMP=YES in your control statements
Sample JCL

//COMPAKT EXEC PGM=FDRCPK
//SYSPRINT DD SYSOUT=*
//SYSMAP DD SYSOUT=*
//SYSUDUMP DD SYSOUT=*
//TAPE1 DD UNIT=CART,DISP=(,CATLG),
//            DSN=DMB.V03904,VOL=(,,,99)
//SYSIN DD *
DUMP TYPE=FDR,DATA=USED,DSNENQ=USE
 CPK DUMP=YES,VOL=V03904,SIZEKEEP=0,
 VTOC=COMPAKT,OVERRIDE=YES
SELECT ***VTOC,SIZE=40,POS=BEGIN
SELECT DSN=SYS1.VTOCIX.**,POS=VTOC
SELECT DSN=SYS1.VVDS.**,POS=VTOC

If your VVDS is in multiple extents it can cause performance
problems. You can consolidate your VVDS into a single extent
with FDRCPK, but you need to use the override parameter as
FDRCPK considers a VVDS as unmovable. You need exclusive use
of the VVDS to do this, so it is safest to vary the disk
offline to any other sharing LPARS before running the job.
Sample JCL would be

//COMPAKT EXEC PGM=FDRCPK
//SYSPRINT DD SYSOUT=*
//SYSMAP DD SYSOUT=*
//SYSUDUMP DD SYSOUT=*
//TAPE1 DD UNIT=CART,DISP=(,CATLG),
//            DSN=DMB.V03904,VOL=(,,,99)
//SYSIN DD *
DUMP TYPE=FDR,DATA=USED,DSNENQ=USE
 CPK DUMP=YES,VOL=V03904,SIZEKEEP=0,
SELECT DSN=SYS1.VVDS.**,POS=VTOC,OVERRIDE=YES






>< ADD NAME=FDR$05   0100-07010-07010-1849-00126-00126-00000-KTOMIAK

This is a report that I use if a storage pool is running out of
space. It will report on old data in a storage pool giving its
last referenced data and the SMS management class. You will
need to adjust the Julian date in the LRDATE exclusion clause
to get the data that you are interested in.

//REPORT   EXEC PGM=FDREPORT,REGION=0M
//SYSPRINT DD SYSOUT=*
//ABRMAP   DD SYSOUT=*
//ABRSUM   DD SYSOUT=*
//SYSIN    DD *
 XSELECT STORGRP=poolname
 XEXCLUDE LRDATE<05.210
 REPORT FIELD=(DSN,CLUSTER,LRDATE,VOL,MGMTCLAS,SIZEINFO)
 SORT    FIELD=(LRDATE)
 PRINT
//

The report is sorted by last referenced data so older data is
more obvious. The 'xselect' and 'exclude' parameters give you
a lot of flexibility in selecting files or disks. As an example,

XSELECT XDSN=INP/.|+AB*.**,vol=P+*

will select datasets with a high level qualifier starting INP
that is exactly four characters long (the / represents any one
character), the second qualifier starts with any alphabetic
character (|) then any numeric character (+) then exactly 'AB'
then anything that pads the second qualifier out to a maximum
of eight characters. Finally, the '**' means any valid set of
characters and levels up to the maximum allowed by z/OS. So
INP2.A6ABZ#.UNIT.TEST will be selected, while INP.ARABZ#.UNIT.TEST
will not be selected (because the HLQ has only three characters
and because character 2 in the second qualifier is not numeric).
XSELECT also works on volumes. VOL=/AB* means select any volume
starting with an alphabetic character, with the second and
third characters 'AB'. The next report looks at a problem
storage pool from the other angle. It lists out all data that
was created today. It is useful to know this if a pool suddenly
starts running out of space because it can tell you who to
blame. The 'SIZEINFO' parameter will list out the SIZE of
each file in tracks and also SIZEFREE and percentage free.
You can specifically ask for the size in bytes if you want.
I am excluding various system files and also the
XEXCLUDE XDSN=**.INDEX, DSORG=EF parameter will exclude
all VSAM files that end in .INDEX. The reason for this is
that these files never get their update bit set, so they
will clog up the report.

//SYSIN    DD *
 XSELECT STORGRP=(LNVLRGPD),CRDATE.EQ.2005118
 XEXCLUDE XDSN=**VTOC
 XEXCLUDE XDSN=**ABR
 XEXCLUDE XDSN=SYS1
 XEXCLUDE XDSN=FDRABR.**
 XEXCLUDE XDSN=**.INDEX, DSORG=EF
 REPORT FIELD=(DSN,SIZEINFO,MGMTCLAS)
 PRINT  DATEFORMAT=DDMMYYYY
 SORT   FIELD=DSN

VSAM reports
If you want to know these things, then FDReport will tell
you about VSAM clusters  that have a high number of CA and
CI splits, or that are on an excessive number of extents.
For example this report will list out problem VSAM files
that have more than 80 extents, OR more that 50 CA splits,
OR more than 100 CI splits.

XSELECT XDSN=(AXP.**,AYP.**,CIT.**),DSORG=EF,VOL=/P*,NOEPV.GT.80
XSELECT XDSN=(AXP.**,AYP.**,CIT.**),DSORG=EF,VOL=/P*,CASPLIT.GT.50
XSELECT XDSN=(AXP.**,AYP.**,CIT.**),DSORG=EF,VOL=/P*,CISPLIT.GT.100
REPORT FIELD=(CLUSTER,DSN,VOL,CASPLIT,CISPLIT,CISIZE,CICA,NOEPV)
SORT FIELD=(CLUSTER,DSN)
PRINT ENABLE=AUTOSTACK,SORTALLOC=YES

HSM Migration reports
FDReport will report on both its own FDRABR migration and
also on DFHSM Migration. See the DFHSM section for details
on DFHSM. The report below is reading the DFHSM MCDS. This
is specified in the MCDSDD DD name. It will report on all
migrated datasets with a high qualifier of DRP, and will
tell you how big the file is, which volume it was on, the
date it was migrated and the number of days since migrated.
It will also tell you how many times each file has been
migrated (NTMIGRAT, useful to detect thrashing) the
management class, and finally 'DSSN' will tell you which
migration level the file is on

//MCDSDD   DD DISP=SHR,DSN=your.mcds.name
//SYSIN    DD *
 TITLE     LINE='HSM INFO'
 XSELECT   XDSN=DRP.**
 REPORT FIELD=(DSN,VOL,SIZE,ADATE,NTMIGRAT,ADAYS,DSSN,MGMTCLAS)
 PRINT DATATYPE=MCDS

Here's an example of an FDReport that I used to increase the
retention of datasets that were already migrated by DFHSM.
The customer wanted all her XVN.PROD files that already have
a five year retention retained for 10 years instead. This
meant building a list of all migrated files with a specific
management class and changing that class. FDReport will find
the files for you, then build the control statements to
change the management class. The PUNCH statement tell
FDReport to format an output list. The <NAME> bit in the
ALTER statement is a system variable that will substitute
the database name. A courageous person would run this job with
the SYSPUNCH file feeding straight into a second IDCAMS step
to just change the classes, but I prefer to check the output
first then run the changes later.

//REPORT   EXEC PGM=FDREPORT,REGION=0M
//SYSPRINT DD SYSOUT=*
//SYSPUNCH DD DSN=YOUR.OUTPUT.FILE,DISP=OLD
//MCDSDD   DD DISP=SHR,DSN=YOUR.MCDS
//ABRMAP   DD SYSOUT=*
//ABRSUM   DD SYSOUT=*
//SYSIN    DD *
 XSELECT   XDSN=XVN.PROD.**,MGMTCLAS=YEAR5
  REPORT FIELD=(DSN,MGMTCLAS)
 PUNCH  FDRLIB=MASK
 PRINT  RPTYPE=SELPCH,DATATYPE=MCDS
//MASK     DD  *
 ALTER <NAME> MGMTCLAS(YEAR10)


>< ADD NAME=FDR$06   0100-07010-07010-1850-00019-00019-00000-KTOMIAK

ABR Backup reports
You can report on available ABR backups for any dataset,
disk or storage pool. The example below will list out all
backups for storage pool 'CICSPROD', giving you the creation
data, generation and cycle numbers, and also the tape volser
and file sequence number

//REPORT   EXEC PGM=FDREPORT,REGION=0M
//SYSPRINT DD SYSOUT=*
//ABRMAP   DD SYSOUT=*
//ABRSUM   DD SYSOUT=*
//SYSIN    DD *
 XSELECT STORGRP=CICSPROD
 REPORT FIELD=(VOL,CRDATE,BKGEN,BKCYCLE,BKVOL,BKFILENO)
 PRINT
/*
//

>< ADD NAME=FDR$07   0100-07010-07010-1851-00035-00035-00000-KTOMIAK

if you use SMS, then backup by storagepool. Example JCL is

//STEP1    EXEC PGM=FDRABR
//TAPE1    DD DSN=&&TEMP,UNIT=3590,DISP=(MOD,KEEP)
//SYSPRINT DD SYSOUT=*
//SYSPRIN1 DD SYSOUT=*
//SYSUDUMP DD SYSOUT=*
//SYSIN    DD *
  DUMP     TYPE=FDR,DSNENQ=USE,ENQERR=NO
  MOUNT    VOL=volser
  MOUNT    STORGRP=poolname

If you are backing up a large storage pool, you can use
multiple TAPE DD statements so you write to more than
one tape drive concurrently. If you do this, then every
TAPEx statement must have matching SYSPRINx statement

//TAPE1    DD DSN=&&TEMP,UNIT=3590,DISP=(MOD,KEEP)
//TAPE2    DD DSN=&&TEMP,UNIT=3590,DISP=(MOD,KEEP)
//SYSPRINT DD *
//SYSPRIN1 DD SYSOUT=*
//SYSPRIN2 DD SYSOUT=*












>< ADD NAME=FDR$08   0100-07010-07010-1852-00015-00015-00000-KTOMIAK

If you want to move a complete volume from one address to
another, it is easiest to do this with PGM=FDR combined
with the COPY STATEMENT. Sample JCL is

//COPY       EXEC  PGM=FDR,REGION=0M
//SYSPRINT    DD   SYSOUT=*
//SYSPRIN1    DD   SYSOUT=*
//SYSUDUMP    DD   SYSOUT=*
//DISK1       DD   UNIT=3390,DISP=OLD,VOL=SER=SOURCE
//TAPE1      DD   UNIT=3390,DISP=OLD,VOL=SER=TARGET
//SYSIN      DD   *
    COPY     TYPE=FDR,CPYVOLID=YES,CONFMESS=NO
/*

>< ADD NAME=FDR$09   0100-07010-07010-1853-00035-00035-00000-KTOMIAK

Copying datasets with FDRCOPY
PGM=FDRCOPY has two options, MOVE and COPY, which should
be self explanatory. To take a copy of a file called
ISP.ACCTS.TSAD.INPUT run the following job

//STEP1    EXEC PGM=FDRCOPY
//SYSPRINT DD SYSOUT=*
//SYSUDUMP DD SYSOUT=*
//SYSIN    DD *
 COPY  TYPE=DSF
 SELECT CATDSN=ISP.ACCTS.TSAD.INPUT,
   NEWNAME=ISP.ACCTS.TSAD.INPUT.COPY


This will move all datasets (except system files like
the VTOC, VTOCIX, VVDS and ABR initialisation dataset)
from volume DA1245 to volume DA4567. You need to
specify an output volume, but if the data is SMS
managed, SMS will intervene and pick its own target
disks.














>< ADD NAME=FDR$10   0100-07010-07010-1854-00012-00012-00000-KTOMIAK

To drain an SMS managed volume DA1245, change
its SMS status to DISNEW, then run the following job

//STEP1    EXEC PGM=FDRCOPY
//SYSPRINT DD SYSOUT=*
//SYSUDUMP DD SYSOUT=*
//SYSIN    DD *
 MOVE      TYPE=DSF
 SELECT    ALLDSN,VOL=DA1245,NVOL=DA4567
/*

./ ADD NAME=FTP      0666-07209-07209-1455-00001-00001-00000-DIR2UPDT
>< ADD NAME=FTP      0104-07003-07112-1824-00003-00050-00000-KTOMIAK

FTP$01    A whole bunch of things you might be able to do
FTP$02    Sample NETRC used by FTP
FTP$03    Sample SYSFTPD from SEZAINST.
FTP$04    Using a DDNAME as input
FTP$05    Using NUM ON, yes you can! And continuation character.

The record length and block size of the output data set can be any size.
If the logical record length of the output data set is less than 100
bytes, some messages could be truncated or wrapped around to the next
line. If you create INPUT and OUTPUT data sets, use the following
guidelines:

//INPUT
= Specify the INPUT data set:
- Record format=FB.
- Logical record length=2080. The logical record length of the input
  data set can be any value in the range 80-2080.
- Block size is a multiple of logical record length.

//OUTPUT is the real DDname to use, it will also accept //SYSPRINT
= Specify the OUTPUT data set:
- Record format=FB.
- Logical record length=160.
- Block size is a multiple of 160.

//NETRC
= NETRC data set can be via DD or a z?OS UNIX file
The user_id.NETRC data set (/$HOME/.netrc, in z/OS UNIX) provides you
with an alternative to specifying your user_id and password as FTP
parameters when you want to FTP to a remote host. The following example
shows you how to specify the user_id.NETRC data set:

machine mvs1.tcp.raleigh.ibm.com login user28 password user28
machine 9.67.112.25 login user28
MACHINE FEDC:BA98:7654:3210:FEDC:BA98:7654:3210 LOGIN user28

The keywords machine, login, and password must be lowercase and the
variables user_ID and password might be case sensitive, depending on the
remote host. (For example, when using UNIX or AIX hosts, user_ID and
password are case sensitive.)

//SYSFTPD
= NOT YOUR z/OS FTP SERVER defaults. Too many people point to their
  TCPPARMS(FTPDATA) member. That is for the server, go browse
  SEZAINST(FTCDATA). That "C" means CLIENT. Make a copy in your data
  set and then make all the changes you want.

//ANYDD
= You can reference a DDname instead of a catalogued data set.
>< ADD NAME=FTP$01   0101-07003-07003-2114-00054-00054-00000-KTOMIAK

//STEP001 EXEC PGM=FTP,PARM='-v (EXIT TIMEOUT 72',REGION=2M
//SYSFTPD  DD  DISP=SHR,DSN=&SYSUID..CNTL(FTPUSERP)
//*  sysftpd   copy SYS1.SEZAINST(EZAFTPAC) and tailor as needed
//NAMES    DD  DISP=SHR,DSN=&SYSUID..NAMES.TEXT
//NETRC    DD  DISP=SHR,DSN=&SYSUID..NETRC.DATA
//OUTPUT   DD  SYSOUT=*,DCB=(RECFM=FB,BLKSIZE=0,LRECL=147)
//INPUT    DD  *
host.to.connect.to
myuserid.there
mycurrentpassword.there
pwd
cwd 'myuserid'
pwd
cd 'myuserid'
pwd
lpwd
lcd 'myuserid.xmitdsn'
dir
ls
sendsite
quote site umask 755
quote site chmod ugo+x \tmp\filename
quote site recfm=fb blksize=3120 lrecl=80
locsite volser=zglbos unit=sysallda
locsite tracks primary=100 secondary=50
bin
ascii
ebcdic
rest
LOCSTat
NOop
STAtus
SYstem
TSO ping some.hostname.org
TSO listc entry('share.mvsscpu.cntl')
TSO submit 'myuserid.CNTL(ftpjob)'
quote site filetype=JES
put 'myuserid.CNTL(CANCELME)'
GET J01148.X 'some.dataset.name(IV2C301J)'
DEBug
pwd
QUIt
DELE  fred
MKDIR fred
DELE george
LMKDIR george
!      ; can only be used under unix system services (open edition)
ACcount
CLose
Open
PAss
User
/*
>< ADD NAME=FTP$02   0101-07057-07112-1812-00011-00011-00000-KTOMIAK
#
# machine site login userid password pass
#
#
# Under USS the keywords should be lower case,
# values may be case sensitive.
#
# ibm
machine ftp.software.ibm.com login anonymous +
password your.email@address.goes.here
#
>< ADD NAME=FTP$03   0101-07112-07126-1640-00791-00033-00000-KTOMIAK
;
; Now really, if you can copy this member from your system, all I will
; give you is the hint where you can get it from your system.
;
; Too many ignorant people believe they should point to the
; TCPPARMS(FTPDATA) member used by their FTP daemon. This is
; where you get parameters for your client! They are not the same.
;
; Help break the bad habit and use the correct parameters.
;
;***********************************************************************
;                                                                      *
;   Name of File:             SEZAINST(FTCDATA)                        *
;                                                                      *
;   Descriptive Name:         FTP.DATA  (for FTP Client)               *
;                                                                      *
;   SMP/E Distribution Name:  EZAFTPAC                                 *
;                                                                      *
;   Copyright:    Licensed Materials - Property of IBM                 *
;                                                                      *
;                 "Restricted Materials of IBM"                        *
;                                                                      *
;                 5694-A01                                             *
;                                                                      *
;                 (C) Copyright IBM Corp. 1977, 2006                   *
;                                                                      *
;                 US Government Users Restricted Rights -              *
;                 Use, duplication or disclosure restricted by         *
;                 GSA ADP Schedule Contract with IBM Corp.             *
;                                                                      *
;   Status:       CSV1R8                                               *
;                                                                      *
;***********************************************************************
>< ADD NAME=FTP$04   0100-07112-07112-1818-00012-00012-00000-KTOMIAK

//STEP001 EXEC PGM=FTP,PARM='-v (EXIT TIMEOUT 72',REGION=2M
//OUTPUT   DD  SYSOUT=*,DCB=(RECFM=FB,BLKSIZE=0,LRECL=147)
//ANYDD    DD  DISP=SHR,DSN=SHARE.MVSSCP.UTL.CNTL(FTP$04)
//INPUT    DD  *
host.to.connect.to
myuserid.there
mycurrentpassword.there
put //DDNAME:ANYDD \u\ktomiak\this.is.zos.unix.txt
quit
/*

>< ADD NAME=FTP$05   0100-07112-07112-1824-00024-00024-00000-KTOMIAK
                                                                        00010000
//STEP001 EXEC PGM=FTP,PARM='-v (EXIT TIMEOUT 72',REGION=2M             00020000
//OUTPUT   DD  SYSOUT=*,DCB=(RECFM=FB,BLKSIZE=0,LRECL=147)              00030000
//INPUT    DD  *                                                        00040000
;  Comment lines start wtih a semi-colon in column 1                    00050000
;  If you choose to use NUM ON, you must end every line with a          00060000
;  semi-colon. The line ends after a valid command. So the              00070000
;  semi-colon can be in any column. Leave one out and the line          00080000
;  numbers get passed as part of the command.                           00090000
;                                                                       00100000
;  I like to have at least one space before my semi-colon.              00110000
;                                                                       00120000
;  Did you notice the lcd command uses the continuation character?      00121000
;                                                                       00123000
host.to.connect.to ;                                                    00130000
myuserid.there ;                                                        00140000
mycurrentpassword.there ;                                               00150000
lcd + ;                                                                 00160000
\u\ktomiak ;                                                            00170000
dir ;                                                                   00180000
quit ;                                                                  00190000
/*                                                                      00200000
//                                                                      00210000
                                                                        00220000
./ ADD NAME=HCD      0666-07209-07209-1501-00001-00001-00000-DIR2UPDT
>< ADD NAME=HCD      0103-07003-07016-2344-00007-00007-00000-KTOMIAK

HCD$01 Allocate &sysuid..HCD.PROFILE, TRACE, MSGLOG, TERM
HCD$02 Copy sample entries for HCD.PROFILE
HCD$03 Sample &sysuid..HCD.PROFILE entries
HCD$04 Sample HCM Server
HCD$05 Sample HCM Agent
>< ADD NAME=MGHCP    0101-07003-07016-2348-00005-00005-00000-KTOMIAK

MGHCP$01  Allocate data sets to use the Hardware Configuration Dialog
MGHCP$02  Initialize an IODF
MGHCP$03  Copy one IODF to another


>< ADD NAME=HCD$01   0102-07003-07003-2114-00017-00017-00000-KTOMIAK
//ALLOC   EXEC PGM=IEFBR14
//PROFILE  DD  DISP=(NEW,CATLG),DSN=&SYSUID..HCD.PROFILE,
//             UNIT=SYSALLDA,SPACE=(TRK,(1,1)),
//             DCB=(DSORG=PS,RECFM=FB,BLKSIZE=0,LRECL=80)
//HCDTRACE DD  DISP=(NEW,CATLG),DSN=&SYSUID..HCD.TRACE,
//             UNIT=SYSALLDA,SPACE=(TRK,(10,1)),
//             DCB=(DSORG=PS,RECFM=FB,BLKSIZE=0,LRECL=80)
//HCMTRACE DD  DISP=(NEW,CATLG),DSN=&SYSUID..HCM.TRACE,
//             UNIT=SYSALLDA,SPACE=(TRK,(10,1)),
//             DCB=(DSORG=PS,RECFM=FB,BLKSIZE=0,LRECL=80)
//TERM     DD  DISP=(NEW,CATLG),DSN=&SYSUID..HCD.TERM,
//             UNIT=SYSALLDA,SPACE=(TRK,(1,1)),
//             DCB=(DSORG=PS,RECFM=FB,BLKSIZE=0,LRECL=80)
//MSGLOG   DD  DISP=(NEW,CATLG),DSN=&SYSUID..HCD.MSGLOG,
//             UNIT=SYSALLDA,SPACE=(TRK,(5,1)),
//             DCB=(DSORG=PS,RECFM=FB,BLKSIZE=0,LRECL=133)
//
>< ADD NAME=HCD$02   0100-07003-07003-2114-00005-00005-00000-KTOMIAK
//GENER   EXEC PGM=IEBGENER
//SYSPRINT DD  SYSOUT=*
//SYSIN    DD  DUMMY
//SYSUT1   DD  DISP=SHR,DSN=SHARE.MVSSCPU.CNTL(HCD#03)
//SYSUT2   DD  DISP=OLD,DSN=&SYSUID..HCD.PROFILE
>< ADD NAME=HCD$03   0100-07003-07003-2114-00107-00107-00000-KTOMIAK
/*********************************************************************/
/*                                                                   */
/* Make sure you "UNNUM" your profile !                              */
/*                                                                   */
/*********************************************************************/
/*********************************************************************/
/*                                                                   */
/*             HCD PROFILE FOR OS/390 RELEASE 9 HCD                  */
/*                                                                   */
/*********************************************************************/
/*                                                                   */
/* Make sure you "UNNUM" your profile !                              */
/*                                                                   */
/*********************************************************************/
/*                                                                   */
/*-------------------------------------------------------------------*/
/* Options relieving storage constraints                             */
/*                                                                   */
IODF_DATA_SPACE = YES         /*IODF IN OWN DATASPACE                */
/*                                                                   */
/*-------------------------------------------------------------------*/
/* Options for tailoring the HCD dialog                              */
/*                                                                   */
PANEL_CUP0 = SCREEN           /*DISPLAY ENTIRE SCREEN FOR CBDPCUP0   */
TSO_NOPREFIX = NO             /*ENABLE TSO  NOPREFIX                 */
OS_PARM_DEFAULT = LOCANY,YES  /*   DEFAULT PARAMETERS                */
OS_PARM_DEFAULT = DYNAMIC,NO  /*   DEFAULT PARAMETERS                */
/*                                                                   */
/*-------------------------------------------------------------------*/
/* Options for migration                                             */
/*                                                                   */
MIGRATE_EXTENDED = YES        /*ENABLE MIGRATION ENHANCEMENTS        */
MAP_CUTYPE = 3880,3880-23     /*REPLACE CU TYPE DURING MIGRATION     */
MAP_CUTYPE = 3705,3745        /*REPLACE CU TYPE DURING MIGRATION     */
ESOTERIC_TOKEN = YES          /*ESOTERIC TOKEN IN ASCENDING ORDER    */
/*                                                                   */
/*-------------------------------------------------------------------*/
/* Options for  print/display                                        */
/*                                                                   */
LINES_PER_REPORT_PAGE = 60    /*MAX. NUMBER OF LINES PER PAGE        */
UPPERCASE_ONLY=NO             /*upper and or lower case              */
GCR_FORMAT = DCF              /*GRAPHIC DATA FORMAT BOOKMASTER       */
GCR_FONT = X0GT20             /*GOTHIC TEXT 20-PITCH (FOR 3820 PRT)  */
GCR_COMPACT = YES             /*GRAPHIC COMPACT VIEW                 */
COLOR_NORM=BLACK              /*DEFAULT = GREEN                      */
COLOR_TEXT=BLUE               /*DEFAULT = YELLOW                     */
/*                                                                   */
/*-------------------------------------------------------------------*/
/* Options for activation                                            */
/*                                                                   */
BYPASS_UPD_IODF_FOR_SNA = YES /*NO IODF UPDATE WITH IOCDS DATA       */
SHOW_IO_CHANGES = YES         /*ENABLE MESSAGE SHOW FOR DYN. ACTIVATE*/
/*                                                                   */
/*-------------------------------------------------------------------*/
/* Options controlling placement of data sets                        */
/*                                                                   */
ACTLOG_VOL = *                /*ACTIVITY LOG ON SAME VOLUME AS IODF  */
HCDDECK_VOL = METNET          /*VOLUME FOR CONFIGURATION DATA SET    */
HCDJES3_VOL = METNET          /*VOLUME FOR JES3 OUTPUT DATA SET      */
/*                                                                   */
/*-------------------------------------------------------------------*/
/* Options for enhanced validation                                   */
/*                                                                   */
BATCH_IODF_NAME_CHECK = YES   /* CHECKS IODF NAMING CONVENTIONS      */
CU_ATTACHABLE_DEVICE = RS6K,3274   /* EXTENT ATTACHABLE DEVICE LIST  */
/*                                                                   */
/*-------------------------------------------------------------------*/
/* Where to find UIM modules, if other than sys1.nucleus             */
/*                                                                   */
UIM_LIBNAME = SYS1.NUCLEUS     /* Use * for normal MVS search order  */
/*                                                                   */
/*                                                                   */
/*-------------------------------------------------------------------*/
/* TRACE for debugging purposes.                                     */
/*     (WARNING: Do not use comments on the TRACE line)              */
/*                                                                   */
/*  trace on,all                                                     */
/*  TRace--> ON  | trace-category |                                  */
/*       --> | trace-category |                                      */
/*       --> OFF                                                     */
/*           ---> ,CLOSE                                             */
/*                                                                   */
/*  trace-category:                                                  */
/*  ALL                                                              */
/*     --> ,LEVEL=n                   n=0 to 255, 0 is defauly       */
/*     --> ,ID=IODF                   can not be specified in profile*/
/*                 --> ,REPAIR                                       */
/*     --> ,ID=JCL                                                   */
/*     --> ,ID=IOOPSOUT                                              */
/*  Batch                                                            */
/*  Command                                                          */
/*  Dialog                                                           */
/*  DYNamic                                                          */
/*  HOM                                                              */
/*  Migration                                                        */
/*  Repository                                                       */
/*  RepService                                                       */
/*  RESET                                                            */
/*  Service                                                          */
/*  UIM                                                              */
/*  UIMService                                                       */
/*  Utility                                                          */
/*  Validation                                                       */
/*  Other                                                            */
/*                                                                   */
/*********************************************************************/
/*                                                                   */
>< ADD NAME=HCD$04   0100-07003-07003-2114-00018-00018-00000-KTOMIAK
//*                                                                     00010000
/*JOBPARM  L=99,S=*                                                     00020000
//*                                                                     00030000
//*                                                                     00040000
//DEFENV   SET ENV='ENVAR(ICLUI_TRACETO=STDERR)'                        00050000
//DEFJNP   SET JNP='+U'                                                 00060000
//DEFLOG   SET LOG=NOLOG                                                00070000
//DEFPORT  SET PORT=51107                                               00080000
//DEFJSK   SET JSK=+SHARE.MVSSCPU.CNTL(HCD#05)                          00090000
//DEFP0    SET P0='P0=10000'                                            00100000
//DEFP1    SET P1='P1=65530'                                            00110000
//TDIS     EXEC PGM=CBDQTDIS,                                           00120000
//         PARM='&ENV/&AV L=&LOG P=&PORT JNP=&JNP S=&JSK &P0 &P1'       00130000
//JCLOUT   DD   SYSOUT=(A,INTRDR)                                       00140000
//SYSOUT   DD   SYSOUT=*                                                00150000
//SYSPRINT DD   SYSOUT=*                                                00160000
//CEEDUMP  DD   SYSOUT=*                                                00170000
//*                                                                     00180000
>< ADD NAME=HCD$05   0101-07003-07003-2114-00061-00061-00002-KTOMIAK
//<JOBNAM> JOB (0700,MID),'<PRGNAM>',CLASS=0,REGION=<REGION>,           00010000
//         MSGCLASS=<MCLASS>,TIME=NOLIMIT,                              00020000
//         USER=<USER><PASSWD><NOTIFY>                                  00030000
//* THE FOLLOWING LINE IS FOR JES2 SYSTEMS (HERE: USED AS DEFAULT)      00040000
/*JOBPARM SYSAFF=*                                                      00050000
//* THE FOLLOWING LINE IS FOR JES3 SYSTEMS (HERE: IT IS DISABLED)       00060000
//* //*MAIN SYSTEM=(<TSYS>)                                             00070000
//*                                                                     00080000
//DEFENV   SET ENV='ENVAR(ICLUI_TRACETO=STDERR)'                        00090000
//DEFPORT  SET PORT='<PORT>'                                            00100000
//DEFTIME  SET T='<TIMEOUT>'                                            00110000
//DEFLOG   SET LOG='<ALOGDSN>'                                          00120000
//DEFAV    SET AV='<AV>'                                                00130000
//DEFTIME  SET TIMESTMP='<TSTAMP>'                                      00140000
//************************************************************          00150000
//* HCM AGENT JOB SKELETON FOR HCM TCP/IP HOST CONNECTION    *          00160000
//*                                                          *          00170000
//* BEFORE USING THIS SKELETON, PLEASE ENSURE THAT THE       *          00180000
//* JOB WILL RUN ON THE LOCAL SYSTEM:                        *          00190000
//*   FOR JES2 SYSTEMS:                                      *          00200000
//*     ADAPT THE JOBPARM SYSAFF PARAMETER (IF NECESSARY)    *          00210000
//*   FOR JES3 SYSTEMS:                                      *          00220000
//*     COMMENT THE LINE FOR JES2 AND UNCOMMENT THE LINE     *          00230000
//*     FOR JES3. THEN ADAPT THE MAIN SYSTEM PARAMETER.      *          00240000
//*     IF YOU DO NOT MODIFY <TSYS> IN THE MAIN STATEMENT    *          00250000
//*     THEN THE DISPATCHER WILL SUBSTITUE THE LOCAL SYSTEM  *          00260000
//*     NAME FOR <TSYS>.                                     *          00270000
//*                                                          *          00280000
//* YOU SHOULD ALSO SUBSTITUTE ACCOUNTING INFORMATION FOR    *          00290000
//* '<ACCT>' ABOVE, SO THAT INDIVIDUAL HCM USERS DO NOT HAVE *          00300000
//* TO. IF YOU LEAVE '<ACCT>' AS A SUBSTITUTABLE PARAMETER,  *          00310000
//* HCM USERS WILL HAVE TO SPECIFY THEIR PERSONAL            *          00320000
//* ACCOUNTING INFORMATION IN THE SECTION CBDQAGNT OF      *          00330000
//* THEIR EEQHCM.INI FILE ON THE PWS, E.G.,                  *          00340000
//*       CBDQAGNT                                         *          00350000
//*       AJCLACCT=(DE03160,,)                               *          00360000
//*                                                          *          00370000
//* ALL OTHER SUBSTITUTABLE PARAMETERS IN THE SKELETON       *          00380000
//* WILL BE SUPPLIED BY THE DISPATCHER.                      *          00390000
//*                                                          *          00400000
//* IF YOU SUBSTITUTE THE VALUES                             *          00410000
//* <JCLASS> (JOB CLASS), <REGION>, OR <MCLASS> (MESSAGE     *          00420000
//* CLASS), THEN INDIVIDUAL HCM USERS CAN NO LONGER CONTROL  *          00430000
//* THESE VALUES FROM WITHIN THEIR EEQHCM.INI FILES.         *          00440000
//*                                                          *          00450000
//************************************************************          00460000
//*     LICENSED MATERIALS - PROPERTY OF IBM                 *          00470000
//*     5647-A01                                             *          00480000
//*     (C) COPYRIGHT IBM CORP. 1990, 2000                   *          00490000
//*     STATUS = HCS6091                                     *          00500000
//************************************************************          00510000
//*                                                                     00520000
//AGNT     EXEC PGM=<PROG>,                                             00530000
//         PARM='&ENV/P=&PORT T=&T L=&LOG &AV'                          00540000
//STEPLIB  DD DISP=SHR,DSN=SYS1.SCBDHENU                                00550000
<STEPLIB>                                                               00560000
//SYSOUT   DD <SYSOUT>                                                  00570000
//SYSPRINT DD <SYSPRINT>                                                00580000
//CEEDUMP  DD <CEEDUMP>                                                 00590000
<HCDPROF>                                                               00600001
<HCDTRACE>                                                              00610001
>< ADD NAME=MGHCP$01 0100-07003-07003-2114-00028-00028-00000-KTOMIAK

Example 1: Allocate data sets to use the Hardware Configuration Dialog

//*
//STEP001 EXEC PGM=IKJEFT1B,PARM='',
//             REGION=18M,TIME=1400
//SYSTSPRT DD  SYSOUT=*
//SYSTSIN  DD  *
  "Alloc file(HCDMSGS) DATASET('"user".HCD.MSGLOG')",
    "UNIT(SYSALLDA) VOL(SHTSO1) SPACE(2 1) TRACKS",
    "DSORG(PS) RECFM(F B) BLKSIZE(0) LRECL(133)"

  "Alloc file(HCDTERM) DATASET('"user".HCD.TERM')",
    "UNIT(SYSALLDA) VOL(SHTSO1) SPACE(2 1) TRACKS",
    "DSORG(PS) RECFM(F B) BLKSIZE(0) LRECL(80)"

  "Alloc file(HCDTRACE) DATASET('"user".HCD.TRACE')",
    "UNIT(SYSALLDA) VOL(SHTSO1) SPACE(2 2) TRACKS",
    "DSORG(PS) RECFM(F B) BLKSIZE(0) LRECL(80)"

  "DEFINE CLUSTER (NAME ('"user".IODF00.CLUSTER')",
                  "LINEAR",
                  "RECORDS (1500)",
                  "VOLUMES(SHTSO2)",
                  ")",
           "DATA (NAME ('"user".IODF00'))"
/*

>< ADD NAME=MGHCP$02 0100-07003-07003-2114-00017-00017-00000-KTOMIAK

Example 2: Initialize an IODF

//*
//*--------------------------------------------------------------------
//* INITIALIZE &HLQ..IODF00.WORK
//*--------------------------------------------------------------------
//INIT01  EXEC PGM=CBDMGHCP,
//             PARM='INITIODF SIZE=1500,ACTLOG=YES'
//HCDCNTL  DD  *
THIS IODF IS BRAND NEW FOR THE HCD LAB
/*
//HCDIODFT DD  DISP=OLD,DSN=&HLQ..IODF00
//HCDMLOG  DD  DISP=OLD,DSN=&HLQ..HCD.MSGLOG     <=MESSAGES
//HCDTRACE DD  DISP=OLD,DSN=&HLQ..HCD.TRACE      <=TRACE ENTRIES
//HCDTERM  DD  DISP=OLD,DSN=&HLQ..HCD.TERM       <=I DONT KNOW WHY

>< ADD NAME=MGHCP$03 0100-07003-07003-2114-00011-00011-00000-KTOMIAK

Example 3: Copy one IODF to another

//*
//*--------------------------------------------------------------------
//* COPY ONE IODF TO ANOTHER
//*--------------------------------------------------------------------
//COPY01  EXEC PGM=CBDMGHCP,
//             PARM='COPYIODF'
//HCDIODFS DD  DISP=SHR,DSN=&SRC.IODF00           <= SOURCE
//HCDIODFT DD  DISP=OLD,DSN=&TGT..IODF00            <= TARGET
./ ADD NAME=ICKDSF   0666-07209-07209-1454-00001-00001-00000-DIR2UPDT
>< ADD NAME=DSF      0102-07017-07051-2303-00004-00008-00000-KTOMIAK

DSF$01   Initialize a non-SMS volume
DSF$02   Add IPLTEXT
DSF$03   Initialize a SMS volume
DSF$04   Disable indexed vtoc (convert to osvtoc)
DSF$05   Enable Indexed vtoc
DSF$06   Standard "small" vtoc 1-3-3-8

>< ADD NAME=DSF$01   0102-07017-07037-2304-00018-00116-00000-KTOMIAK

//INITVOL EXEC PGM=ICKDSF
//DD4VOL   DD  DISP=OLD,UNIT=SYSDA,VOL=SER=NEWVOL
//SYSPRINT DD  SYSOUT=*
//SYSIN    DD  *
  /*  DESCRIPTION OF WHAT VOLUME IS FOR.                            */
  INIT     DDNAME(DD4VOL) -
           MAP -
         NOCHECK -
         NORECLAIM -
         NOVERIFY    /* OR VERIFY(OLDVOL) */ -
           PURGE -
         NOVALIDATE -
           VOLID(NEWVOL) -
           VTOC(0,1,44) -
           INDEX(3,0,5)
/*
//

======================================================================

INITIALIZE DASD VOLUMES WITH ICKDSF

       3 3 9 0                                   15 TRKS/CYL
MOD DSCB/TRK IDX/TRK MAXIDX MAXVTOC   VVDS    MAXCYLS  MAXTRKS
  1    50      21        17     328      ?       1113    16695
  2    50      21        33     655      ?       2226    33390
  3    50      21        50     983      ?       3339    50085
  9    50      21       150    2944      ?      10017   150255
 27    50      21       491    9828      ?      32760   491400

IF YOU DON'T MAKE THEM BIG ENOUGH THEN YOU CAN'T GET AS MANY SMALL
DATASETS ON THE VOLUME.

======================================================================

 SOME THOUGHTS, MAY BE MYTH

 CYL 0 TRK 0 IS THE LABEL
 VTOC SHOULD END ON A CYLINDER BOUNDARY
           VTOC(0,1,44) -
                    |= SIZE IN TRACKS
                  |=== TRACK TO BEGIN AT WITHIN CYLINDER
                |===== CYLINDER TO BEGIN AT
 INDEXED VTOC SHOULD IMMEDIATELY FOLLOW
           INDEX(3,0,5)
                     |= SIZE IN TRACKS
                   |=== TRACK TO BEGIN AT WITHIN CYLINDER
                 |===== CYLINDER TO BEGIN AT
   MAKES IT EASY TO CALCULATE, TAKE (VTOC SIZE IN TRACKS + 1) / 15
 VVDS SHOULD IMMEDIATELY FOLLOW THE IXVTOC
   ALLOCATE ONE IF YOU WILL HAVE MANY SMALL CLUSTERS ON THE VOLUME

 IN DAYS OF TRUE 3390 SPINDLES YOU WOULD PLACE THESE THREE SPECIAL
 AREAS IN THE MIDDLE OF THE VOLUME SO ARM MOVEMENT WAS MINIMIZED.
 FROM ACCESSING THE VTOC, IXVTOC, VVDS TO ACTUAL DATA WAS NEVER MORE
 THAN HALF A PLATTER'S DISTANCE.

 NOWADAYS, DASD ARRAYS USE 3.5 INCH DRIVES AND SOFTWARE SO THIS IS
 NO LONGER THE CONCERN.

 SIZING A VTOC AND IXVTOC BASED ON MAXIMUM CAPACITY AND ADHERING
 TO THE CYLINDER BOUNDARY CONCERN:

======================================================================

 A VOLUME FOR JES SPOOL WON'T NEED MUCH
 VTOC SHOULD END ON A CYLINDER BOUNDARY, SO 0,1,14 FILLS THE 1ST CYL,
 USES 14 TRACKS. REALLY DOESN'T NEED TO HOLD MORE THAN FOUR ENTRIES.
   1) THE VTOC ITSELF
   2) THE IXVTOC,
   3) A CHECKPOINT DATASET,
   4) ONE HASPACE DATASET.

           VTOC(0,1,14) -
           INDEX(1,0,5)

======================================================================

 A VOLUME FOR JES SPOOL WON'T NEED MUCH
 VTOC SHOULD END ON A CYLINDER BOUNDARY, SO 0,1,14 FILLS THE 1ST CYL,
 USES 14 TRACKS. REALLY DOESN'T NEED TO HOLD MORE THAN FOUR ENTRIES.
   1) THE VTOC ITSELF
   2) THE IXVTOC,
   3) A CHECKPOINT DATASET,
   4) ONE HASPACE DATASET.

           VTOC(0,1,14) -
           INDEX(1,0,5)

======================================================================

 STEPPING UP EACH VOLUME TYPE PLUS CYLINDER BOUNDARIES
   3390-1  VTOC(0,1,314)  IXVTOC(21,0,15)
   3390-2  VTOC(0,1,644)  IXVTOC(43,0,30)
   3390-3  VTOC(0,1,974)  IXVTOC(65,0,45)
   3390-9  VTOC(0,1,2939) IXVTOC(196,0,150)
   3390-27 VTOC(0,1,9824) IXVTOC(655,0,480)

 YOU CAN SEE FROM THE TABLE UP ABOVE AND THESE STATEMENTS THAT IF
 YOU WANT TO USE THE LARGEST SIZE AND HIT CYLINDER BOUNDARIES YOU
 WILL NEED TO MAKE SOME ADJUSTMENTS. LIKE THESE:

   3390-1  VTOC(0,2,328)  IXVTOC(22,13,17)
   3390-2  VTOC(0,5,655)  IXVTOC(44,12,33)
   3390-3  VTOC(0,7,983)  IXVTOC(66,10,50)
   3390-9  VTOC(0,11,2944) IXVTOC(197,0,150)
   3390-27 VTOC(0,12,9828) IXVTOC(656,0,480)

 TRY IT FIRST, I'M DOING THE MATH AND COULD BE OFF BY A TRACK.

 FOR A 3390-1, 328 TRACKS WOULD NEED TO END AT 330, SO 330-328=2.
 THUS I USED 0,2,328. 330 / 15 = 22. 13+17 = 30. SO 22,13,17.

/*
//
>< ADD NAME=DSF$02   0100-07017-07017-0114-00016-00016-00000-KTOMIAK

//IPLTEXT  EXEC PGM=ICKDSF
//SYSPRINT DD SYSOUT=*
//VSDD     DD DISP=OLD,UNIT=SYSDA,VOL=SER=FTVL2A
//IPLTXT   DD DSN=SYS1.SAMPLIB(IPLRECS),DISP=SHR,
//            UNIT=SYSDA,VOL=SER=FTVL2A
//         DD DSN=SYS1.SAMPLIB(IEAIPL00),DISP=SHR,
//            UNIT=SYSDA,VOL=SER=FTVL2A
//SYSIN    DD  *
  REFORMAT DNAME(VSDD)
         NOVERIFY
         NOBOOT
           IPL(IPLTXT,OBJ)
/*
//

>< ADD NAME=DSF$03   0100-07051-07051-2308-00118-00118-00000-KTOMIAK

//INITVOL EXEC PGM=ICKDSF
//DD4VOL   DD  DISP=OLD,UNIT=SYSDA,VOL=SER=NEWVOL
//SYSPRINT DD  SYSOUT=*
//SYSIN    DD  *
  /*  DESCRIPTION OF WHAT VOLUME IS FOR.                            */
  INIT -
         NOCHECK -
           DDNAME(DD4VOL) -
           INDEX(3,0,5) -
           MAP -
           PURGE -
         NORECLAIM -
           STORAGEGROUP(stogroupname) -
         NOVALIDATE -
         NOVERIFY    /* OR VERIFY(OLDVOL) */ -
           VOLID(NEWVOL) -
           VTOC(0,1,44)
/*
//

======================================================================

INITIALIZE DASD VOLUMES WITH ICKDSF

       3 3 9 0                                   15 TRKS/CYL
MOD DSCB/TRK IDX/TRK MAXIDX MAXVTOC   VVDS    MAXCYLS  MAXTRKS
  1    50      21        17     328      ?       1113    16695
  2    50      21        33     655      ?       2226    33390
  3    50      21        50     983      ?       3339    50085
  9    50      21       150    2944      ?      10017   150255
 27    50      21       491    9828      ?      32760   491400

IF YOU DON'T MAKE THEM BIG ENOUGH THEN YOU CAN'T GET AS MANY SMALL
DATASETS ON THE VOLUME.

======================================================================

 SOME THOUGHTS, MAY BE MYTH

 CYL 0 TRK 0 IS THE LABEL
 VTOC SHOULD END ON A CYLINDER BOUNDARY
           VTOC(0,1,44) -
                    |= SIZE IN TRACKS
                  |=== TRACK TO BEGIN AT WITHIN CYLINDER
                |===== CYLINDER TO BEGIN AT
 INDEXED VTOC SHOULD IMMEDIATELY FOLLOW
           INDEX(3,0,5)
                     |= SIZE IN TRACKS
                   |=== TRACK TO BEGIN AT WITHIN CYLINDER
                 |===== CYLINDER TO BEGIN AT
   MAKES IT EASY TO CALCULATE, TAKE (VTOC SIZE IN TRACKS + 1) / 15
 VVDS SHOULD IMMEDIATELY FOLLOW THE IXVTOC
   ALLOCATE ONE IF YOU WILL HAVE MANY SMALL CLUSTERS ON THE VOLUME

 IN DAYS OF TRUE 3390 SPINDLES YOU WOULD PLACE THESE THREE SPECIAL
 AREAS IN THE MIDDLE OF THE VOLUME SO ARM MOVEMENT WAS MINIMIZED.
 FROM ACCESSING THE VTOC, IXVTOC, VVDS TO ACTUAL DATA WAS NEVER MORE
 THAN HALF A PLATTER'S DISTANCE.

 NOWADAYS, DASD ARRAYS USE 3.5 INCH DRIVES AND SOFTWARE SO THIS IS
 NO LONGER THE CONCERN.

 SIZING A VTOC AND IXVTOC BASED ON MAXIMUM CAPACITY AND ADHERING
 TO THE CYLINDER BOUNDARY CONCERN:

======================================================================

 A VOLUME FOR JES SPOOL WON'T NEED MUCH
 VTOC SHOULD END ON A CYLINDER BOUNDARY, SO 0,1,14 FILLS THE 1ST CYL,
 USES 14 TRACKS. REALLY DOESN'T NEED TO HOLD MORE THAN FOUR ENTRIES.
   1) THE VTOC ITSELF
   2) THE IXVTOC,
   3) A CHECKPOINT DATASET,
   4) ONE HASPACE DATASET.

           VTOC(0,1,14) -
           INDEX(1,0,5)

======================================================================

 A VOLUME FOR JES SPOOL WON'T NEED MUCH
 VTOC SHOULD END ON A CYLINDER BOUNDARY, SO 0,1,14 FILLS THE 1ST CYL,
 USES 14 TRACKS. REALLY DOESN'T NEED TO HOLD MORE THAN FOUR ENTRIES.
   1) THE VTOC ITSELF
   2) THE IXVTOC,
   3) A CHECKPOINT DATASET,
   4) ONE HASPACE DATASET.

           VTOC(0,1,14) -
           INDEX(1,0,5)

======================================================================

 STEPPING UP EACH VOLUME TYPE PLUS CYLINDER BOUNDARIES
   3390-1  VTOC(0,1,314)  IXVTOC(21,0,15)
   3390-2  VTOC(0,1,644)  IXVTOC(43,0,30)
   3390-3  VTOC(0,1,974)  IXVTOC(65,0,45)
   3390-9  VTOC(0,1,2939) IXVTOC(196,0,150)
   3390-27 VTOC(0,1,9824) IXVTOC(655,0,480)

 YOU CAN SEE FROM THE TABLE UP ABOVE AND THESE STATEMENTS THAT IF
 YOU WANT TO USE THE LARGEST SIZE AND HIT CYLINDER BOUNDARIES YOU
 WILL NEED TO MAKE SOME ADJUSTMENTS. LIKE THESE:

   3390-1  VTOC(0,2,328)  IXVTOC(22,13,17)
   3390-2  VTOC(0,5,655)  IXVTOC(44,12,33)
   3390-3  VTOC(0,7,983)  IXVTOC(66,10,50)
   3390-9  VTOC(0,11,2944) IXVTOC(197,0,150)
   3390-27 VTOC(0,12,9828) IXVTOC(656,0,480)

 TRY IT FIRST, I'M DOING THE MATH AND COULD BE OFF BY A TRACK.

 FOR A 3390-1, 328 TRACKS WOULD NEED TO END AT 330, SO 330-328=2.
 THUS I USED 0,2,328. 330 / 15 = 22. 13+17 = 30. SO 22,13,17.

/*
//
>< ADD NAME=DSF$04   0100-07021-07021-2316-00011-00011-00000-KTOMIAK

//OSVTOC  EXEC PGM=ICKDSF
//SYSPRINT DD  SYSOUT=*
//volser   DD  DISP=OLD,UNIT=SYSALLDA,VOL=SER=volser
//SYSIN    DD *
  BUILDIX -
    DDNAME(volser) -
    OSVTOC -
    PURGE
/*

>< ADD NAME=DSF$05   0101-07021-07051-2309-00013-00013-00000-KTOMIAK

//IXVTOC  EXEC PGM=ICKDSF
//SYSPRINT DD  SYSOUT=*
//HOSPITAL DD  DUMMY
//volser   DD  DISP=(NEW,KEEP),DSN=SYS1.VTOCIX.volser,
//             UNIT=3390,SPACE=(TRK,30,,CONTIG),
//             VOL=SER=volser
//SYSIN    DD  *
  BUILDIX -
    DDNAME(volser) -
    IXVTOC
/*

>< ADD NAME=DSF$06   0102-07051-07051-2313-00012-00026-00000-BRIANP

//DSFINIT EXEC PGM=ICKDSF,PARM='NOREPLYU'
//SYSPRINT DD  SYSOUT=*
//volser   DD  DISP=old,unit=sysallda,vol=ser=volser
//SYSIN    DD  *
  INIT    -
    DDNAME(volser) -
    index(0,4,3) -

    VERIFY(oldser) -
    VOLID(newvol) -
    vtoc(0,7,8)
/*
//* IDCAMS
//AMSVVDS EXEC PGM=IDCAMS,REGION=2M
//SYSPRINT DD  SYSOUT=*
//SYSIN    DD  *
  define cluster( -
    name(sys1.vvds.vnewvol) -
    volume(newvol) -
    trk(3 3) -
    nonindexed -
  )
/*
//

./ ADD NAME=IDCAMS   0666-07209-07209-1450-00001-00001-00000-DIR2UPDT
>< ADD NAME=AMS      0105-07016-07145-1854-00007-00011-00000-KTOMIAK

AMS$01    LISTCAT and DELETE - ENTRY
AMS$02    LISTCAT and DELETE - LEVEL
AMS$03    IVP - listcat, delete, define, repro, print
AMS$04    DCOLLECT
AMS$05    Allocate VSAM from JCL
AMS$06    Define a cluster to be a zFS filespace
AMS$07    Delete an errant VVR record
AMS$08    Recatalog an IODF
AMS$09    Allocate NONVSAM from IDCAMS

>< ADD NAME=AMS$01   0101-07003-07003-2113-00011-00011-00000-KTOMIAK

//* IDCAMS
//AMS0001 EXEC PGM=IDCAMS,REGION=2M
//SYSPRINT DD  SYSOUT=*
//SYSIN    DD  *
  LISTCAT ENTRY('SOME.DATASET')
  IF LASTCC = 0 THEN -
    DELETE 'SOME.DATASET'
  SET MAXCC = 0
/*

>< ADD NAME=AMS$02   0100-07003-07003-2113-00010-00010-00000-KTOMIAK
                                                                        00110000
//* IDCAMS
//AMS0001 EXEC PGM=IDCAMS,REGION=2M
//SYSPRINT DD  SYSOUT=*
//SYSIN    DD  *
  LISTCAT LEVEL('HLQ.PREFIX')
  IF LASTCC = 0 THEN -
    DELETE 'HLQ.PREFIX.*'
  SET MAXCC = 0
/*
>< ADD NAME=AMS$03   0102-07003-07003-2133-00319-00329-00011-KTOMIAK
//*                                                                     00010000
//STEP001 EXEC PGM=IDCAMS                                               00020000
//SYSPRINT DD  SYSOUT=*                                                 00030000
//SYSIN    DD  *                                                        00040000
 /*---------------------------------------------------------------*/    00050000
 /*                                                               */    00060000
 /*---------------------------------------------------------------*/    00070000
 /*                                                               */    00080000
  IF MAXCC = 0 THEN -                                                   00090000
    DO                                                                  00100000
      LISTCAT ENTRY('SHARE##.S2820LAB.NONVSAM.DISK3390') ALL            00110000
      IF LASTCC = 0 THEN -                                              00120000
        DO                                                              00130000
          DELETE 'SHARE##.S2820LAB.NONVSAM.DISK3390' -                  00140000
                 NOSCRATCH                                              00150000
          IF LASTCC = 0 THEN                                            00160000
            SET MAXCC = 0                                               00170000
        END                                                             00180000
      DEFINE NONVSAM ( -                                                00190000
               NAME('SHARE##.S2820LAB.NONVSAM.DISK3390') -              00200000
               DEVICETYPES(3390, 3390) -                                00210000
               VOLUMES(1$3390 -                                         00220000
                       2$3390 -                                         00230000
                      ) -                                               00240000
               OWNER(FRED) -                                            00250000
             )                                                          00260000
      IF LASTCC = 0 THEN -                                              00270000
        DO                                                              00280000
          LISTCAT ENTRY('SHARE##.S2820LAB.NONVSAM.DISK3390') ALL        00290000
          SET MAXCC=0                                                   00300000
        END                                                             00310000
    END                                                                 00320000
 /*---------------------------------------------------------------*/    00330000
 /*                                                               */    00340000
 /*---------------------------------------------------------------*/    00350000
 /*                                                               */    00360000
  IF MAXCC = 0 THEN -                                                   00370000
    DO                                                                  00380000
      LISTCAT ENTRY('SHARE##.S2820LAB.ESDS.CLUSTER') ALL                00390000
      IF LASTCC = 0 THEN -                                              00400000
        DO                                                              00410000
          DELETE 'SHARE##.S2820LAB.ESDS.CLUSTER'                        00420000
          IF LASTCC = 0 THEN                                            00430000
            SET MAXCC = 0                                               00440000
        END                                                             00450000
      DEFINE CLUSTER ( -                                                00460000
                      NAME('SHARE##.S2820LAB.ESDS.CLUSTER') -           00470000
                      TRACKS(1 1) -                                     00480000
                      VOLUMES(SHTSO2 -                                  00490000
                             ) -                                        00500000
                      FREESPACE(10 15) -                                00510000
                      KEYS(20 5) -                                      00520000
                      OWNER(SHARE##) -                                  00530000
                      RECORDSIZE(128 4089) -                            00540000
                      SHAREOPTIONS(1 3) -                               00550000
                      RECOVERY -                                        00560000
                      UNIQUE -                                          00570000
                      NONINDEXED -                                      00580000
                     ) -                                                00590000
             DATA ( -                                                   00600000
                   NAME('SHARE##.S2820LAB.ESDS.CLUSTER.DATA') -         00610000
                  )                                                     00620000
      IF LASTCC = 0 THEN -                                              00630000
        DO                                                              00640000
          LISTCAT ENTRY('SHARE##.S2820LAB.ESDS.CLUSTER') ALL            00650000
          SET MAXCC=0                                                   00660000
          REPRO INFILE(DATAIN1) -                                       00670000
            OUTDATASET('SHARE##.S2820LAB.ESDS.CLUSTER')                 00680000
        END                                                             00690000
    END                                                                 00700000
 /*---------------------------------------------------------------*/    00710000
 /*                                                               */    00720000
 /*---------------------------------------------------------------*/    00730000
 /*                                                               */    00740000
  IF MAXCC = 0 THEN -                                                   00750000
    DO                                                                  00760000
      LISTCAT ENTRY('SHARE##.S2820LAB.KSDS.CLUSTER') ALL                00770000
      IF LASTCC = 0 THEN -                                              00780000
        DO                                                              00790000
          DELETE 'SHARE##.S2820LAB.KSDS.CLUSTER'                        00800000
          IF LASTCC = 0 THEN                                            00810000
            SET MAXCC = 0                                               00820000
        END                                                             00830000
      DEFINE CLUSTER ( -                                                00840000
                      NAME('SHARE##.S2820LAB.KSDS.CLUSTER') -           00850000
                      TRACKS(1 1) -                                     00860000
                      VOLUMES(SHTSO2 -                                  00870000
                             ) -                                        00880000
                      FREESPACE(10 15) -                                00890000
                      KEYS(20 5) -                                      00900000
                      OWNER(SHARE##) -                                  00910000
                      RECORDSIZE(128 4089) -                            00920000
                      SHAREOPTIONS(1 3) -                               00930000
                      RECOVERY -                                        00940000
                      UNIQUE -                                          00950000
                      INDEXED -                                         00960000
                     ) -                                                00970000
             DATA ( -                                                   00980000
                   NAME('SHARE##.S2820LAB.KSDS.CLUSTER.DATA') -         00990000
                  ) -                                                   01000000
             INDEX ( -                                                  01010000
                    NAME('SHARE##.S2820LAB.KSDS.CLUSTER.OTHER') -       01020000
                   )                                                    01030000
      IF LASTCC = 0 THEN -                                              01040000
        DO                                                              01050000
          LISTCAT ENTRY('SHARE##.S2820LAB.KSDS.CLUSTER') ALL            01060000
          SET MAXCC=0                                                   01070000
          REPRO INFILE(DATAIN1) -                                       01080000
            OUTDATASET('SHARE##.S2820LAB.KSDS.CLUSTER')                 01090000
        END                                                             01100000
    END                                                                 01110000
 /*---------------------------------------------------------------*/    01120000
 /*                                                               */    01130000
 /*---------------------------------------------------------------*/    01140000
 /*                                                               */    01150000
  IF MAXCC = 0 THEN -                                                   01160000
    DO                                                                  01170000
      LISTCAT ENTRY('SHARE##.S2820LAB.RRDS.CLUSTER') ALL                01180000
      IF LASTCC = 0 THEN -                                              01190000
        DO                                                              01200000
          DELETE 'SHARE##.S2820LAB.RRDS.CLUSTER'                        01210000
          IF LASTCC = 0 THEN                                            01220000
            SET MAXCC = 0                                               01230000
        END                                                             01240000
      DEFINE CLUSTER ( -                                                01250000
                      NAME('SHARE##.S2820LAB.RRDS.CLUSTER') -           01260000
                      TRACKS(1 1) -                                     01270000
                      VOLUMES(SHTSO2 -                                  01280000
                             ) -                                        01290000
                      FREESPACE(10 15) -                                01300000
                      KEYS(20 5) -                                      01310000
                      OWNER(SHARE##) -                                  01320000
                      RECORDSIZE(128 4089) -                            01330000
                      SHAREOPTIONS(1 3) -                               01340000
                      RECOVERY -                                        01350000
                      UNIQUE -                                          01360000
                      NUMBERED -                                        01370000
                     ) -                                                01380000
             DATA ( -                                                   01390000
                   NAME('SHARE##.S2820LAB.RRDS.CLUSTER.DATA') -         01400000
                  )                                                     01410000
      IF LASTCC = 0 THEN -                                              01420000
        DO                                                              01430000
          LISTCAT ENTRY('SHARE##.S2820LAB.RRDS.CLUSTER') ALL            01440000
          SET MAXCC=0                                                   01450000
          REPRO INFILE(DATAIN1) -                                       01460000
            OUTDATASET('SHARE##.S2820LAB.RRDS.CLUSTER')                 01470000
        END                                                             01480000
    END                                                                 01490000
 /*---------------------------------------------------------------*/    01500000
 /*                                                               */    01510000
 /*---------------------------------------------------------------*/    01520000
 /*                                                               */    01530000
  IF MAXCC = 0 THEN -                                                   01540000
    DO                                                                  01550000
      LISTCAT ENTRY('SHARE##.S2820LAB.GDG') ALL                         01560000
      IF LASTCC = 0 THEN -                                              01570000
        DO                                                              01580000
          DELETE 'SHARE##.S2820LAB.GDG.*'                               01590000
          DELETE 'SHARE##.S2820LAB.GDG'                                 01600000
          IF LASTCC = 0 THEN                                            01610000
            SET MAXCC = 0                                               01620000
        END                                                             01630000
      DEFINE GENERATIONDATAGROUP( -                                     01640000
                                 NAME('SHARE##.S2820LAB.GDG') -         01650000
                                 NOEMPTY -                              01660000
                                 SCRATCH -                              01670000
                                 OWNER('SHARE##') -                     01680000
                                 LIMIT(5) -                             01690000
                                )                                       01700000
      IF LASTCC = 0 THEN -                                              01710000
        DO                                                              01720000
          LISTCAT ENTRY('SHARE##.S2820LAB.GDG') ALL                     01730000
          SET MAXCC=0                                                   01740000
        END                                                             01750000
    END                                                                 01760000
 /*---------------------------------------------------------------*/    01770000
 /*                                                               */    01780000
 /*---------------------------------------------------------------*/    01790000
 /*                                                               */    01800000
  IF MAXCC = 0 THEN -                                                   01810000
    DO                                                                  01820000
      LISTCAT ENTRY('SHARE##.S2820LAB.KSDS.CLUSTER')                    01830000
      IF LASTCC = 0 THEN -                                              01840000
        DO                                                              01850000
          LISTCAT ENTRY('SHARE##.S2820LAB.AIX') ALL                     01860000
          IF LASTCC = 0 THEN -                                          01870000
            DO                                                          01880000
              DELETE 'SHARE##.S2820LAB.AIX'                             01890000
              IF LASTCC = 0 THEN                                        01900000
                SET MAXCC = 0                                           01910000
            END                                                         01920000
          DEFINE ALTERNATEINDEX ( -                                     01930000
                                 NAME(SHARE##.S2820LAB.AIX) -           01940000
                            RELATE('SHARE##.S2820LAB.KSDS.CLUSTER') -   01950000
                                 TRACKS(5 5) -                          01960000
                                 VOLUMES(* -                            01970000
                                         * -                            01980000
                                        ) -                             01990000
                                 SHAREOPTIONS(1 3) -                    02000000
                                 ERASE -                                02010000
                                 IMBED -                                02020000
                                 ORDERED -                              02030000
                                 NORECATALOG -                          02040000
                                 REPLICATE -                            02050000
                                 REUSE -                                02060000
                                 SPEED -                                02070000
                                 UNIQUEKEY -                            02080000
                                 UPGRADE -                              02090000
                                 OWNER(SHARE##) -                       02100000
                                 KEYS(18 5) -                           02110000
                                ) -                                     02120000
                 DATA ( -                                               02130000
                       NAME(SHARE##.S2820LAB.AIX.DATA) -                02140000
                      ) -                                               02150000
                 INDEX ( -                                              02160000
                        NAME(SHARE##.S2820LAB.AIX.INDEX) -              02170000
                       )                                                02180000
          IF LASTCC = 0 THEN -                                          02190000
            DO                                                          02200000
              LISTCAT ENTRY('SHARE##.S2820LAB.AIX') ALL                 02210000
              SET MAXCC=0                                               02220000
            END                                                         02230000
        END                                                             02240000
    END                                                                 02250000
 /*---------------------------------------------------------------*/    02260000
 /*                                                               */    02270000
 /*---------------------------------------------------------------*/    02280000
 /*                                                               */    02290000
  IF MAXCC = 0 THEN -                                                   02300000
    DO                                                                  02310000
      LISTCAT ENTRY('SHARE##.S2820LAB.KSDS.CLUSTER')                    02320000
      IF LASTCC = 0 THEN -                                              02330000
        DO                                                              02340000
          LISTCAT ENTRY('SHARE##.S2820LAB.AIX') ALL                     02350000
          IF LASTCC = 0 THEN -                                          02360000
            DO                                                          02370000
              LISTCAT ENTRY('SHARE##.S2820LAB.PATH') ALL                02380000
              IF LASTCC = 0 THEN -                                      02390000
                DO                                                      02400000
                  DELETE 'SHARE##.S2820LAB.PATH'                        02410000
                  IF LASTCC = 0 THEN                                    02420000
                    SET MAXCC = 0                                       02430000
                END                                                     02440000
              DEFINE PATH ( -                                           02450000
                           NAME(SHARE##.S2820LAB.PATH) -                02460000
                           PATHENTRY(SHARE##.S2820LAB.AIX) -            02470000
                           UPDATE -                                     02480000
                           OWNER(KENTOMIA) -                            02490000
                          )                                             02500000
              IF LASTCC = 0 THEN -                                      02510000
                DO                                                      02520000
                  LISTCAT ENTRY('SHARE##.S2820LAB.AIX') ALL             02530000
                  SET MAXCC=0                                           02540000
                END                                                     02550000
            END                                                         02560000
        END                                                             02570000
    END                                                                 02580000
 /*---------------------------------------------------------------*/    02590000
 /*                                                               */    02600000
 /*---------------------------------------------------------------*/    02610000
 /*                                                               */    02620000
/*                                                                      02630000
//DATAIN1  DD  *                                                        02640000
12345678901234567890aaaaa1234567890                                     02650000
12345678901234567890bbbbb1234567890                                     02660000
12345678901234567890ddddd1234567890                                     02670000
12345678901234567890eeeee1234567890                                     02680000
/*                                                                      02690000
//*                                                                     02700000
//STEP002 EXEC PGM=IEFBR14                                              02710000
//NEWDD    DD  DISP=(NEW,CATLG),DSN=SHARE##.S2820LAB.GDG(+1),           02720000
//             UNIT=SYSDA,                                              02730000
//             SPACE=(TRK,(1,1)),                                       02740000
//             DCB=(DSORG=PS,RECFM=FB,BLKSIZE=0,LRECL=80)               02750000
//*                                                                     02760000
//STEP003 EXEC PGM=IEFBR14                                              02770000
//NEWDD    DD  DISP=(NEW,CATLG),DSN=SHARE##.S2820LAB.GDG(+2),           02780000
//             UNIT=SYSDA,                                              02790000
//             SPACE=(TRK,(1,1)),                                       02800000
//             DCB=(DSORG=PS,RECFM=FB,BLKSIZE=0,LRECL=80)               02810000
//*                                                                     02820000
//STEP004 EXEC PGM=IDCAMS                                               02830000
//BASEDD   DD  DISP=OLD,DSN=SHARE##.S2820LAB.KSDS.CLUSTER               02840000
//AIXDD    DD  DISP=OLD,DSN=SHARE##.S2820LAB.AIX                        02850000
//SYSPRINT DD  SYSOUT=*                                                 02860000
//SORTMSGS DD  SYSOUT=*                                                 02870000
//SYSIN    DD   *                                                       02880000
 REPRO INFILE(DATAIN2) -                                                02890000
       OUTDATASET('SHARE##.S2820LAB.ESDS.CLUSTER')                      02900000
 BLDINDEX INFILE(BASEDD) -                                              02910000
          OUTFILE(AIXDD) -                                              02920000
          SORTCALL -                                                    02930000
          SORTMESSAGELEVEL(ALL) -                                       02940000
          SORTMESSAGEDD(SORTMSGS)                                       02950000
 REPRO INFILE(DATAIN2) -                                                02960000
       OUTDATASET('SHARE##.S2820LAB.KSDS.CLUSTER')                      02970000
/*                                                                      03010000
//DATAIN2  DD  *                                                        03020000
12345678901234567890ccccc1234567890                                     03030000
12345678901234567890ggggg1234567890                                     03040000
12345678901234567890AAAAA1234567890                                     03050000
12345678901234567890BBBBB1234567890                                     03060000
12345678901234567890CBBBB1234567890                                     03070001
15345678901234567890DDBBB1234567890                                     03090002
12945678901234567890EBBBB1234567890                                     03100002
22345678901234567890EFBBB1234567890                                     03101002
/*                                                                      03110000
//*                                                                     03120000
//STEP005 EXEC PGM=IDCAMS                                               03130001
//SYSPRINT DD  SYSOUT=*                                                 03140000
//SYSIN    DD  *                                                        03150000
          DELETE 'SHARE##.S2820LAB.NONVSAM.DISK3390' -                  03160000
                 NOSCRATCH                                              03170000
          DELETE 'SHARE##.S2820LAB.GDG.*'                               03180000
          DELETE 'SHARE##.S2820LAB.GDG'                                 03190000
          DELETE 'SHARE##.S2820LAB.PATH'                                03200000
          DELETE 'SHARE##.S2820LAB.AIX'                                 03210000
          DELETE 'SHARE##.S2820LAB.RRDS.CLUSTER'                        03220000
          DELETE 'SHARE##.S2820LAB.ESDS.CLUSTER'                        03230000
 PRINT -                                                                03231002
   SKIP(2) -                                                            03232002
       INDATASET('SHARE##.S2820LAB.KSDS.CLUSTER')                       03233002
 PRINT -                                                                03234002
   CHARACTER -                                                          03235002
       INDATASET('SHARE##.S2820LAB.KSDS.CLUSTER')                       03236002
          DELETE 'SHARE##.S2820LAB.KSDS.CLUSTER'                        03240000
/*                                                                      03250000
//                                                                      03260000
>< ADD NAME=AMS$04   0100-07003-07003-2151-00012-00012-00000-KTOMIAK
//*                                                                     00006000
//STEP001 EXEC PGM=IDCAMS,REGION=6M,TIME=1439                           00010000
//SYSPRINT DD  SYSOUT=*                                                 00020000
//SYSIN    DD  *                                                        00030000
  DCOLLECT -                                                            00040000
    OUTFILE(DCOUT) -                                                    00050000
    SMSDATA(ACTIVE) -                                                   00060000
    VOLUMES(*)                                                          00070000
/*                                                                      00080000
//DCOUT    DD  DISP=(NEW,CATLG),DSN=SHARE##.S2820LAB.DCOLLECT.DATA,     00090000
//             UNIT=SYSDA,SPACE=(TRK,(500,250),RLSE),AVGREC=K,          00100000
//             DSORG=PS,RECFM=VB,LRECL=932                              00110000
>< ADD NAME=AMS$05   0100-07003-07003-2154-00008-00008-00000-KTOMIAK

//*
//VSAMKSDS DD  DISP=(NEW,CATLG,DELETE),DSN=SHARE##.S2820LAB.VSAMJCL,
//             UNIT=SYSDA,
//             SPACE=(CYL,(10,10)),
//             LRECL=100,KEYOFF=10,KEYLEN=12,RECORG=KS
//*

>< ADD NAME=AMS$06   0100-07055-07055-2131-00034-00034-00000-RJAHMAD
//*-------------------------------------------------------------------*
//*
//* This job will create a zFS Multivolume Compatability Aggregate
//* DEFINE - allocates a cluster.
//*
//*
//*
//* FORMAT - formats the cluster as a Compatability Aggregate using
//*          375,300 segments and can grow in increments of 300,240.
//*
//*-------------------------------------------------------------------*
//DEFINE  EXEC PGM=IDCAMS
//SYSPRINT DD  SYSOUT=*
//SYSIN    DD  *
     DELETE OMVS.yourid.ZFS PURGE
     SET MAXCC=0
     DEFINE -
       CLUSTER ( -
         NAME(OMVS.yourid.ZFS) -
         LINEAR -
         CYL(3336 5) -
         SHAREOPTIONS(3) -
         DATACLAS(ZVSAMLDS) -
         STORCLAS(ZVSAMLDS) -
       )
/*
//*
//FORMAT  EXEC PGM=IOEAGFMT,REGION=0M,
//             PARM=('-aggregate OMVS.yourid.ZFS',
//             '-compat -size 375300 -grow 300240')
//SYSPRINT DD  SYSOUT=*
//STDOUT   DD  SYSOUT=*
//STDERR   DD  SYSOUT=*

>< ADD NAME=AMS$07   0100-07055-07055-2134-00012-00012-00000-RJAHMAD

//*-------------------------------------------------------------------*
//* Step to delete a VVR record
//*-------------------------------------------------------------------*
//DELVVR  EXEC PGM=IDCAMS
//SYSPRINT DD  SYSOUT=*
//DD1      DD  DISP=OLD,UNIT=SYSALLDA,VOL=SER=WSL002  <=== Change
//SYSIN    DD  *
  DELETE LOGGER.ATR.WSLPLEX.ARCHIVE.WSLPLEX.DATA   VVR FILE(DD1)
/*
//

>< ADD NAME=AMS$08   0100-07055-07055-2145-00020-00020-00000-RJAHMAD

//*-------------------------------------------------------------------*
//* RECATALOG IODF DATASET SYS1.IODF05
//*-------------------------------------------------------------------*
//RECAT   EXEC PGM=IDCAMS
//SYSPRINT DD  SYSOUT=*
//SYSIN    DD  *
  DEFINE -
    CLUSTER ( -
      NAME(SYS1.IODF05.CLUSTER) -
      LINEAR -
      VOLUMES(OPSRS1)                /* <== Change this  */ -
      RECATALOG -
    ) -
    DATA -
      (NAME (SYS1.IODF05) -
    )
/*
//

>< ADD NAME=AMS$09   0100-07145-07145-1853-00043-00043-00000-KTOMIAK

//*-------------------------------------------------------------------*
//* ALLOCATE NONVSAM USING AMS
//*-------------------------------------------------------------------*
//ALLOC   EXEC PGM=IDCAMS
//SYSPRINT DD  SYSOUT=*
//SYSIN    DD  *
 /*---------------------------------------------------------------*/
 /*                                                               */
 /*---------------------------------------------------------------*/
 /*                                                               */
         LISTCAT -
           ENTRY(SHARE##.S2820.BOOK)

         IF LASTCC GT 0 THEN -
           DO
             ALLOCATE -
               DSNAME('SHARE##.S2820.BOOK') -
               NEW -
               CATALOG -
               RECFM(F B) -
               LRECL(4096) -
               DSORG(PS) -
               BLKSIZE(28672) -
               AVBLOCK(28672) -
               SPACE(70 7) -
               UNIT(3390) -
               VOLUME(SHTSO2)
             IF LASTCC EQ 0 THEN -
               DO
                 SET MAXCC = 0
               END
           END
         ELSE -
           CANCEL

         LISTCAT -
           ENTRY(SHARE##.S2820.BOOK) -
           ALL

/*
//

./ ADD NAME=IEBCOMPR 0666-07209-07209-1451-00001-00001-00000-DIR2UPDT
>< ADD NAME=COMPR    0100-07016-07016-2156-00010-00010-00000-KTOMIAK

COMPR$01  Compare Data Sets that Reside on Tape
COMPR$02  Compare Sequential Data Sets that Reside on Tape
COMPR$03  Compare Sequential Data Sets Written at Different Densities
COMPR$04  Compare Sequential Data Sets-Input Stream and Tape Input
COMPR$05  Copy and Compare Sequential Data Set in Two Job Steps
COMPR$06  Compare Two Partitioned Data Sets
COMPR$07  Copy and Compare Partitioned Data Set in Two Job Steps
COMPR$08  Compare Two PDSEs

>< ADD NAME=COMPR$01 0100-07003-07003-2113-00032-00032-00000-SC26UTL

Example 1: Compare Data Sets that Reside on Tape

In this example, two sequential data sets that reside on 9-track tape
volumes are compared.

//TAPETAPE JOB ...
//        EXEC PGM=IEBCOMPR
//SYSPRINT DD  SYSOUT=*
//SYSUT1   DD  DISP=(OLD,KEEP),DSN=SET1,
//             UNIT=tape,LABEL=(,NL),
//             VOL=SER=001234,
//             DCB=(RECFM=FB,BLKSIZE=2000,LRECL=80)
//SYSUT2   DD  DISP=(OLD,KEEP),DSN=SET2,
//             UNIT=tape,LABEL=(,NL),
//             VOL=SER=001235,
//             DCB=(RECFM=FB,BLKSIZE=1040,LRECL=80)
//SYSIN    DD  DUMMY
/*

The job control statements are discussed below:

x) SYSUT1 DD defines an input data set (SET1), which resides on an
   unlabeled 9-track tape volume.

x) SYSUT2 DD defines an input data set (SET2), which resides on an
   unlabeled 9-track tape volume.

x) SYSIN DD defines a dummy data set. Because no user routines are used
   and the input data sets have a sequential organization, utility
   control statements are not necessary.

>< ADD NAME=COMPR$02 0100-07003-07003-2113-00043-00043-00000-SC26UTL

Example 2: Compare Sequential Data Sets that Reside on Tape

In this example, two sequential data sets that reside on 7-track tape
volumes are compared.

//TAPETAPE JOB ...
//        EXEC PGM=IEBCOMPR
//SYSPRINT DD  SYSOUT=*
//SYSUT1   DD  DISP=(OLD,KEEP),DSN=SET1,
//             UNIT=tape,LABEL=(2,SUL),
//             VOL=SER=001234,
//             DCB=(DEN=2,RECFM=FB,BLKSIZE=2000,LRECL=80,TRTCH=C)
//SYSUT2   DD  DISP=(OLD,KEEP),DSN=SET2,LABEL=(,SUL),
//             UNIT=tape,LABEL=(,SUL),
//             VOL=SER=001235,
//             DCB=(DEN=2,RECFM=FB,BLKSIZE=2000,LRECL=80,TRTCH=C)
//SYSIN    DD  *
         COMPARE TYPORG=PS
         LABELS  DATA=ONLY
/*

The control statements are discussed below:

x) SYSUT1 DD defines an input data set, SET1, which resides on a
   labeled, 7-track tape volume. The blocked data set was originally
   written at a density of 800 bits per inch (DEN=2) with the data
   converter on (TRTCH=C).

x) SYSUT2 DD defines an input data set, SET2, which is the first or
   only data set on a labeled, 7-track tape volume. The blocked data
   set was originally written at a density of 800 bits per inch (DEN=2)
   with the data converter on (TRTCH=C).

x) SYSIN DD defines the control data set, which follows in the input
   stream.

x) COMPARE TYPORG=PS specifies that the input data sets are
   sequentially organized.

x) LABELS DATA=ONLY specifies that user header labels are to be treated
   as data and compared. All other labels on the tape are ignored.

>< ADD NAME=COMPR$03 0100-07003-07003-2113-00046-00046-00000-SC26UTL

Example 3: Compare Sequential Data Sets Written at Different Densities

In this example, two sequential data sets that were written at
different densities on different tape units are compared.

//TAPETAPE JOB ...
//        EXEC PGM=IEBCOMPR
//SYSPRINT DD  SYSOUT=*
//SYSUT1   DD  DISP=(OLD,KEEP),DSN=SET1,
//             UNIT=tape,LABEL=(2,SUL),
//             VOL=SER=001234,
//             DCB=(DEN=2,RECFM=FB,BLKSIZE=320,LRECL=80,TRTCH=C)
//SYSUT2   DD  DISP=(OLD,KEEP),DSN=SET2,LABEL=(,SUL),
//             UNIT=tape,LABEL=(,SUL),
//             VOL=SER=001235,
//             DCB=(DEN=2,RECFM=FB,BLKSIZE=640,LRECL=80,TRTCH=C)
//SYSIN    DD  *
         COMPARE TYPORG=PS
         EXITS   INHDR=HDRS,INTLR=TLRS
         LABELS  DATA=NO
/*

The control statements are discussed below:

x) SYSUT1 DD defines an input data set, SET1, which is the first or
   only data set on a labeled, 7-track tape volume. The blocked data
   set was originally written at a density of 556 bits per inch (DEN=1)
   with the data converter on (TRTCH=C).

x) SYSUT2 DD defines an input data set, SET2, which is the first or
   only blocked data set on a labeled tape volume. In this example,
   assume SYSUT2 is on a 9-track tape drive.

x) SYSIN DD defines the control data set, which follows in the input
   stream.

x) COMPARE TYPORG=PS specifies that the input data sets are
   sequentially organized.

x) EXITS identifies the names of routines to be used to process user
   input header labels and trailer labels.

x) LABELS DATA=NO specifies that the user input header and trailer
   labels for each data set are not to be compared.

>< ADD NAME=COMPR$04 0100-07003-07003-2113-00031-00031-00000-SC26UTL

Example 4: Compare Sequential Data Sets-Input Stream and Tape Input

In this example, two sequential data sets (input stream and tape) are
compared.

//CARDTAPEJOB ...
//        EXEC PGM=IEBCOMPR
//SYSPRINT DD  SYSOUT=*
//SYSIN    DD  DUMMY
//SYSUT2   DD  DISP=(OLD,KEEP),
//             UNIT=tape,LABEL=(,NL),
//             VOL=SER=001234,
//             DCB=(RECFM=FB,BLKSIZE=2000,LRECL=80)
//SYSUT1   DD  DATA

(input data set)

/*

The control statements are discussed below:

x) SYSIN DD defines a dummy control data set. Because no user routines
   are provided and the input data sets are sequential, utility control
   statements are not necessary.

x) SYSUT2 DD defines an input data set, which resides on an unlabeled,
   tape volume.

x) SYSUT1 DD defines a system input stream data set.

>< ADD NAME=COMPR$05 0100-07003-07003-2113-00038-00038-00000-SC26UTL

Example 5: Copy and Compare Sequential Data Set in Two Job Steps

In this example, a sequential disk or tape data set is copied and
compared in two job steps.

//TAPETAPE JOB ...
//STEPA   EXEC PGM=IEBGENER
//SYSPRINT DD  SYSOUT=*
//SYSUT1   DD  DISP=(OLD,PASS),DSN=WAREHOUS.COPYSET1
//SYSUT2   DD  DISP=(,PASS),DSN=WAREHOUS.COPYSET2,
//             UNIT=tape,LABEL=(,SL),
//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=640)
//SYSIN    DD  DUMMY
//*
//STEPB   EXEC PGM=IEBCOMPR
//SYSPRINT DD  SYSOUT=*
//SYSUT1   DD  DISP=(OLD,KEEP),DSN=*.STEPA.SYSUT1
//SYSUT2   DD  DISP=(OLD,KEEP),DSN=*.STEPA.SYSUT2
//SYSIN    DD  DUMMY

The first job step copies the data set and passes the original and
copied data sets to the second job step. The second job step compares
the two data sets.

The control statements for the IEBCOMPR job step are discussed below:

x) SYSUT1 DD defines an input data set passed from the preceding job
   step (COPYSET1). The data set resides on a labeled tape volume.

x) SYSUT2 DD defines an input data set passed from the preceding job
   step (COPYSET2). The data set, which was created in the preceding
   job step, resides on a labeled tape volume.

x) SYSIN DD defines a dummy control data set. Because the input is
   sequential and no user exits are provided, no utility control
   statements are required.

>< ADD NAME=COMPR$06 0100-07003-07003-2113-00028-00028-00000-SC26UTL

Example 6: Compare Two Partitioned Data Sets

In this example, two partitioned data sets are compared.

//DISKDISK JOB ...
//STEP1   EXEC PGM=IEBCOMPR
//SYSPRINT DD  SYSOUT=*
//SYSUT1   DD  DISP=(SHR),DSN=PDSSET1
//SYSUT2   DD  DISP=(SHR),DSN=PDSSET2
//SYSIN    DD  *
         COMPARE TYPORG=PO
/*

The control statements are discussed below:

x) SYSUT1 DD defines an input partitioned data set, PDSSET1. The
   blocked data set resides on a disk volume.

x) SYSUT2 DD defines an input partitioned data set, PDSSET2. The
   blocked data set resides on a disk volume.

x) SYSIN DD defines the control data set, which follows in the input
   stream.

x) COMPARE TYPORG=PO indicates that the input data sets are
   partitioned.

>< ADD NAME=COMPR$07 0100-07003-07003-2113-00053-00053-00000-SC26UTL

Example 7: Copy and Compare Partitioned Data Set in Two Job Steps

In this example, a partitioned data set is copied and compared in two
job steps.

//DISKDISK JOB ...
//STEPA   EXEC PGM=IEBCOPY
//SYSPRINT DD  SYSOUT=*
//SYSUT1   DD  DISP=(SHR),DSN=MAINDB.LOG.OLDSET
//SYSUT2   DD  DISP=(NEW,PASS),DSN=MAINDB.LOG.NEWMEMS,
//             UNIT=disk,
//             SPACE=(TRK,(5,5,5)),
//             DCB=(DSPRG=PO,RECFM=FB,BLKSIZE=0,LRECL=80)
//SYSUT3   DD  UNIT=disk,SPACE=(TRK,(1))
//SYSUT4   DD  UNIT=disk,SPACE=(TRK,(1))
//SYSIN    DD  *
         COPY OUTDD=SYSUT2,INDD=SYSUT1
         SELECT MEMBER=(A,B,D,E,F)
/*
//STEPB   EXEC PGM=IEBCOMPR
//SYSPRINT DD  SYSOUT=*
//SYSUT1   DD  DISP=(OLD,KEEP),DSN=MAINDB.LOG.OLDSET
//SYSUT2   DD  DISP=(OLD,KEEP),DSN=MAINDB.LOG.NEWMEMS
//SYSIN    DD  *
         COMPARE TYPORG=PO
         EXITS   ERROR=SEEERROR
/*

The first job step copies the data set and passes the original and
copied data sets to the second job step. The second job step compares
the two data sets.

The control statements for the IEBCOMPR job step are discussed below:

x) SYSUT1 DD defines a blocked input data set (MAINDB.LOG.OLDSET) that
   is passed from the preceding job step. The data set resides on a
   disk or tape volume.

x) SYSUT2 DD defines a blocked input data set (MAINDB.LOG.NEWMEMS) that
  is passed from the preceding job step. The data set resides on a disk
  volume.

x) SYSIN DD defines the control data set, which follows in the input
   stream.

x) COMPARE TYPORG=PO specifies partitioned organization.

x) EXITS specifies that a user error routine, SEEERROR, is to be used.

Because the input data set names are not identical, the data sets can
be retrieved by their data set names.

>< ADD NAME=COMPR$08 0100-07003-07003-2113-00028-00028-00000-SC26UTL

Example 8: Compare Two PDSEs

In this example, two PDSEs are compared.

//DISKDISK JOB ...
//        EXEC PGM=IEBCOMPR
//SYSPRINT DD  SYSOUT=*
//SYSUT1   DD  DISP=(SHR),DSN=PDSE1
//SYSUT2   DD  DISP=(SHR),DSN=PDSE2
//SYSIN    DD  *
         COMPARE TYPORG=PO
/*

PDSEs no longer must be SMS managed. Because these PDSEs are cataloged,
you need not specify the UNIT or VOLUME parameters.

The control statements are discussed below:

x) SYSUT1 DD and SYSUT2 DD define input PDSEs, PDSE1, and PDSE2.
   Because no DCB values are specified, the DCB values that were
   specified in creating the data sets will be used.

x) SYSIN DD defines the control data set, which follows in the input
   stream.

x) COMPARE TYPORG=PO indicates that the input data sets are PDSEs.

./ ADD NAME=IEBCOPY  0666-07209-07209-1452-00001-00001-00000-DIR2UPDT
>< ADD NAME=COPY     0101-07003-07016-2325-00019-00018-00000-KTOMIAK

COPY$01   Copy an Entire Data Set
COPY$02   Merge Four Data Sets
COPY$03   Copy and Replace Selected Members of a Data Set
COPY$04   Unload and Compress a Data Set
COPY$05   Merge Data Sets and Compress the Merged Data Set
COPY$06   Multiple Copy Operations with One Output Data Set
COPY$07   Multiple Copy Operations with Different Output Data Sets
COPY$08   Loading a Data Set
COPY$09   Unload Selected Members, Load, Copy and Merge
COPY$10   Alter Load Modules in Place
COPY$11   Replace a Load Module Using COPYMOD
COPY$12   Reblock Load Library and Distribute It to Different Device
COPY$13   Convert a Partitioned Data Set to a PDSE
COPY$14   Copy Groups from a PDSE to a PDSE
COPY$15   Copy Groups from a PDSE to a PDSE with Replace
COPY$16   Copy a Selected Group from a PDSE to a PDSE

>< ADD NAME=COPY$01  0100-07003-07003-2113-00035-00035-00000-SC26UTL

Example 1: Copy an Entire Data Set

In this example, a partitioned data set (DATASET5) is copied from one
disk volume to another.

//COPY JOB ...
//JOBSTEP EXEC PGM=IEBCOPY
//SYSPRINT DD  SYSOUT=*
//SYSUT1   DD  DISP=(SHR),DSN=DATASET5
//SYSUT2   DD  DISP=(NEW,CATLG),DSN=DATASET4,
//             UNIT=disk,
//             SPACE=(TRK,(5,1,2))


The control statements are discussed below:

x) SYSUT1 DD defines a partitioned data set, DATASET5, that contains
   two members (A and C).

x) SYSUT2 DD defines a new partitioned data set, DATASET4, that is to
   be kept after the copy operation. Five tracks are allocated for the
   data set; two blocks are allocated for directory entries.

x) Because the partitioned data set has only two members, SYSUT3 and
   SYSUT4 DD are not needed.

x) Because the input and output data sets are identified as SYSUT1 and
   SYSUT2, the SYSIN data set is not needed. The SYSUT1 data set will
   be copied in full to the SYSUT2 data set. After the copy operation
   is finished, DATASET4 will contain the same members that are in
   DATASET5. However, there will be no embedded, unused space in
   DATASET4. If you are copying a PDSE, the processing is the same,
   except that there is no embedded, unused space in a PDSE.

>< ADD NAME=COPY$02  0100-07003-07003-2113-00060-00060-00000-SC26UTL

Example 2: Merge Four Data Sets

In this example, members are copied from three input partitioned data
sets (DATASET1, DATASET5, and DATASET6) to an existing output
partitioned data set (DATASET2). The sequence in which the control
statements occur controls the manner and sequence in which partitioned
data sets are processed.

//COPY JOB ...
//JOBSTEP EXEC PGM=IEBCOPY
//SYSPRINT DD  SYSOUT=*
//IN1      DD  DISP=(SHR),DSN=DATASET1
//IN5      DD  DISP=(OLD),DSN=DATASET5
//OUT2     DD  DISP=(OLD,KEEP),DSN=DATASET2
//IN6      DD  DISP=(OLD,DELETE),DSN=DATASET6
//SYSUT3   DD  UNIT=disk,SPACE=(TRK,(1))
//SYSIN    DD  *
COPYOPER COPY OUTDD=OUT2
         INDD=IN1
         INDD=IN6
         INDD=IN5
/*

The control statements are discussed below:

x) IN1 DD defines a partitioned data set (DATASET1).

x) IN5 DD defines a partitioned data set (DATASET5).

x) OUT2 DD defines a partitioned data set (DATASET2).

x) IN6 DD defines a partitioned data set (DATASET6). This data set
   is to be deleted when processing is completed.

x) SYSUT3 defines a temporary spill data set.

x) SYSIN DD defines the control data set, which follows in the input
   stream. The data set contains a COPY statement and three INDD
   statements.

x) COPY indicates the start of the copy operation. The OUTDD parameter
   specifies DATASET2 as the output data set.

x) The first INDD statement specifies DATASET1 as the first input data
   set to be processed. All members (A, B and F) are copied to
   DATASET2.

x) The second INDD statement specifies DATASET6 as the second input
   data set to be processed. Processing occurs as follows:

  1. Since replacement is not specified, members B and C, which already
     exist in DATASET2, are not copied to DATASET2.
  2. Member D is copied to DATASET2.
  3. All members in DATASET6 are lost when the data set is deleted.

x) The third INDD statement specifies DATASET5 as the third input data
   set to be processed. No members are copied to DATASET2 because all
   exist in DATASET2.

>< ADD NAME=COPY$03  0100-07003-07003-2113-00064-00064-00000-SC26UTL

Example 3: Copy and Replace Selected Members of a Data Set

In this example, two members (A and B) are selected from two input
partitioned data sets (DATASET5 and DATASET6) and copied to an existing
output partitioned data set (DATASET1). Member B replaces an
identically named member that already exists on the output data set.

//COPY JOB ...
//JOBSTEP EXEC PGM=IEBCOPY
//SYSPRINT DD  SYSOUT=*
//OUT1     DD  DISP=(OLD,KEEP),DSN=DATASET1
//IN6      DD  DISP=(OLD),DSN=DATASET6
//IN5      DD  DISP=(OLD,KEEP),DSN=DATASET5
//SYSUT3   DD  UNIT=disk,SPACE=(TRK,(1))
//SYSUT4   DD  UNIT=disk,SPACE=(TRK,(1))
//SYSIN    DD  *
COPYOPER COPY OUTDD=OUT1
         INDD=IN5,IN6
         SELECT MEMBER=((B,,R),A)
/*

The control statements are discussed below:

x) OUT1 DD defines a partitioned data set (DATASET1), which contains
   three members (A, B and F).

x) IN6 DD defines a partitioned data set (DATASET6), which contains
   three members (B, C and D).

x) IN5 DD defines a partitioned data set (DATASET5), which contains
   two members (A and C).

x) SYSUT3 and SYSUT4 DD define temporary spill data sets. One track is
   allocated for each on a disk volume.

x) SYSIN DD defines the control data set, which follows in the input
   stream. The data set contains a COPY statement, an INDD statement,
   and a SELECT statement.

x) COPY indicates the start of the copy operation. The use of a SELECT
   statement causes a selective copy. The OUTDD parameter specifies
   DATASET1 as the output data set.

x) INDD specifies DATASET5 as the first input data set to be processed
   and DATASET6 as the second input data set to be processed.
   Processing occurs as follows:

  1. Selected members are searched for on DATASET5.
  2. Member A is found, but is not copied to DATASET1 because DATASET1
     already has a member named "A", and the replace option is not
     specified for member A.
  3. Selected members not found on DATASET5 are searched for on
     DATASET6.
  4. Member B is found and copied to DATASET1, even though there is
     already a DATASET1 member "B" in DATASET1, because the replace
     option is specified for member B on the member level. The pointer
     in DATASET1's directory is changed to point to the new (copied)
     member B; thus, the space occupied by the old member B is unused.

x) SELECT specifies the members to be selected from the input data sets
   (DATASET5 and DATASET6) to be copied to the output data set
   (DATASET1).

>< ADD NAME=COPY$04  0100-07003-07003-2113-00073-00073-00000-SC26UTL

Example 4: Unload and Compress a Data Set

In this example, a partitioned data set is unloaded to a tape volume to
create a backup copy of the data set. If this step is successful, the
partitioned data set is to be compressed in place.

//SAVEJOB ...
//STEP1   EXEC PGM=IEBCOPY
//SYSPRINT DD  SYSOUT=*
//SYSUT1   DD  DISP=(OLD),DSN=PARTPDS
//SYSUT2   DD  DISP=(NEW,KEEP),DSN=SAVDATA,
//             UNIT=tape,LABEL=(,SL)
//SYSUT3   DD  DISP=(NEW,DELETE),DSN=&&TEMP1,
//             UNIT=disk
//             SPACE=(80,(60,45))
//SYSIN    DD  DUMMY
//*
//STEP2   EXEC PGM=IEBCOPY,COND=(0,NE),PARM='SIZE=500K'
//SYSPRINT DD  SYSOUT=*
//COMPDS   DD  DISP=(OLD),DSN=PARTPDS,UNIT=disk,
//             VOL=SER=PCP001
//SYSUT3   DD  DISP=(NEW,DELETE),DSN=&&TEMPA,
//             UNIT=disk,
//             SPACE=(80,(60,45))
//SYSIN    DD  *
         COPY OUTDD=COMPDS,INDD=COMPDS
/*

The control statements are discussed below:

x) SYSUT1 DD defines a partitioned data set (PARTPDS) that resides on
   a disk volume and is assumed to have 700 members. The number of
   members is used to calculate the space allocation on SYSUT3.

x) SYSUT2 DD defines a sequential data set to hold PARTPDS in unloaded
   form. Block size information can optionally be added; this data set
   must be NEW.

x) SYSUT3 DD defines the temporary spill data set. The SYSUT4 data set
   is never used for an unload operation.

x) SYSIN DD defines the control data set. Because SYSIN is dummied and
   SYSUT2 defines a sequential data set, all members of the SYSUT1 data
   set will be unloaded to the SYSUT2 data set.

x) The second EXEC statement marks the beginning of the
   compress-in-place operation. The SIZE parameter indicates that the
   buffers are to be as large as possible. The COND parameter indicates
   that the compress-in-place is to be performed only if the unload
   operation was successful.

x) COMPDS DD defines a partitioned data set (PARTPDS) that contains 700
   members and resides on a disk volume.

x) SYSUT3 DD defines the temporary spill data set to be used if there
   is not enough space in main storage for the input data set's
   directory entries. TEMPA contains one 80-character record for each
   member.

x) SYSIN DD defines the control data set, which follows in the input
   stream. The data set contains a COPY statement.

x) COPY marks the beginning of the copy operation. Because the same DD
   statement is specified for both the INDD and OUTDD operands, the
   data set is compressed in place. If a PDSE is being used, this step
   will not be processed.

If you want to unload more than one data set in a single use of
IEBCOPY, you must use a separate COPY statement for each unload
operation. Only one input data set may be specified in an unload
operation.

>< ADD NAME=COPY$05  0100-07003-07003-2113-00066-00066-00000-SC26UTL

Example 5: Merge Data Sets and Compress the Merged Data Set

In this example, two input partitioned data sets (DATASET5 and
DATASET6) are copied to an existing output partitioned data set
(DATASET1). In addition, all members on DATASET6 are copied; members on
the output data set that have the same names as the copied members are
replaced. After DATASET6 is processed, the output data set (DATASET1)
is compressed in place.

//COPY JOB ...
//JOBSTEP EXEC PGM=IEBCOPY
//SYSPRINT DD  SYSOUT=*
//INOUT1   DD  DISP=(OLD,KEEP),DSN=DATASET1
//IN5      DD  DISP=(OLD),DSN=DATASET5
//IN6      DD  DISP=(OLD,KEEP),DSN=DATASET6
//SYSUT3   DD  UNIT=disk,SPACE=(TRK,(1))
//SYSUT4   DD  UNIT=disk,SPACE=(TRK,(1))
//SYSIN    DD  *
COPYOPER COPY OUTDD=INOUT1,INDD=(IN5,(IN6,R),INOUT1)
/*


The control statements are discussed below:

x) INOUT1 DD defines a partitioned data set (DATASET1), which contains
   three members (A, B and F).

x) IN5 DD defines a partitioned data set (DATASET5), which contains two
   members (A and C).

x) IN6 DD defines a partitioned data set (DATASET6), which contains
   three members (B, C and D).

x) SYSUT3 and SYSUT4 DD define temporary spill data sets. One track is
   allocated for each on a disk volume.

x) SYSIN DD defines the control data set, which follows in the input
   stream. The data set contains a COPY statement.

x) COPY indicates the start of the copy operation. The OUTDD operand
   specifies DATASET1 as the output data set.

x) The INDD operand specifies DATASET5 as the first input data set to
   be processed. It then specifies DATASET6 as the second input data
   set to be processed. In addition, the replace option is specified
   for all members copied from DATASET6. Finally, it specifies DATASET1
   as the last input data set to be processed. Since DATASET1 is also
   the output data set, DATASET1 is compressed in place. However, if
   DATASET1 is a PDSE, the compress-in-place operation will not be
   processed. Processing occurs as follows:

  1. Member A is not copied from DATASET5 into DATASET1 because it
     already exists on DATASET1 and the replace option was not
     specified for DATASET5.
  2. Member C is copied from DATASET5 to DATASET1, occupying the first
     available space.
  3. All members are copied from DATASET6 to DATASET1, immediately
     following the last member. Members B and C are copied even though
     the output data set already contains members with the same names
     because the replace option is specified on the data set level. The
     pointers in DATASET1's directory are changed to point to the new
     members B and C. Thus, the space occupied by the old members B and
     C is unused. The members currently on DATASET1 are compressed in
     place, thereby eliminating embedded unused space.

>< ADD NAME=COPY$06  0100-07003-07003-2113-00099-00099-00000-SC26UTL

Example 6: Multiple Copy Operations with One Output Data Set

In this example, members are selected, excluded, and copied from input
partitioned data sets onto an output partitioned data set. This example
is designed to illustrate multiple copy operations.

The example follows.

//COPY JOB ...
//JOBSTEP EXEC PGM=IEBCOPY
//SYSPRINT DD  SYSOUT=*
//INOUTA   DD  DISP=(OLD),DSN=DATASETA
//INB      DD  DISP=(OLD),DSN=DATASETB
//INC      DD  DISP=(OLD),DSN=DATASETC
//IND      DD  DISP=(OLD),DSN=DATASETD
//INE      DD  DISP=(OLD),DSN=DATASETE
//OUTX     DD  DISP=(NEW,CATLG),DSN=DATASETX,
//             UNIT=disk,
//             SPACE=(TRK,(3,1,2))
//SYSUT3   DD  UNIT=disk,SPACE=(TRK,(1))
//SYSIN    DD  *
COPERST1 COPY    O=OUTX,I=INOUTA
         COPY    OUTDD=INOUTA,INDD=INOUTA
         INDD=INB
         COPY    OUTDD=INOUTA
         INDD=IND
         EXCLUDE MEMBER=MM
         INDD=INC
         SELECT  MEMBER=((ML,MD,R))
         INDD=INE
/*

The control statements are discussed below:

x) INOUTA DD defines a partitioned data, DATASETA, which contains seven
   members (MA, MB, MC, MD, ME, MF and MG).

x) INB DD defines a partitioned data set, DATASETB, which contains two
   members (MA and MJ).

x) INC DD defines a partitioned data set,
   DATASETC, which contains four members (MF, ML, MM and MN).

x) IND DD defines a partitioned data set, DATASETD, which contains two
   members (MM and MP).

x) INE DD defines a partitioned data set, DATASETE, which contains four
   members (MD, ME, MF and MT).

x) OUTX DD defines a partitioned data set (DATASETX). This data set is
  new and is to be kept after the copy operation. Three tracks are
  allocated for the data set on a disk volume. Two blocks are allocated
  for directory entries.

x) SYSUT3 defines a temporary spill data set.

x) SYSIN DD defines the control data set, which follows in the input
   stream. The data set contains two COPY statements, several INDD
   statements, a SELECT statement, and an EXCLUDE statement.

x) The first COPY statement indicates the start of the first copy
   operation. This copy operation is done to create a backup copy of
   DATASETA.

x) The second COPY statement indicates the start of another copy
   operation. Since DATASETA is specified in both the INDD and OUTDD
   parameters, DATASETA is compressed in place. The output data set is
   compressed in place first to save space because it is known that it
   contains embedded, unused space.

x) The following INDD statement
   specifies DATASETB as the next input data set to be copied. Only
   member MJ is copied, because DATASETA already contains a member
   named "MA".

x) The third COPY statement indicates the start of the third copy
   operation. The OUTDD parameter specifies DATASETA as the output data
   set. This copy operation contains more than one copy step.

x) The first INDD statement specifies DATASETD as the first input data
   set to be processed. Only member MP is copied to DATASETA because
   the EXCLUDE statement specifies that member MM is to be excluded
   from the first copy step within this copy operation.

x) The second INDD statement marks the beginning of the second copy
   step for this copy operation and specifies DATASETC as the second
   input data set to be processed. The SELECT statement specifies that
   member ML of DATASETC is to be renamed "MD", and that the new member
   will replace any member in DATASETA that happens to be named "MD".
   Member ML is searched for, found, copied to DATASETA and renamed.

x) The third INDD statement marks the beginning of the third copy step
   for this copy operation and specifies DATASETE as the last data set
   to be copied. Only member MT is copied, because DATASETA already
   contains the other members. Because the INDD statement is not
   followed by an EXCLUDE or SELECT statement, a full copy is
   performed.

>< ADD NAME=COPY$07  0100-07003-07003-2113-00100-00100-00000-SC26UTL

Example 7: Multiple Copy Operations with Different Output Data Sets

In this example, members are selected, excluded, and copied from input
partitioned data sets to an output partitioned data set. This example
is designed to illustrate multiple copy operations.

The example follows:

//COPY JOB ...
//JOBSTEP EXEC PGM=IEBCOPY
//SYSPRINT DD  SYSOUT=*
//OUTA     DD  DISP=(OLD),DSN=DATASETA
//INOUTB   DD  DISP=(OLD),DSN=DATASETB
//INOUTC   DD  DISP=(OLD,KEEP),DSN=DATASETC
//INOUTD   DD  DISP=(OLD),DSN=DATASETD
//INE      DD  DISP=(OLD),DSN=DATASETE
//SYSUT3   DD  UNIT=disk,SPACE=(TRK,(1))
//SYSUT4   DD  UNIT=disk,SPACE=(TRK,(1))
//SYSIN    DD  *
         COPY    OUTDD=OUTA
         INDD=INE
         SELECT  MEMBER=(MA,MJ)
         INDD=INOUTC
         EXCLUDE MEMBER=(MM,MN)
         COPY    OUTDD=INOUTB,INDD=INOUTD
         INDD=((INOUTC,R),INOUTB)
         COPY    OUTDD=INOUTD,INDD=((INOUTB,R))
         SELECT  MEMBER=MM
/*

The control statements are discussed below:

x) OUTA DD defines a partitioned data set, DATASETA, which contains
   three members (MA, MB and MD).

x) INOUTB DD defines a partitioned data set, DATASETB, which contains
   two members (MA and MJ).

x) INOUTC DD defines a partitioned data set, DATASETC, which contains
   four members (MF, ML, MM and MN).

x) INOUTD DD defines a partitioned data set, DATASETD, which contains
   two members (MM and MP).

x) INE DD defines a partitioned data set, DATASETE, which contains
   three members (MA, MJ and MK).

x) SYSUT3 and SYSUT4 DD define temporary spill data sets. One track is
   allocated for each on a disk volume.

x) SYSIN DD defines the control data set, which follows in the input
   stream. The data set contains three COPY statements, two SELECT
   statements, one EXCLUDE statement, and several INDD statements.

x) The first COPY statement indicates the start of a copy operation.
   The OUTDD operand specifies DATASETA as the output data set.

x) The first INDD statement specifies DATASETE as the first input data
   set to be processed. The SELECT statement specifies that members MA
   and MJ are to be copied from DATASETE to DATASETA. Processing occurs
   as follows:

  1. Member MA is searched for and found, but is not copied because the
     replace option is not specified.
  2. Member MJ is searched for, found, and copied to DATASETA.

x) The second INDD statement marks the end of the first copy step and
   the beginning of the second copy step within the first copy
   operation. It specifies DATASETC as the second input data set to be
   processed. Members MF and ML, which are not named on the EXCLUDE
   statement, are copied because DATASETA contains neither one of them.
   EXCLUDE specifies that members MM and MN are not to be copied from
   DATASETC to DATASETA.

x) The second COPY statement indicates the start of another copy
   operation. The OUTDD parameter specifies DATASETB as the output data
   set. The INDD parameter specifies DATASETD as the first input data
   set to be processed. Members MP and MM are copied to DATASETB.

x) The next INDD statement specifies DATASETC as the second and
   DATASETB as the third input data set to be processed. Members MF,
   ML, MM and MN are copied from DATASETC. Member MM is copied,
   although DATASETB already contains a member MM, because the replace
   option is specified.

   The pointer in DATASETB's directory is changed to point to the new
   (copied) member MM. Thus, the space occupied by the replaced member
   MM is embedded, unused space. DATASETB is then compressed in place
   to remove embedded, unused space. (DATASETB is specified as both the
   input and output data sets.)

x) The third COPY statement indicates the start of the last copy
  operation. The OUTDD parameter specifies DATASETD as the output data
  set. The INDD parameter specifies DATASETB as the input data set.

x) SELECT specifies that member MM is to be copied from DATASETB to
   DATASETD. Since the replace option is specified on the data set
   level, member MM is copied and replaces DATASETDs member MM.

>< ADD NAME=COPY$08  0100-07003-07003-2113-00037-00037-00000-SC26UTL

Example 8: Loading a Data Set

In this example, a sequential data set that was created by an IEBCOPY
unload operation is loaded.

//LOAD JOB ...
//STEPA   EXEC PGM=IEBCOPY
//SYSPRINT DD  SYSOUT=*
//SYSUT1   DD  DISP=(OLD),DSN=UNLOADSET
//SYSUT2   DD  DISP=(NEW,CATLG),DSN=DATASET4,
//             UNIT=disk,
//             SPACE=(CYL,(10,5,10))
//SYSUT3   DD  DISP=(NEW,DELETE),DSN=&&TEMP1,
//             UNIT=disk,
//             SPACE=(80,(15,1))
//SYSIN    DD  DUMMY
/*

The control statements are discussed below:

x) SYSUT1 DD defines a sequential data set that was previously created
   by an IEBCOPY unload operation. The data set contains 28 members in
   sequential organization.

x) SYSUT2 DD defines a new partitioned data set on a disk volume. This
   data set is to be kept after the load operation. Ten cylinders are
   allocated for the data set; ten blocks are allocated for directory
   entries.

x) SYSUT3 DD defines a temporary spill data set on a disk volume.

x) SYSIN DD defines the control data set. Because SYSIN is dummied,
   SYSUT1 defines a sequential data set, and SYSUT2 defines a
   partitioned data set, the entire SYSUT1 data set will be loaded into
   the SYSUT2 data set.

>< ADD NAME=COPY$09  0100-07003-07003-2113-00100-00100-00000-SC26UTL

Example 9: Unload Selected Members, Load, Copy and Merge

In this example, members are selected, excluded, unloaded, loaded, and
copied. Processing will occur as follows:

  1. unload, excluding members
  2. unload, selecting members
  3. load and copy to merge members

//COPY JOB ...
//STEP    EXEC PGM=IEBCOPY
//SYSPRINT DD  SYSOUT=*
//PDS1     DD  DISP=(OLD),DSN=ACCOUNTA
//PDS2     DD  DISP=(OLD),DSN=ACCOUNTB
//SEQ1     DD  DISP=(NEW,CATLG),DSN=SAVAC,
//             UNIT=disk,
//             SPACE=(CYL,(5,2))
//SEQ2     DD  DISP=(NEW,CATLG),DSN=SAVACB,
//             UNIT=tape,
//             LABEL=(,SL)
//NEWUP    DD  DISP=(OLD),DSN=NEWACC
//MERGE    DD  DISP=(OLD),DSN=ACCUPDAT
//SYSUT3   DD  DISP=(NEW,DELETE),DSN=&&TEMP1,
//             UNIT=disk,
//             SPACE=(80,(1,1))
//SYSUT4   DD  DISP=(NEW,DELETE),DSN=&&TEMP2,
//             UNIT=disk,
//             SPACE=(256,(1,1)),DCB=(KEYLEN=8)
//SYSIN DD  *
         COPY    OUTDD=SEQ1,INDD=PDS1
         EXCLUDE MEMBER=(D,C)
         COPY    OUTDD=SEQ2,INDD=PDS2
         SELECT  MEMBER=(A,K)
         COPY    OUTDD=MERGE,INDD=((NEWUP,R),PDS1,PDS2)
         EXCLUDE MEMBER=A
/*

The control statements are discussed below:

x) PDS1 DD defines a partitioned data set called ACCOUNTA that contains
   six members (A, B, C, D, E, and F).

x) PDS2 DD defines a partitioned data set called ACCOUNTB that contains
   three members (A, K, and L).

x) SEQ1 DD defines a new sequential data set called SAVAC.

x) SEQ2 DD defines a new sequential data set called SAVACB on a tape
   volume. The tape has IBM standard labels.

x) NEWUP DD defines an old sequential data set called NEWACC that is
   the unloaded form of a partitioned data set that contains eight
   members (A, B, C, D, M, N, O, and P). It resides on a tape volume.

x) MERGE DD defines a partitioned data set called ACCUPDAT that
   contains six members (A, B, C, D, Q, and R).

x) SYSUT3 and SYSUT4 DD define temporary spill data sets.

x) SYSIN DD defines the control data set, which follows in the input
   stream.

x) The first COPY statement indicates the start of the first copy
   operation. The OUTDD parameter specifies that SAVAC is the output
   data set, and the INNDD parameter specifies that ACCOUNTA is the
   input data set. Because SAVAC is a sequential data set, ACCOUNTA
   will be unloaded in this copy operation.

x) The EXCLUDE statement specifies that members D and C are not to be
   unloaded to SAVAC with the rest of ACCOUNTA.

x) The second COPY statement indicates the start of the second copy
   operation.

x) The OUTDD parameter specifies that SAVACB is the output data set,
   and the INDD parameter specifies that ACCOUNTB is the input data
   set. Because SAVACB is a sequential data set, ACCOUNTB will be
   unloaded in this copy operation.

x) The SELECT statement specifies that members A and K are the only
   members of ACCOUNTB that are to be unloaded to SAVACB.

x) The third COPY statement indicates the start of the last copy
   operation. The OUTDD parameter specifies that ACCUPDAT is the output
   data set. The EXCLUDE statement specifies that member A is excluded
   from this copy operation. The three data sets specified in the INDD
   parameter will be processed as follows:

  1. The data set NEWACC is a sequential data set, so it is loaded into
     ACCUPDAT. Because the replace option is specified, members B, C,
     and D in NEWACC replace identically named members in ACCUPDAT. The
     remaining members of NEWACC are also copied to ACCUPDAT, except
     for A, which is excluded from the copy operation.
  2. The data set ACCOUNTA is a partitioned data set, so its members
     are copied to ACCUPDAT. Because replacement is not specified, only
     members E and F are copied.
  3. The data set ACCOUNTB is a partitioned data set, so its members
     are copied to ACCUPDAT. Only members K and L are copied.

>< ADD NAME=COPY$10  0100-07003-07003-2113-00047-00047-00000-SC26UTL

Example 10: Alter Load Modules in Place

In this example, all members of data set MODLIBJ, members MODX, MODY,
and MODZ of data set MODLIBK, and all members of data set MODLIBL,
except MYMACRO and MYJCL, are altered in place.

//ALTERONE JOB ...
//STEPA   EXEC PGM=IEBCOPY
//SYSPRINT DD  SYSOUT=*
//SYSUT3   DD  UNIT=disk,SPACE=(TRK,(5,1))
//LIBJ     DD  DISP=(OLD),DSN=MODLIBJ
//LIBK     DD  DISP=(OLD),DSN=MODLIBK
//LIBL     DD  DISP=(OLD),DSN=MODLIBL
//SYSIN    DD  *
         ALTERMOD OUTDD=LIBJ
         ALTERMOD OUTDD=LIBK,LIST=NO
         SELECT   MEMBER=(MODX,MODY,MODZ)
         ALTERMOD OUTDD=LIBL
         EXCLUDE  MEMBER=(MYMACRO,MYJCL)
/*

The control statements are discussed below:

x) LIBJ DD defines the partitioned data set MODLIBJ, which has been
   previously created and cataloged.

x) LIBK DD defines the partitioned data set MODLIBK, which has been
   previously created and cataloged.

x) LIBL DD defines the partitioned data set MODLIBL, which has been
   previously created and cataloged.

x) SYSIN DD defines the control data set, which follows in the input
   stream.

x) The first ALTERMOD statement specifies that the entire data set
   defined in LIBJ is to be altered in place.

x) The second ALTERMOD statement plus the following SELECT statement
   indicates that members MODX, MODY, and MODZ are to be altered in
   place. The remainder of MODLIBK is unchanged.

x) The third ALTERMOD statement plus the following EXCLUDE statement
  indicates that all of MODLIBL is to be altered in place except the
  members called MYMACRO and MYJCL. These members remain unchanged.

>< ADD NAME=COPY$11  0100-07003-07003-2113-00050-00050-00000-SC26UTL

Example 11: Replace a Load Module Using COPYMOD

In this example, a load module in an existing load library is replaced
by another module. The new module originally resides on a 3390 DASD
device, whereas the load library to which it is copied resides on a
3380. Because the module has a block size larger than the block size
assigned to the output data set, the module must be reblocked before it
is added to the load library.

This example illustrates how you can transfer load modules between
devices of different sizes. In this case, updated modules are created
on a 3390 and tested before being added to the load library for general
use.

//REPLACE JOB ...
//STEP1   EXEC PGM=IEBCOPY
//SYSPRINT DD  SYSOUT=*
//TESTLIB  DD  DISP=(SHR),DSN=JOHNDOE.COBOL.TESTLOAD
//PRODLIB  DD  DISP=(OLD),DSN=PAYROLL.MASTER.LOADLIB
//SYSIN    DD  *
         COPYMOD OUTDD=PRODLIB,INDD=TESTLIB
         SELECT  MEMBER=((WAGETAX,,R))
/*

The control statements are discussed below:

x) TESTLIB DD defines a load library on a 3390 direct access device. It
   has a block size of 23470.

x) PRODLIB DD defines a load library on a 3380 direct access device. It
   has a block size of 19069.

x) SYSIN DD defines the control data set, which follows in the input
   stream.

x) The COPYMOD statement identifies PAYROLL.MASTER.LOADLIB as the
   output data set and JOHNDOE.COBOL.TESTLOAD as the input data set.
   The SELECT statement indicates that the load module WAGETAX is to be
   copied from the input data set and is to replace any member with
   that name that is in the output data set. The member is also
   reblocked to 19069.

Note that, in this case, COPYMOD has to be used in order to copy the
member WAGETAX into the PAYROLL.MASTER.LOADLIB. Because the original
block size of WAGETAX is larger than the largest block size that can
reside in the output data set, attempting this operation with the COPY
statement would be unsuccessful. The problem would be attributed to a
DCB validation error because of incorrect block size.

>< ADD NAME=COPY$12  0100-07003-07003-2113-00066-00066-00000-SC26UTL

Example 12: Reblock Load Library and Distribute It to Different Device
Types

In this example, a load library is distributed (by copying it) to
devices whose maximum block size differs from that on which the
original load library resides. The library is first reblocked to a
maximum block size that is compatible with each of the devices to which
the library will be copied. Then, the library is copied to those
devices.

This example illustrates how load libraries can be developed on one
type of direct access device and then distributed to other types of
direct access devices.

//RBLKCOPY JOB ...
//REBLOCK EXEC PGM=IEBCOPY
//SYSPRINT DD  SYSOUT=*
//TESTED   DD  DISP=(SHR),DSN=TESTED.MASTER.LOADLIB
//STDSIZE  DD  DISP=(OLD),DSN=PROGRAM.MASTER.LOADLIB
//SYSIN    DD  *
         COPYMOD OUTDD=STDSIZE,INDD=TESTED,MAXBLK=13030
/*
//DISTRIB EXEC PGM=IEBCOPY
//SYSPRINT DD  SYSOUT=*
//STDSIZE  DD  DISP=(SHR),DSN=PROGRAM.MASTER.LOADLIB
//LIB3350  DD  DISP=(OLD),DSN=PROGRAM.LIB3380.LOADLIB
//LIB3330  DD  DISP=(OLD),DSN=PROGRAM.LIB3380.LOADLIB
//SYSIN    DD  *
         COPY OUTDD=LIB3380,INDD=STDSIZE
         COPY OUTDD=LIB3380,INDD=STDSIZE
/*

The control statements are discussed below:

x) The REBLOCK EXEC statement begins the reblocking step.

x) TESTED DD defines the cataloged load library TESTED.MASTER.LOADLIB.

x) STDSIZE DD defines an existing data set, PROGRAM.MASTER.LOADLIB,
   which resides on a 3390 direct access device and has a block size of
   23470.

x) The COPYMOD statement in the SYSIN data set specifies that
   TESTED.MASTER.LOADLIB is to be merged into PROGRAM.MASTER.LOADLIB.
   It also specifies that PROGRAM.MASTER.LOADLIB is to be reblocked
   with a maximum block size of 13030. This block size is chosen
   because it is small enough to fit on both 3380 and 3390 direct
   access devices.

x) The DISTRIB EXEC statement begins the distribution step, where the
   reblocked data set is copied to devices with different maximum block
   sizes.

x) STDSIZE DD defines the same data set that was reblocked in the
   previous step.

x) LIB3380 DD defines the data set PROGRAM.LIB3380.LOADLIB, which
   resides on a 3380 direct access device.

x) The COPY statements in the SYSIN data set specify that the data set
   PROGRAM.MASTER.LOADLIB is to be copied to the output data sets
   without being reblocked. If PROGRAM.MASTER.LOADLIB had not been
   reblocked to the smaller block size, this step would end
   unsuccessfully.

>< ADD NAME=COPY$13  0100-07003-07003-2113-00034-00034-00000-SC26UTL

Example 13: Convert a Partitioned Data Set to a PDSE

In this example, a partitioned data set is converted to a PDSE.

//CONVERT JOB ...
//STEP1   EXEC PGM=IEBCOPY
//SYSPRINT DD  SYSOUT=*
//SYSUT1   DD  DISP=(SHR),DSN=PDSSET
//SYSUT2   DD  DISP=(NEW,CATLG),DSN=PDSESET,
//             LIKE=PDSSET,DSNTYPE=LIBRARY,
//             STORCLAS=SCLASX,DATACLAS=DCLASY

The control statements are discussed below:

x) SYSUT1 DD defines the input data set, PDSSET, which is a partitioned
   data set.

x) SYSUT2 DD defines the output data set, PDSESET, which is a
   partitioned data set extended. This new data set will be SMS-managed
   because it has a storage class.

x) The LIKE parameter indicates that the DCB and SPACE attributes for
   PDSESET are to be copied from PDSSET. The DSNTYPE parameter defines
   the new data set as a PDSE rather than as a partitioned data set.
   DATACLAS=DCLASY identifies the PPDSE as a program object PDSE with
   undefined logical record length.

x) The Storage Management Subsystem chooses an appropriate volume for
   the allocation, based on how SCLASX was defined.

x) Since the ddnames "SYSUT1" and "SYSUT2" are used to define the input
   and output data sets, no SYSIN data set is required.

>< ADD NAME=COPY$14  0100-07003-07003-2113-00045-00045-00000-SC26UTL

Example 14: Copy Groups from a PDSE to a PDSE

In this example, members and their aliases (groups) are copied from a
PDSE to a PDSE (full data set copy). See "Copying Program Objects
(COPYGRP Statement)" on page 28 for information about copying groups.

//CPYGRP JOB ...
//STEP1   EXEC PGM=IEBCOPY
//SYSPRINT DD  SYSOUT=*
//DDIN     DD  DISP=(SHR),DSN=PDSESETA
//DDOUT    DD  DISP=(NEW,CATLG),DSN=PDSESETB,
//             LIKE=PDSESETA,DSNTYPE=LIBRARY
//SYSUT3   DD  UNIT=disk,SPACE=(TRK,(1,1))
//SYSIN    DD  *
GROUPCPY COPYGRP INDD=DDIN,OUTDD=DDOUT
/*

The control statements are discussed below:

x) DDIN DD defines the input data set, PDSESETA, which is a partitioned
   data set extended.

x) DDOUT DD defines the output data set, PDSESETA, which is a
   partitioned data set extended.

x) The LIKE subparameter indicates that the DCB and SPACE attributes
   for PDSESETB are to be copied from PDSESETA. The DSNTYPE
   subparameter defines the new data set as a PDSE.

x) The Storage Management Subsystem chooses an appropriate volume for
   the allocation.

x) SYSUT3 DD defines a temporary spill data set.

x) SYSIN DD defines the control data set, which follows in the input
   stream. The data set contains a COPYGRP statement, an INDD
   statement, and an OUTDD statement.

x) COPYGRP indicates the start of the copy operation.

x) The INDD parameter shows PDSESETA as the input data set.

x) The OUTDD parameter shows PDSESETB as the output data set.

>< ADD NAME=COPY$15  0100-07003-07003-2113-00049-00049-00000-SC26UTL

Example 15: Copy Groups from a PDSE to a PDSE with Replace

In this example, members and their aliases are copied in groups from a
PDSE to a PDSE with the replace (R) option. See "Replacing Program
Objects" on page 29 for information about replacing groups with
COPYGRP.

//CPYGRP JOB ...
//STEP1   EXEC PGM=IEBCOPY
//SYSPRINT DD  SYSOUT=*
//DDIN     DD  DISP=(SHR),DSN=PDSESETA
//DDOUT    DD  DISP=(NEW,CATLG),DSN=PDSESETB,
//             LIKE=PDSESETA,DSNTYPE=LIBRARY
//SYSUT3   DD  UNIT=disk,SPACE=(TRK,(1,1))
//SYSIN    DD  *
GROUPCPY COPYGRP INDD=((DDIN,R)),OUTDD=DDOUT
/*

The control statements are discussed below:

x) DDIN DD defines the input data set, PDSE, which is a partitioned
   data set extended.

x) DDOUT DD defines the output data set, PDSE, which is a partitioned
   data set extended.

x) The LIKE parameter indicates that the DCB and SPACE attributes for
   PDSESETB are to be copied from PDSESETA.

x) The DSNTYPE parameter defines the new data set as a PDSE.

x) The Storage Management Subsystem chooses an appropriate volume for
   the allocation.

x) SYSUT3 DD defines a temporary spill data set.

x) SYSIN DD defines the control data set, which follows in the input
   stream. The data set contains a COPYGRP statement, an INDD
   statement, and an OUTDD statement.

x) COPYGRP indicates the start of the copy operation.

x) The ((INDD,R)) parameter shows PDSESETA as the input data set
   containing members to replace members with the same name in
   PDSESETB.

x) The OUTDD parameter shows PDSESETB as the output data set.

>< ADD NAME=COPY$16  0100-07003-07003-2113-00055-00055-00000-SC26UTL

Example 16: Copy a Selected Group from a PDSE to a PDSE

In this example, a selected member and its aliases are copied from a
PDSE to a PDSE. Either the member's name or a maximum of eight
characters can be given on the SELECT statement. See "Copying Program
Objects (COPYGRP Statement)" on page 28 for information about selecting
groups on COPYGRP.

//CPYGRP JOB ...
//STEP1   EXEC PGM=IEBCOPY
//SYSPRINT DD  SYSOUT=*
//DDIN     DD  DISP=(SHR),DSN=PDSESETA
//DDOUT    DD  DISP=(NEW,CATLG),DSN=PDSESETB,
               LIKE=PDSESETA,DSNTYPE=LIBRARY
//SYSUT3   DD  UNIT=disk,SPACE=(TRK,(1,1))
//SYSIN    DD  *
GROUPCPY COPYGRP INDD=DDIN,OUTDD=DDOUT
         SELECT  MEMBER=(ALIAS001)
/*

The control statements are discussed below:

x) DDIN DD defines the input data set, PDSE, which is a partitioned
   data set extended.

x) DDOUT DD defines the output data set, PDSE, which is a partitioned
   data set extended.

x) All PDSEs must be managed by the Storage Management Subsystem.

x) The LIKE parameter indicates that the DCB and SPACE attributes for
   PDSESETB are to be copied from PDSESETA.

x) The DSNTYPE parameter defines the new data set as a PDSE.

x) The Storage Management Subsystem chooses an appropriate volume for
   the allocation.

x) SYSUT3 DD defines a temporary spill data set.

x) SYSIN DD defines the control data set, which follows in the input
   stream. The data set contains a COPYGRP statement, an INDD
   statement, and an OUTDD statement.

x) COPYGRP indicates the start of the copy operation.

x) The INDD parameter shows PDSESETA as the input data set.

x) The OUTDD parameter shows PDSESETB as the output data set.

x) The SELECT statement indicates that a group that has the alias
   ALIAS001 is to be selected from the input data set (PDSESETA) and
   copied to the output data set (PDSESETB).

./ ADD NAME=IEBDG    0666-07209-07209-1453-00001-00001-00000-DIR2UPDT
>< ADD NAME=DG       0101-07003-07016-2326-00008-00008-00000-KTOMIAK

DG$01  Place Binary Zeros in Records Copied from Sequential Data
DG$02  Ripple 10-byte Alphabetic Pattern
DG$03  Create Output Records from Utility Control Statements
DG$04  Use Members and Input Records as Basis of Output Member
DG$05  Create Records in Three Output Data Sets and Write them
DG$06  Construct Records with Your Own Patterns

>< ADD NAME=DG$01    0100-07003-07003-2113-00055-00055-00000-SC26UTL

Example 1: Place Binary Zeros in Records Copied from Sequential Data
Set

In this example, binary zeros are placed in two fields of 100 records
copied from a sequential data set. After the operation, each record in
the copied data set (OUTSET) contains binary zeros in locations 20
through 29 and 50 through 59.

//CLEAROUT JOB ...
//STEP1   EXEC PGM=IEBDG
//SYSPRINT DD  SYSOUT=*
//SEQIN    DD  DISP=(OLD,KEEP),DSN=INSET,
//             DCB=(RECFM=FB,BLKSIZE=800,LRECL=80),
//             UNIT=tape,LABEL=(,NL)
//SEQOUT   DD  DISP=(NEW,KEEP),DSN=OUTSET,
//             UNIT=tape,LABEL=(,SL),
//             DCB=(RECFM=FB,BLKSIZE=32760,LRECL=80)   <==close to 32K
//SYSIN    DD  *
         DSD    OUTPUT=(SEQOUT),INPUT=(SEQIN)
         FD     NAME=FIELD1,LENGTH=10,STARTLOC=20
         FD     NAME=FIELD2,LENGTH=10,STARTLOC=50
         CREATE QUANTITY=100,INPUT=SEQIN,NAME=(FIELD1,FIELD2)
         END
/*

The control statements are discussed below:

x) SEQIN DD defines a sequential input data set (INSET). The data set
   was originally written on a unlabeled tape volume.

x) SEQOUT DD defines the test data set (OUTSET). The output records are
   identical to the input records, except for locations 20 through 29
   and 50 through 59, which contain binary zeros at the completion of
   the operation.

x) SYSIN DD defines the control data set, which follows in the input
   stream.

x) DSD marks the beginning of a set of utility control statements and
   refers to the DD statements defining the input and output data sets.

x) The first and second FD statements create two 10-byte fields (FIELD1
   and FIELD2). Because no pattern is specified for these fields, each
   field contains the default fill of binary zeros. The fields are to
   begin in the 20th and 50th bytes of each output record.

x) CREATE constructs 100 output records in which the contents of
   previously defined fields (FIELD1, FIELD2) are placed in their
   respective starting locations in each of the output records. Input
   records from data set INSET are used as the basis of the output
   records.

x) END signals the end of a set of utility control statements.

>< ADD NAME=DG$02    0100-07003-07003-2113-00050-00050-00000-SC26UTL

Example 2: Ripple 10-byte Alphabetic Pattern

In this example, a 10-byte alphabetic pattern is rippled. At the end of
the job step the first output record contains "ABCDEFGHIJ", followed by
data in location 11 through 80 from the input record; the second record
contains "BCDEFGHIJK" followed by data in locations 11 through 80, and
so forth.

//RIPPLEJOB ...
//STEP1   EXEC PGM=IEBDG
//SYSPRINT DD  SYSOUT=*
//SEQIN    DD  DISP=(OLD),DSN=INSET
//SEQOUT   DD  DISP=(NEW,CATLG),DSN=OUTSET,
//             UNIT=disk,
//             SPACE=(TRK,(10,10))
//             DCB=(RECFM=FB,BLKSIZE=0,LRECL=80)
//SYSIN    DD  *
         DSD    OUTPUT=(SEQOUT),INPUT=(SEQIN)
         FD     NAME=FIELD1,LENGTH=10,FORMAT=AL,ACTION=RP,STARTLOC=1
         CREATE QUANTITY=100,INPUT=SEQIN,NAME=FIELD1
         END
/*

The control statements are discussed below:

x) SEQIN DD defines an input sequential data set (INSET). The data set
   was originally written on a standard labeled tape volume.

x) SEQOUT DD defines the test output data set (OUTSET). Ten tracks of
   primary space and ten tracks of secondary space are allocated for
   the sequential data set on a disk volume.

x) SYSIN DD defines the control data set, which follows in the input
   stream.

x) DSD marks the beginning of a set of utility control statements and
   refers to the DD statements defining the input and output data sets.

x) The FD statement creates a 10-byte field in which the pattern
   ABCDEFGHIJ is initially placed. The data is rippled after each
   output record is written.

x) CREATE constructs 100 output records in which the contents of a
   previously defined field (FIELD1) are included. The CREATE statement
   uses input records from data set INSET as the basis of the output
   records.

x) END signals the end of a set of utility control statements.

>< ADD NAME=DG$03    0100-07003-07003-2113-00053-00053-00000-SC26UTL

Example 3: Create Output Records from Utility Control Statements

In this example, output records are created entirely from utility
control statements. Three fields are created and used in the
construction of the output records. In two of the fields, alphabetic
data is truncated; the other field is a numeric field that is
incremented (indexed) by one after each output record is written.

//UTLYONLY JOB ...
//STEP1   EXEC PGM=IEBDG
//SYSPRINT DD  SYSOUT=*
//SEQOUT   DD  DISP=(NEW,CATLG),DSN=OUTSET,
//             UNIT=disk,
//             SPACE=(TRK,(10,10)),
//             DCB=(RECFM=FB,BLKSIZE=0,LRECL=80)
//SYSIN    DD  DATA
         DSD    OUTPUT=(SEQOUT)
         FD     NAME=FIELD1,LENGTH=30,STARTLOC=1,FORMAT=AL,ACTION=TL
         FD     NAME=FIELD2,LENGTH=30,STARTLOC=31,FORMAT=AL,ACTION=TR
         FD     NAME=FIELD3,LENGTH=10,STARTLOC=71,PICTURE=10,          X
               P'1234567890',INDEX=1
         CREATE QUANTITY=100,NAME=(FIELD1,FIELD2,FIELD3),FILL=X'FF'
         END
/*

The control statements are discussed below:

x) SEQOUT DD defines the test output data set. Ten tracks of primary
   space and ten tracks of secondary space are allocated for the
   sequential data set on a disk volume.

x) SYSIN DD defines the control data set, which follows in the input
   stream.

x) DSD marks the beginning of a set of utility control statements and
   refers to the DD statement defining the output data set.

x) FD defines the contents of three fields to be used in the
   construction of output records. The first field contains 30 bytes of
   alphabetic data to be truncated left after each output record is
   written. The second field contains 30 bytes of alphabetic data to be
   truncated right after each output record is written. The third field
   is a 10-byte field containing a packed decimal number (1234567890)
   to be increased by one after each record is written.

x) CREATE constructs 100 output records in which the contents of
   previously defined fields (FIELD1, FIELD2, and FIELD3) are included.
   Note that after each record is written, FIELD1 and FIELD2 are
   restored to full width.

x) END signals the end of a set of utility control statements.

>< ADD NAME=DG$04    0100-07003-07003-2113-00075-00075-00000-SC26UTL

Example 4: Use Members and Input Records as Basis of Output Member

In this example, two partitioned members and input records from the
input stream are used as the basis of a partitioned output member. Each
block of 12 output records contains 10 modified records from an input
partitioned member and two records from the input stream.

//MIX JOB ...
//STEP1   EXEC PGM=IEBDG
//SYSPRINT DD  SYSOUT=*
//PARIN1   DD  DISP=(OLD),DSN=INSET1(MEMBA)
//PARIN2   DD  DISP=(OLD),DSN=INSET2(MEMBA)
//PAROUT   DD  DISP=(NEW,CATLG),DSN=PARSET(MEMBA),
//             UNIT=disk,
//             SPACE=(TRK,(10,10,5)),
//             DCB=(DSORG=PO,RECFM=FB,BLKSIZE=0,LRECL=80)
//SYSIN    DD  DATA
         DSD    OUTPUT=(PAROUT),INPUT=(PARIN1,PARIN2)
         FD     NAME=FIELD1,LENGTH=13,PICTURE=13,'DEPARTMENT 21'
         REPEAT QUANTITY=10,CREATE=2
         CREATE QUANTITY=10,INPUT=PARIN1,NAME=FIELD1
         CREATE QUANTITY=2,INPUT=SYSIN

(input records 1 through 20)

$$$E
         REPEAT QUANTITY=10,CREATE=2
         CREATE QUANTITY=10,INPUT=PARIN2,NAME=FIELD1
         CREATE QUANTITY=2,INPUT=SYSIN

(input records 21 through 40)

$$$E
         END
/*

The control statements are discussed below:

x) PARIN1 DD defines one of the input partitioned members.

x) PARIN 2 DD defines the second of the input partitioned members.
   (Note that the members are from different partitioned data sets.)

x) PAROUT DD defines the output partitioned member. This example
   assumes that the partitioned data set does not exist before the job
   step; that is, this DD statement allocates space for the partitioned
   data set.

x) SYSIN DD defines the control data set, which follows in the input
   stream.

x) DSD marks the beginning of a set of utility control statements and
   refers to the DD statements defining the input and output data sets.

x) FD creates a 13-byte field in which the picture "DEPARTMENT 21" is
   placed.

x) The first REPEAT statement indicates that the following group of two
   CREATE statements is to be repeated 10 times.

x) The first CREATE statement creates 10 output records. Each output
   record is constructed from an input record (from partitioned data
   set INSET1) and from previously defined FIELD1.

x) The second CREATE statement indicates that two records are to be
   constructed from input records included next in the input stream.

x) The $$$E record separates the input records from the REPEAT
   statement. The next REPEAT statement group is identical to the
   preceding group, except that records from a different partitioned
   member are used as input.

x) END signals the end of a set of utility control statements.

>< ADD NAME=DG$05    0100-07003-07003-2113-00010-00010-00000-SC26UTL

Example 5: Create Records in Three Output Data Sets and Write them
to Three Partitioned Data Set Members

Restriction: This example will not work if the data sets are
system-managed or SMS data sets.

This example was removed because you should be using system-managed
datasets.

>< ADD NAME=DG$06    0100-07003-07003-2113-00053-00053-00000-SC26UTL

Example 6: Construct Records with Your Own Patterns

In this example, 10 fields containing user-supplied character patterns
are used in the construction of output records. After a record is
written, each field is rolled or waved, as specified in the applicable
FD statement.

//ROLLWAVEJOB ...
//STEP1   EXEC PGM=IEBDG
//SYSPRINT DD  SYSOUT=*
//OUTSET   DD  DISP=(NEW,CATLG),DSN=SEQSET,
//             UNIT=disk,
//             SPACE=(TRK,(10,10)),
//             DCB=(RECFM=FB,BLKSIZE=0,LRECL=80)
//SYSIN    DD  *
         DSD    OUTPUT=(OUTSET)
         FD     NAME=FIELD1,LENGTH=8,PICTURE=8,' AAAAA',ACTION=RO
         FD     NAME=FIELD2,LENGTH=8,PICTURE=8,'BBBBB ',ACTION=RO
         FD     NAME=FIELD3,LENGTH=8,PICTURE=8,'A AA ',ACTION=RO
         FD     NAME=FIELD4,LENGTH=8,PICTURE=8,' BB B',ACTION=RO
         FD     NAME=FIELD5,LENGTH=8,PICTURE=8,' AAA ',ACTION=RO
         FD     NAME=FIELD6,LENGTH=8,PICTURE=8,' CCCCC',ACTION=WV
         FD     NAME=FIELD7,LENGTH=8,PICTURE=8,' DDDD ',ACTION=WV
         FD     NAME=FIELD8,LENGTH=8,PICTURE=8,' C CC ',ACTION=WV
         FD     NAME=FIELD9,LENGTH=8,PICTURE=8,' DD D',ACTION=WV
         FD     NAME=FIELD10,LENGTH=8,PICTURE=8,' CCC ',ACTION=WV
         CREATE QUANTITY=300,NAME=(FIELD1,FIELD2,FIELD3,               X
               FIELD4,FIELD5,FIELD6,FIELD7,FIELD8,FIELD9,FIELD10)
         END
/*

The control statements are discussed below:

x) OUTSET DD defines the output sequential data set on a disk volume.
   Ten tracks of primary space and 10 tracks of secondary space are
   allocated to the data set.

x) SYSIN DD defines the control data set that follows in the input
   stream.

x) DSD marks the beginning of a set of utility control statements and
   refers to the DD statement defining the output data set.

x) FD defines a field to be used in the subsequent construction of
   output records. The direction and frequency of the initial roll or
   wave depend on the location of data in the field.

x) CREATE constructs 300 records from the contents of the previously
   defined fields.

x) END signals the end of a set of utility control statements.

./ ADD NAME=IEBEDIT  0666-07209-07209-1455-00001-00001-00000-DIR2UPDT
>< ADD NAME=EDIT     0101-07003-07016-2327-00008-00008-00000-KTOMIAK

EDIT$01  Copy One Job
EDIT$02  Copy Steps from Three Jobs
EDIT$03  Include Step from One Job, Exclude Step from Another
EDIT$04  Copy Statement for JOBA and JOB STEPF
EDIT$05  Copy Entire Input Data Set
EDIT$06  Copy Entire Data Set to Include New Delimiter

>< ADD NAME=EDIT$01  0100-07003-07003-2113-00032-00032-00000-SC26UTL

Example 1: Copy One Job

In this example, one job (JOBA), including all of its job steps, is
copied into the output data set. The input data set contains three
jobs: JOBA, JOBB and JOBC.

//EDIT1 JOB ...
//STEP1   EXEC PGM=IEBEDIT
//SYSPRINT DD  SYSOUT=*
//SYSUT1   DD  DISP=(OLD),DSN=INJOBS
//SYSUT2   DD  DISP=(NEW,CATLG),DSN=OUTTAPE,
//             UNIT=tape,
//             DCB=(RECFM=FB,BLKSIZE=0,LRECL=80)
//SYSIN    DD  *
         EDIT START=JOBA
/*

The control statements are discussed below:

x) SYSUT1 DD defines the input data set, INJOBS. The data set resides
   on a standard labeled tape volume (001234).

x) SYSUT2 DD defines the output data set, called OUTTAPE. The data set
   is to reside as the first data set on a standard labeled tape
   volume. The system will select an optimal block size.

x) SYSIN DD defines the control data set, which follows in the input
   stream.

x) EDIT indicates that JOBA is to be copied in its entirety.

>< ADD NAME=EDIT$02  0100-07003-07003-2113-00041-00041-00000-SC26UTL

Example 2: Copy Steps from Three Jobs

This example copies job steps from each of three jobs. The input data
set contains three jobs: JOBA, which includes STEPA, STEPB, STEPC, and
STEPD; JOBB, which includes STEPE, STEPF, and STEPG; and JOBC, which
includes STEPH and STEPJ.

//EDIT2 JOB ...
//STEP1   EXEC PGM=IEBEDIT
//SYSPRINT DD  SYSOUT=*
//SYSUT1   DD  DISP=(OLD),DSN=INJOBS
//SYSUT2   DD  DISP=(NEW,CATLG),DSN=OUTSTRM,
//             UNIT=tape,LABEL=(2,SL),
//             VOL=SER=001235,
//             DCB=(RECFM=FB,BLKSIZE=0,LRECL=80)
//SYSIN    DD  *
         EDIT START=JOBA,TYPE=INCLUDE,STEPNAME=(STEPC,STEPD)
         EDIT START=JOBB,TYPE=INCLUDE,STEPNAME=STEPE
         EDIT START=JOBC,TYPE=INCLUDE,STEPNAME=STEPJ
/*

The control statements are discussed below:

x) SYSUT1 DD defines the input data set, INJOBS. The data set resides
   on a standard labeled tape volume (001234).

x) SYSUT2 DD defines the output data set, OUTSTRM. The data set is to
   reside as the second data set on a standard labeled tape volume
   (001235).

x) SYSIN DD defines the control data set, which follows in the input
   stream.

x) The EDIT statements copy the JOB statements and job steps described
   as follows:

  1. The JOB statement and steps STEPC and STEPD for JOBA.
  2. The JOB statement and STEPE for JOBB.
  3. The JOB statement and STEPJ for JOBC.

>< ADD NAME=EDIT$03  0100-07003-07003-2113-00036-00036-00000-SC26UTL

Example 3: Include Step from One Job, Exclude Step from Another

This example includes a job step from one job and excludes a job step
from another job. The input data set contains three jobs: JOBA, which
includes STEPA, STEPB, STEPC, and STEPD; JOBB, which includes STEPE,
STEPF, and STEPG; and JOBC, which includes STEPH and STEPJ.

//EDIT3 JOB ...
//STEP1   EXEC PGM=IEBEDIT
//SYSPRINT DD  SYSOUT=*
//SYSUT1   DD  DISP=(OLD),DSN=INSET
//SYSUT2   DD  DISP=(NEW,CATLG),DSN=OUTTAPE,
//             UNIT=tape,LABEL=(,SL),
//             DCB=(RECFM=FB,BLKSIZE=0,LRECL=80)
//SYSIN    DD  *
         EDIT START=JOBB,TYPE=INCLUDE,STEPNAME=(STEPF-STEPG)
         EDIT START=JOBC,TYPE=EXCLUDE,STEPNAME=STEPJ
/*

The control statements are discussed below:

x) SYSUT1 DD defines the input data set, INSET.

x) SYSUT2 DD defines the output data set, OUTTAPE. The data set is to
   reside as the first or only data set on a labeled tape volume.

x) SYSIN DD defines the control data set, which follows in the input
   stream.

x) The EDIT statements copy JOB statements and job steps as described
   below:

  1. The JOB statement and steps STEPF and STEPG for JOBB.
  2. The JOB statement and STEPH, excluding STEPJ, for JOBC.

>< ADD NAME=EDIT$04  0100-07003-07003-2113-00034-00034-00000-SC26UTL

Example 4: Copy Statement for JOBA and JOB STEPF

This example copies the JOB statement for JOBA, the job step STEPF, and
all the steps that follow it. The input data set contains one job
(JOBA), which includes STEPA through STEPL. Job steps STEPA through
STEPE are not included in the output data set.

//EDIT4 JOB ...
//STEP1   EXEC PGM=IEBEDIT
//SYSPRINT DD  SYSOUT=*
//SYSUT1   DD  DISP=(OLD),DSN=INSTREAM
//SYSUT2   DD  DISP=(NEW,CATLG),DSN=OUTSTREM,
//             UNIT=disk,
//             SPACE=(TRK,2)
//             DCB=(RECFM=FB,BLKSIZE=0,LRECL=80)
//SYSIN    DD  *
         EDIT START=JOBA,TYPE=POSITION,STEPNAME=STEPF
/*

The control statements are discussed below:

x) SYSUT1 DD defines the input data set, INSTREAM.

x) SYSUT2 DD defines the output data set, OUTSTREAM. The data set is to
   reside on a disk volume. Two tracks are allocated for the output
   data set.

x) SYSIN DD defines the control data set, which follows in the input
   stream.

x) EDIT copies the JOB statement for JOBA and job steps STEPF through
   STEPL.

>< ADD NAME=EDIT$05  0100-07003-07003-2113-00035-00035-00000-SC26UTL

Example 5: Copy Entire Input Data Set

This example copies the entire input data set. The record containing
the characters "..*" in columns 1 through 3 is converted to a "/*"
statement in the output data set.

//EDIT5 JOB ...
//STEP1   EXEC PGM=IEBEDIT
//SYSPRINT DD  SYSOUT=*
//SYSUT2   DD  DISP=(NEW,CATLG),DSN=OUTTAPE,
//             UNIT=tape,
//             DCB=(RECFM=FB,BLKSIZE=0,LRECL=80)
//SYSIN    DD  DUMMY
//SYSUT1   DD  DATA
//BLDGDGIX JOB ...
//        EXEC PGM=IEHPROGM
//SYSPRINT DD  SYSOUT=*
//DD1      DD  DISP=OLD,UNIT=disk,VOL=SER=111111
//SYSIN DD  *
         BLDG INDEX=A.B.C,ENTRIES=10,EMPTY
/*

The control statements are discussed below:

x) SYSUT2 DD defines the output data set, OUTTAPE. The data set will be
   the first data set on a tape volume.

x) SYSIN DD defines a dummy control data set.

x) SYSUT1 DD defines the input data set, which follows in the input
   stream. The job is stopped when the statement "/*" is encountered.
   (SYSUT1 therefore includes the BLDGDGIX JOB statement, EXEC
   statement, SYSPRINT, DD1, and SYSIN DD statements.)

>< ADD NAME=EDIT$06  0100-07003-07003-2113-00041-00041-00000-SC26UTL

Example 6: Copy Entire Data Set to Include New Delimiter

This example copies the entire input data set, including the JES2
control statement, because a new delimiter (JP) has been coded.
Otherwise, the "/*" in the JES2 control statement would have stopped
the input.

//EDIT6 JOB ...
//STEP1   EXEC PGM=IEBEDIT
//SYSPRINT DD  SYSOUT=*
//SYSUT2   DD  DISP=(NEW,CATLG),DSN=TAPEOUT,
//             UNIT=tape,LABEL=(2,SL),
//             DCB=(RECFM=FB,BLKSIZE=0,LRECL=80)
//SYSIN    DD  DUMMY
//SYSUT1   DD  DATA,DLM='JP'
//LISTVTOC JOB ...
/*MESSAGE JOB NEEDS VOLUME 338000
//FSTEP   EXEC PGM=IEHLIST
//SYSPRINT DD  SYSOUT=*
//DD2      DD  DISP=OLD,UNIT=disk,VOL=SER=338000
//SYSIN    DD  *
         LISTVTOC FORMAT,VOL=disk=338000
/*
JP

The control statements are discussed below:

x) SYSUT2 DD defines the output data set, TAPEOUT. The data set will be
   the first data set on a standard label tape volume.

x) SYSIN DD defines a dummy control data set.

x) SYSUT1 DD defines the input data set, which follows in the input
   stream. The DLM parameter defines characters JP to act as a
   delimiter for the input data.

x) IEBEDIT copies the JOB statement through the "/*" statement
   (including the LISTVTOC and MESSAGE job statements, FSTEP EXEC
   statement, and SYSPRINT, DD2 and SYSIN DD statements).

./ ADD NAME=IEBGENER 0666-07209-07209-1456-00001-00001-00000-DIR2UPDT
>< ADD NAME=GENER    0101-07003-07016-2328-00011-00011-00000-KTOMIAK

GENER$01 Print a Sequential Data Set
GENER$02 Create a Partitioned Data Set from Sequential Input
GENER$03 Convert Sequential Input into Partitioned Members
GENER$03 Convert Sequential Input into Partitioned Members
GENER$04 In-stream Input, Sequential Data Set to Tape Volume
GENER$05 Produce Blocked Copy on Tape from Unblocked Disk File
GENER$06 Edit and Copy a Sequential Input Data Set with Labels
GENER$07 Edit and Copy a Sequential USS File to a Sequential Data
GENER$08 Edit Double-Byte Character Set Data

>< ADD NAME=GENER$01 0100-07003-07003-2113-00025-00025-00000-SC26UTL

Example 1: Print a Sequential Data Set

In this example, a sequential data set is printed. The printed output
is left-aligned, with one 80-byte record appearing on each line of
printed output.

//PRINT JOB ...
//STEP1   EXEC PGM=IEBGENER
//SYSPRINT DD  SYSOUT=*
//SYSIN    DD  DUMMY
//SYSUT1   DD  DISP=(SHR),DSN=D80.DATA
//SYSUT2   DD  SYSOUT=*

The job control statements are discussed below:

x) SYSIN DD defines a dummy data set. Since no editing is performed, no
   utility control statements are required.

x) SYSUT1 DD defines the input sequential data set.

x) SYSUT2 DD indicates that the output is to be written on the system
   output device (printer). IEBGENER copies LRECL and RECFM from the
   SYSUT1 data set and the system determines a BLKSIZE.

>< ADD NAME=GENER$02 0100-07003-07003-2113-00055-00055-00000-SC26UTL

Example 2: Create a Partitioned Data Set from Sequential Input

In this example, a partitioned data set (consisting of three members)
is created from sequential input.

//TAPEDISK JOB ...
//STEP1   EXEC PGM=IEBGENER
//SYSPRINT DD  SYSOUT=*
//SYSUT1   DD  DISP=(OLD),DSN=INSET
//SYSUT2   DD  DISP=(NEW,CATLG),DSN=NEWSET,
//             UNIT=disk,
//             SPACE=(TRK,(10,5,5)),
//             DCB=(RECFM=FB,BLKSIZE=0,LRECL=80)
//SYSIN    DD  *
         GENERATE MAXNAME=3,MAXGPS=2
         MEMBER   NAME=MEMBER1
         GROUP1   RECORD IDENT=(8,'FIRSTMEM',1)
         MEMBER   NAME=MEMBER2
         GROUP2   RECORD IDENT=(8,'SECNDMEM',1)
         MEMBER   NAME=MEMBER3
/*

The control statements are discussed below:

x) SYSUT1 DD defines the input data set (INSET). The data set is the
   first data set on a tape volume.

x) SYSUT2 DD defines the output partitioned data set (NEWSET). The data
   set is to be placed on a disk volume. Ten tracks of primary space,
   five tracks of secondary space, and five blocks (256 bytes each) of
   directory space are blocked to reduce the space required by the data
   set.

x) SYSIN DD defines the control data set, which follows in the input
   stream. The utility control statements are used to create members
   from sequential input data; the statements do not specify any
   editing.

x) GENERATE indicates that three member names are included in
   subsequent MEMBER statements and that the IDENT parameter appears
   twice in subsequent RECORD statements.

x) The first MEMBER statement assigns a member name (MEMBER1) to the
   first member.

x) The first RECORD statement (GROUP1) identifies the last record to be
   placed in the first member. The name of this record (FIRSTMEM)
   appears in the first eight positions of the input record.

x) The remaining MEMBER and RECORD statements define the second and
   third members. Note that, as there is no RECORD statement associated
   with the third MEMBER statement, the remainder of the input file
   will be loaded as the third member.

>< ADD NAME=GENER$03 0100-07003-07003-2113-00057-00057-00000-SC26UTL

Example 3: Convert Sequential Input into Partitioned Members

In this example, sequential input is converted into two partitioned
members. The newly created members are merged into an existing
partitioned data set. User labels on the input data set are passed to
the user exit routine.

//DISKTODK JOB ...
//STEP1   EXEC PGM=IEBGENER
//SYSPRINT DD  SYSOUT=*
//SYSUT1   DD  DISP=(OLD),DSN=INSET
//SYSUT2   DD  DISP=(MOD,KEEP),DSN=EXISTSET,
//             UNIT=disk,
//             VOL=SER=111113
GENERATE GENERATE MAXNAME=3,MAXGPS=1
         EXITS INHDR=ROUT1,INTLR=ROUT2
         MEMBER NAME=(MEMX,ALIASX)
         GROUP1 RECORD IDENT=(8,'FIRSTMEM',1)
         MEMBER NAME=MEMY
/*

The control statements are discussed below:

x) SYSUT1 DD defines the input data set (INSET). The input data set,
   which resides on a disk volume, has standard user labels.

x) SYSUT2 DD defines the output partitioned data set (EXISTSET). The
   members created during this job step are merged into the partitioned
   data set.

x) The SYSIN DD statement is omitted. Because the GENERATE line does
   not begin with //, the system assumes it is preceded by a //SYSIN DD
   * line. SYSIN DD defines the control data set, which follows in the
   input stream. The utility control statements are used to create
   members from sequential input data; the statements do not specify
   any editing.A /* at the end of any DD * data set is unnecessary
   because a JCL satement or end of the job stream marks the end of the
   input stream data set.

x) GENERATE indicates that a maximum of three names and aliases are
   included in subsequent MEMBER statements and that one IDENT
   parameter appears in a subsequent RECORD statement.

x) EXITS defines the user routines that are to process user labels.

x) The first MEMBER statement assigns a member name (MEMX) and an alias
   (ALIASX) to the first member.

x) The RECORD statement identifies the last record to be placed in the
   first member. The name of this record (FIRSTMEM) appears in the
   first eight positions of the input record.

x) The second MEMBER statement assigns a member name (MEMY) to the
   second member. The remainder of the input data set is included in
   this member.

>< ADD NAME=GENER$04 0100-07003-07003-2113-00031-00031-00000-SC26UTL

Example 4: In-stream Input, Sequential Data Set to Tape Volume

In this example, an in-stream input, sequential data set is copied to a
tape volume.

//CDTOTAPEJOB ...
//STEP1   EXEC PGM=IEBGENER
//SYSPRINT DD  SYSOUT=*
//SYSIN    DD  DUMMY
//SYSUT2   DD  DISP=(NEW,CATLG),DSN=OUTSET,
//             UNIT=tape,LABEL=(,SL),
//             DCB=(RECFM=FB,BLKSIZE=0,LRECL=80)
//SYSUT1 DD  *

(in-stream data)

/*

The job control statements are discussed below:

x) SYSIN DD defines a dummy data set. No editing is performed;
   therefore, no utility control statements are needed.

x) SYSUT2 DD defines the output data set, OUTSET. The data set is
   written to a tape volume with IBM standard labels. The data set is
   to reside as the first (or only) data set on the volume.

x) SYSUT1 DD defines the in-stream data which is actually a JES SYSIN
   data set. The data set contains no statements.

>< ADD NAME=GENER$05 0100-07003-07003-2113-00041-00041-00000-SC26UTL

Example 5: Produce Blocked Copy on Tape from Unblocked Disk File

In this example, a blocked copy on tape is made from an unblocked
sequential disk file. Because the disk data set has a relatively small
block size, the number of buffers explicitly requested is larger than
the default of five. This improves performance by permitting more
overlap of reading the SYSUT1 data set with writing the SYSUT2 data
set.

//COPYJOB JOB
//STEP1   EXEC PGM=IEBGENER,REGION=318K
//SYSPRINT DD  SYSOUT=*
//SYSIN    DD  DUMMY
//SYSUT1   DD  DISP=(OLD),DSN=INPUT,
//             DCB=(BUFNO=20)
//SYSUT2   DD  DISP=(NEW,CATLG),DSN=OUTPUT,
//             UNIT=tape,
//             DCB=(RECFM=FB,BLKSIZE=32000,LRECL=2000)

The job control statements are discussed below:

x) The EXEC statement names the IEBGENER program and specifies the
   virtual storage region size required. (Calculation of region size is
   described in Table 15 on page 79.)

x) The SYSIN DD statement is a dummy, since no editing is to be
   performed.

x) The SYSUT1 DD statement identifies an input disk file. Normally, the
   DCB information should not be specified in the DD statement for an
   existing disk file because the information exists in the data set
   label in the VTOC; it is specified in this example to illustrate the
   use of the BUFNO sub-parameter. The DCB information specifies
   BUFNO=20 to allow up to twenty blocks to be read with each rotation
   of the disk, assuming the disk track will hold that many blocks.

x) The SYSUT2 DD statement identifies the output tape data set and
   specifies a block size of 32,000 bytes. The default of five buffers
   should be enough to keep pace with the input.

>< ADD NAME=GENER$06 0100-07003-07003-2113-00060-00060-00000-SC26UTL

Example 6: Edit and Copy a Sequential Input Data Set with Labels

In this example, a sequential input data set is edited and copied.

//TAPETAPE JOB ...
//STEP1   EXEC PGM=IEBGENER
//SYSPRINT DD  SYSOUT=*
//SYSUT1   DD  DISP=(OLD),DSN=OLDSET
//SYSUT2   DD  DISP=(NEW,CATLG),DSN=NEWSET,
//             UNIT=tape,LABEL=(,SL),
//             DCB=(RECFM=FB,BLKSIZE=0,LRECL=80)
//SYSIN    DD  *
         GENERATE MAXFLDS=3,MAXLITS=11
         RECORD FIELD=(10,'**********',,1),
         FIELD=(5,1,HE,11),FIELD=(1,'=',,16)
         RECORD LABELS=2

(first header label record)
(second header label record)

         RECORD LABELS=2

(first trailer label record)
(second trailer label record)

/*

The control statements are discussed below:

x) SYSUT1 DD defines the sequential input data set (OLDSET). The data
   set was originally written as the third data set on a tape volume.

x) SYSUT2 DD defines the sequential output data set (NEWSET). The data
  set is written as the first data set on a tape volume. The output
  records are blocked to reduce the space required by the data set and
  to reduce the access time required when the data set is subsequently
  referred to. The BLKSIZE parameter is omitted so that the system will
  calculate an optimal value that is less than or equal to 32,760 bytes
  unless the system programmer sets the default differently.

x) SYSIN DD defines the control data set, which follows in the input
   stream.

x) GENERATE indicates that a maximum of three FIELD parameters is
   included in subsequent RECORD statements and that a maximum of 11
   literal characters are included in subsequent FIELD parameters.

x) The first RECORD statement controls the editing, as follows:
   asterisks are placed in positions 1 through 10; positions 1 through
   5 of the input record are converted from H-set BCDIC to EBCDIC mode
   and moved to positions 11 through 15; and an equal sign is placed in
   position 16.

x) The second RECORD statement indicates that the next two records from
   SYSIN should be written out as user header labels on SYSUT2.

x) The third RECORD statement indicates that the next two records from
   SYSIN should be written as user trailer labels on SYSUT2.

>< ADD NAME=GENER$07 0100-07003-07003-2113-00049-00049-00000-SC26UTL

Example 7: Edit and Copy a Sequential USS File to a Sequential Data
Set

In this example,a USS (POSIX) file is edited and copied. The logical
record length of the output data set is less than that of the input
data set.

//DISKDISK JOB ...
//STEP1   EXEC PGM=IEBGENER
//SYSPRINT DD  SYSOUT=*
//SYSUT1   DD  PATH='/dist3/stor44/sales.mon',
//             FILEDATA=TEXT,
//             PATHOPTS=ORDONLY,
//             LRECL=100,BLKSIZE=1000,RECFM=FB
//SYSUT2   DD  DISP=(NEW,CATLG),DSN=NEWSET,
//             UNIT=disk,
//             SPACE=(TRK,(20,10)),
//             DCB=(RECFM=FB,BLKSIZE=0,LRECL=80)
//SYSIN DD  *
         GENERATE MAXFLDS=4,MAXGPS=1
         EXITS IOERROR=ERRORRT
         GRP1 RECORD IDENT=(8,'FIRSTGRP',1),FIELD=(21,80,,60),         X
               FIELD=(59,1,,1)
         GRP2 RECORD FIELD=(11,90,,70),FIELD=(69,1,,1)
/*

The control statements are discussed below:

x) SYSUT1 DD defines the input file. Its name is
   /dist3/stor44/sales.mon. It contains text in 100-byte records. The
   record delimiter is not stated here. The file might be on a
   non-System/390 system that is available via NFS, Network File
   System.

x) SYSUT2 DD defines the output data set (NEWSET). Twenty tracks of
   primary storage space and ten tracks of secondary storage space are
   allocated for the data set on a disk volume. The logical record
   length of the output records is 80 bytes, and the output is blocked.

x) SYSIN DD defines the control data set, which follows in the input
   stream.

x) GENERATE indicates that a maximum of four FIELD parameters are
   included in subsequent RECORD statements and that one IDENT
   parameter appears in a subsequent RECORD statement.

x) EXITS identifies the user routine that handles input/output errors.

>< ADD NAME=GENER$08 0100-07003-07003-2113-00066-00066-00000-SC26UTL

Example 8: Edit Double-Byte Character Set Data

In this example, an edited data set containing double-byte character
set data is created. Shift-out/shift-in characters (< and >) are
inserted to enclose the DBCS strings.

//DBLBYTEJOB ...
//STEP1   EXEC PGM=IEBGENER
//SYSPRINT DD  SYSOUT=*
//SYSUT1   DD  DISP=(OLD),DSN=INPUT,
//SYSUT2   DD  DISP=(NEW,CATLG),DSN=OUTPUT,
//             UNIT=disk,
//             SPACE=(TRK,(1,1)),
//             DCB=(RECFM=FB,BLKSIZE=0,LRECL=80)
//SYSIN    DD  *
         GENERATE MAXFLDS=4,MAXLITS=9,DBCS=YES
         RECORD   FIELD=(20,1,,1),FIELD=(16,33,VC,21),                 X
               FIELD=(30,50,VC,39),FIELD=(9,'*********',,72)
/*

The control statements are discussed below.

x) SYSUT1 DD defines the input data set, INPUT, which resides on a disk
   volume.

x) SYSUT2 DD defines the output data set, OUTPUT, which will reside on
   a disk volume.

x) SYSIN DD defines the control data set, which follows in the input
   stream.

x) GENERATE indicates that a maximum of four FIELD parameters and nine
   literal characters will appear on subsequent RECORD statements, and
   that the input data set contains DBCS data.

x) RECORD specifies how input records will be edited before being
   placed in the output data set. The first FIELD parameter indicates
   that the first 20 positions (bytes) of the input records are to be
   placed in the first 20 positions of the output records.

x) The second FIELD parameter indicates that data in positions 33
   through 48 are to be checked to ensure that they are valid DBCS
   data, and that shift-out/shift-in characters are to be inserted
   around this field. For DBCS data to be valid, each byte of the
   2-byte characters must have a hexadecimal value between X'41' and
   X'FE', or the 2-byte character must be a DBCS space (X'4040'). Once
   the checking and inserting are completed, this field is to be copied
   to the output records beginning at position 21.

x) The third FIELD parameter operates on the 30-byte field beginning at
   position 50 in the input records. This field is checked for valid
   DBCS data, and shift-out/shift-in characters are inserted around the
   field. The resulting field is copied to the output records beginning
   at position 39.

Notice that in specifying the output locations in the FIELD parameter,
you have to account for the additional positions that the SO/SI
characters will use. For instance, the eight-character (16-byte) DBCS
string beginning at position 21 does not end at position 36, but at 38.
The SO/SI characters are single-byte characters, so the pair will take
up two positions.

The final FIELD parameter clears out the final positions of the output
records with asterisks.

./ ADD NAME=IEBIMAGE 0666-07209-07209-1457-00001-00001-00000-DIR2UPDT
>< ADD NAME=IMAGE    0101-07003-07016-2345-00028-00028-00000-KTOMIAK

IMAGE$01  Build a New 3800 Forms Control Buffer Module
IMAGE$02  Replace a 3800 Forms Control Buffer Module
IMAGE$03  Replace a 3800 Forms Control Buffer Module
IMAGE$04  Build a New 3800 Forms Control Buffer Module
IMAGE$05  Replace the 3800 Forms Control Buffer Module STD3
IMAGE$06  Build a New 3800 Forms Control Buffer Module for
IMAGE$07  Build a 4248 Forms Control Buffer Module
IMAGE$08  Build a New Copy Modification Module
IMAGE$09  Build a New Copy Modification Module from an Existing
IMAGE$10  Add a New Character to a Character Arrangement Table
IMAGE$11  Build a New Character Arrangement Table Module from an
IMAGE$12  Build Graphic Characters in a Character Arrangement
IMAGE$13  Delete Graphic References From a Character
IMAGE$14  List the World Trade National Use Graphics Graphic
IMAGE$15  Build a Graphic Character Modification Module from the
          Character Modification Module World Trade GRAFMOD
IMAGE$16  Build a New Graphic Character Modification Module and
          Modify a Character Arrangement Table to Use It
IMAGE$17  Build a Graphic Character Modification Module from
          Multiple Sources
IMAGE$18  Define and Use a Character in a Graphic Character
          Modification Module
IMAGE$19  List a Library Character Set Module
IMAGE$20  Build a Library Character Set Module
IMAGE$21  Build a Library Character Set Module and Modify a
IMAGE$22  Build a Library Character Set Module from Multiple

>< ADD NAME=IMAGE$01 0100-07003-07003-2113-00039-00039-00000-SC26UTL

Example 1: Build a New 3800 Forms Control Buffer Module

3800 Model 1

In this example, the vertical spacing and channel codes for an 11-inch
form are specified, and the module is added to the SYS1.IMAGELIB data
set as a new member.

//FCBMOD1 JOB ...
//STEP1   EXEC PGM=IEBIMAGE
//SYSUT1   DD  DISP=(OLD),DSN=SYS1.IMAGELIB
//SYSPRINT DD  SYSOUT=*
//SYSIN    DD  *
         FCB  CH1=1,CH12=80,LPI=8
         NAME IJ
/*

The control statements are discussed below:

x) The SYSUT1 DD statement includes DISP=OLD to ensure that no other
   job can modify the data set while this job is executing.

x) CH1=1 specifies channel 1 code for line 1, allowing for positioning
   at line 1.

x) CH12=80 specifies channel 12 code for line 80, allowing for
   positioning at line 80 and a unit exception indication at line 80
   (the last printable line on the page.)

x) LPI=8 specifies that the entire form is to be at a vertical spacing
   of 8 lines per inch. Because the SIZE parameter is omitted, the form
   length defaults to 11 inches. Because there are 10 inches of
   printable space in an 11-inch form, 80 lines are printed at 8 lines
   per inch.

x) The name of the new FCB module is IJ; it is stored as a member of
   the SYS1.IMAGELIB data set.

>< ADD NAME=IMAGE$02 0100-07003-07003-2113-00043-00043-00000-SC26UTL

Example 2: Replace a 3800 Forms Control Buffer Module

3800 Model 1

In this example, the size and channel codes for a 5-1/2 inch form are
specified, and the module is added to the SYS1.IMAGELIB data set as a
replacement for an existing member. The new module is added to the end
of the data set; the name in the data set's directory is updated so
that it points to the new module; the old module can no longer be
accessed through the data set's directory.

//FCBMOD2 JOB ...
//STEP1   EXEC PGM=IEBIMAGE
//SYSUT1   DD  DISP=(OLD),DSN=SYS1.IMAGELIB
//SYSPRINT DD  SYSOUT=*
//SYSIN    DD  *
         FCB  CH1=(1,7,13,20),CH12=26,SIZE=55
         NAME S55(R)

/*

The control statements are discussed below:

x) The SYSUT1 DD statement includes DISP=OLD to ensure that no other
   job can modify the data set while this job is executing.

x) CH1=(1,7,13,20) specifies channel 1 code for printable line 1, line
   7, line 13, and line 20.

x) CH12=26 specifies channel 12 code for printable line 26.

x) SIZE=55 specifies the length of the form as 55 tenths of an inch, or
   5-1/2 inches.

x) Because the LPI parameter is omitted, the vertical spacing defaults
   to 6 lines per inch. Because there are 4-1/2 inches of printable
   lines in a 5-1/2 inch form, there are 27 print lines on this form.

x) The name of the FCB module is S55, and it replaces an existing FCB
   module of the same name. The new FCB module is stored as a member of
   the SYS1.IMAGELIB data set.

>< ADD NAME=IMAGE$03 0100-07003-07003-2113-00050-00050-00000-SC26UTL

Example 3: Replace a 3800 Forms Control Buffer Module

3800 Model 1

In this example, the vertical spacing, channel codes, and size for a
form are specified, and the module is added to the SYS1.IMAGELIB data
set as a replacement for an existing member. The new module is added to
the end of the data set; the name in the data set's directory is
updated so that it points to the new module; the old module can no
longer be accessed through the data set's directory.

//FCBMOD3 JOB ...
//STEP1   EXEC PGM=IEBIMAGE
//SYSUT1   DD  DISP=(OLD),DSN=SYS1.IMAGELIB
//SYSPRINT DD  SYSOUT=*
//SYSIN    DD  *
         FCB  CH1=1,CH2=4,CH5=11,SIZE=35,LPI=((6,2),(8,3),(6,4),(8,9))
         NAME HL(R)
/*

The control statements are discussed below:

x) The SYSUT1 DD statement includes DISP=OLD to ensure that no other
   job can modify the data set while this job is executing.

x) CH1=1 specifies channel 1 code for printable line 1.

x) CH2=4 specifies channel 2 code for line 4.

x) CH5=11 specifies channel 5 code for line 11.
x) LPI=((6,2),(8,3),(6,4),(8,9)) specifies vertical spacing for the
   first 18 printable lines in the form: (6,2) specifies lines 1
   through 2 are at a vertical spacing of 6 lines per inch, and take up
   2/6 inch. (8,3) specifies lines 3 through 5 are at a vertical
   spacing of 8 lines per inch, and take up 3/8 inch. (6,4) specifies
   lines 6 through 9 are at a vertical spacing of 6 lines per inch, and
   take up 4/6 inch. (8,9) specifies lines 10 through 18 are at a
   vertical spacing of 8 lines per inch, and take up 1-1/8 inch.

x) SIZE=35 specifies the length of the form as 35 tenths of an inch, or
   3-1/2 inches. Because there are 2-1/2 inches of printable space on
   a 3-1/2 inch form, and because the LPI parameter specifies vertical
   spacing for 2-1/2 inches of lines, the vertical spacing of all lines
   in the form is accounted for.

x) The name of the FCB module is HL; it replaces an existing module of
   the same name. The new FCB module is stored as a member of the
   SYS1.IMAGELIB data set.

>< ADD NAME=IMAGE$04 0100-07003-07003-2113-00046-00046-00000-SC26UTL

Example 4: Build a New 3800 Forms Control Buffer Module

3800 Model 1

In this example, the vertical spacing, channel codes, and length of a
form are specified, and the module is added to the SYS1.IMAGELIB data
set as a new member.

//FCBMOD4 JOB ...
//STEP1   EXEC PGM=IEBIMAGE
//SYSUT1   DD  DISP=(OLD),DSN=SYS1.IMAGELIB
//SYSPRINT DD  SYSOUT=*
//SYSIN    DD  *
         FCB  CH1=1,CH6=33,SIZE=70,LPI=((8,32),(12,2))
         NAME TGT
/*

The control statements are discussed below:

x) The SYSUT1 DD statement includes DISP=OLD to ensure that no other
   job can modify the data set while this job is executing.

x) CH1=1 specifies channel 1 code for printable line 1.

x) CH6=33 specifies channel 6 code for line 33.

x) LPI=((8,32),(12,2)) specifies that the first 32 printable lines of
   the form are to be at a vertical spacing of 8 lines per inch, and
   the next 2 printable lines are to be at a vertical spacing of 12
   lines per inch.

x) SIZE=70 specifies that the length of the form is 70 tenths of an
   inch, or 7 inches. Because there are 6 inches of printable lines in
   a 7-inch form and the LPI parameter specifies 32 lines at 8 lines
   per inch, or 4 inches, and 2 lines at 12 lines per inch, or 1/6
   inch, the vertical spacing for the remaining 1-5/6 inches defaults
   to 6 lines per inch.

   Therefore, the form consists of lines 1 through 32 at 8 lines per
   inch, lines 33 through 34 at 12 lines per inch, and lines 35 through
   45 at 6 lines per inch, with channel codes at line 1 and line 33.

x) The name of the new FCB module is TGT; it is stored as a member of
   the SYS1.IMAGELIB data set.

>< ADD NAME=IMAGE$05 0100-07003-07003-2113-00036-00036-00000-SC26UTL

Example 5: Replace the 3800 Forms Control Buffer Module STD3

3800 Model 1

In this example, an FCB module is defined that uses ISO paper sizes,
replacing the IBM-supplied module named STD3. This must be done before
the dump-formatting routines that print high-density dumps can print
them at 8 lines per inch on that printer.

//FCBMOD5 JOB ...
//STEP1   EXEC PGM=IEBIMAGE
//SYSUT1   DD  DISP=(OLD),DSN=SYS1.IMAGELIB
//SYSPRINT DD  SYSOUT=*
//SYSIN    DD  *
         FCB  CH1=1,CH12=88,LPI=(8,88),SIZE=120
         NAME STD3(R)
/*

The control statements are discussed below:

x) The SYSUT1 DD statement includes DISP=OLD to ensure that no other
   job can modify the data set while this job is executing.

x) CH1=1 specifies channel 1 code for printable line 1; CH12=88
   specifies channel 12 code for line 88.

x) LPI=(8,88) specifies that all 88 printable lines of the form are to
   be at a vertical spacing of 8 lines per inch.

x) SIZE=120 specifies that the length of the form is 120 tenths of an
   inch, or 12 inches, which is the longest ISO paper size.

x) The name of the new FCB module is STD3; it is to replace the
   existing module of that same name on SYS1.IMAGELIB.

>< ADD NAME=IMAGE$06 0100-07003-07003-2113-00050-00050-00000-SC26UTL

Example 6: Build a New 3800 Forms Control Buffer Module for
Additional ISO Paper Sizes

3800 Model 3

In this example, an FCB module is defined that uses ISO paper sizes and
has the ISO Paper Sizes Additional Feature installed.

//FCBMOD JOB ... 72
//STEP1   EXEC PGM=IEBIMAGE
//SYSUT1   DD  DISP=(OLD),DSN=SYS1.IMAGELIB
//SYSPRINT DD  SYSOUT=*
//SYSIN    DD  *
         FCB   CH1=1,CH12=75,SIZE=85,                                  X
               LPI=((10,35),(12,4),(10,35),(6,1)
         NAME  ARU
/*

The control statements are discussed below:

x) The SYSUT1 DD statement includes DISP=OLD to ensure that no other
   job can modify the data set while this job is executing.

x) CH1=1 specifies channel 1 code for line 1, allowing for positioning
   at line 1.

x) Ch12=75 specifies channel 12 code for line 75, allowing for
   positioning at line 75 and a unit exception indication at 75 (the
   last printable line on the page.)

x) LPI=((10,35),(12,4),(10,35),(6,1)) specifies vertical spacing for
   the entire printable area on the form. The last printable line on
   the form must have vertical spacing of 6 lines per inch. The sum of
   the lines allocated must be a multiple of 1/2.

   EXAMPLES

   (10,35)=3 1/2"
   (12,4)=2/6"
   (6,1)=1/6"
   31/2+2/6+31/2+1/6=71/2
   which is a multiple of 1/2

x) SIZE=85 specifies the length of the form as 85 tenths of an inch, or
   8-1/2 inches, although the printable area is 7-1/2 inches.

x) The name of the new FCB module is ARU; it is stored as a member of
   the SYS1.IMAGELIB data set.

>< ADD NAME=IMAGE$07 0100-07003-07003-2113-00055-00055-00000-SC26UTL

Example 7: Build a 4248 Forms Control Buffer Module

In this example, a new 4248 default FCB module is built using an
existing FCB module as a model. The new module, NEW1, is added to
SYS1.IMAGELIB as a new member. The existing module, OLD1, remains
unchanged. OLD1 may be a 4248 FCB called FCB4OLD1, or it may be a 3211
FCB called FCB2OLD1. (If both modules existed, FCB4OLD1 would be used.)

//FCBMOD7 JOB ...
//STEP1   EXEC PGM=IEBIMAGE
//SYSUT1   DD  DISP=(OLD),DSN=SYS1.IMAGELIB
//SYSPRINT DD  SYSOUT=*
//SYSIN    DD  *
         OPTION DEVICE=4248
         INCLUDE OLD1
         FCB  COPYP=67,PSPEED=M,DEFAULT=YES
         NAME NEW1
/*

The control statements are discussed below:

x) The SYSUT1 DD statement includes DISP=OLD to ensure that no other
   job can modify the data set while this job is executing.

x) DEVICE=4248 on the OPTION statement specifies that this module is to
   be created for the 4248 printer.

x) The INCLUDE statement specifies that a copy of the existing module
   OLD1 is to be used as a basis for the new module, NEW1.

x) COPYP=67 indicates that the horizontal copy feature should be
   activated, and that horizontal copies should begin printing in the
   67th print position from the left margin. This setting overrides any
   COPYP value previously set in module OLD1; it applies to module
   NEW1, but does not change the value set in OLD1.

   Note that the value 67 divides a 132-hammer printer into two equal
   copy areas for two equally-sized horizontal copies. With COPYP=67, a
   maximum of 66 bytes can be sent to the printer.

x) PSPEED=M indicates that the printer speed should be set to medium
   (3000 LPM). This setting overrides any PSPEED value previously set
   in module OLD1; it applies to module NEW1, but does not change the
   value set in OLD1.

x) DEFAULT=YES indicates that this module, NEW1, should become a
   default FCB module for this installation.

x) Because these parameters are not specified, the values of LINES,
   SIZE, LPI, and CHx default to the values which already exist in
   module OLD1.

x) The NAME statement indicates that this module should be called NEW1.

>< ADD NAME=IMAGE$08 0100-07003-07003-2113-00064-00064-00000-SC26UTL

Example 8: Build a New Copy Modification Module

3800 Model 1

In this example, a copy modification module that contains four
modification segments is built. The module is added to the SYS1.IMAGELIB
data set as a new member.

//COPMOD1 JOB ...
//STEP1   EXEC PGM=IEBIMAGE
//SYSUT1   DD  DISP=(OLD),DSN=SYS1.IMAGELIB
//SYSPRINT DD  SYSOUT=*
//SYSIN    DD  *
COPY1    COPYMOD COPIES=(1,1),LINES=(1,1),POS=50,                      X
               TEXT=(C,'CONTROLLER'S COPY')
COPY2A   COPYMOD COPIES=(2,1),LINES=(1,1),POS=50,                      X
               TEXT=(C,'SHIPPING MANAGER'S COPY')
COPY2B   COPYMOD COPIES=(2,1),LINES=(34,3),POS=75,                     X
               TEXT=(10C,' ')
COPYALL  COPYMOD COPIES=(1,4),LINES=(58,1),POS=35,                     X
               TEXT=((C,'***'),(C,'CONFIDENTIAL'),(3X,'5C'))
         NAME RTO1
/*

The control statements are discussed below:

x) The SYSUT1 DD statement includes DISP=OLD to ensure that no other
   job can modify the data set while this job is executing.

x) The COPY1 COPYMOD statement specifies text that applies to each page
   of the first copy of the output data set: LINES=(1,1) and POS=50
   specify that the text is to be on the first printable line of each
   page, starting at the 50th print position from the left.

   The TEXT parameter identifies each page of the copy as being the
   "Controller's Copy".

x) The COPY2A COPYMOD statement specifies text that applies to each
   page of the second copy of the output data set. The text is to be on
   the first line of each page, at the 50th print position from the
   left, with each page of the copy being the "Shipping Manager's
   Copy".

x) The COPY2B COPYMOD statement specifies that part of the second
   copy's output data set text is to be blanked out, so that the first,
   third, and subsequent copies contain information that is not printed
   on the second copy. The blank area is to be on lines 34, 35, and 36,
   beginning at the 75th print position from the left. The text on
   lines 34, 35, and 36, between print positions 75 and 84, is to be
   blank (that is, the character specified between the TEXT parameter's
   single quotation marks is a blank).

x) The COPYALL COPYMOD statement specifies text that applies to the
   first four copies of the output data set. This example assumes that
   no more than four copies are printed each time the job that produces
   the output data set is processed. The text is to be on the 58th line
   on each page, at the 35th print position from the left. The legend
   "***CONFIDENTIAL***" is to be on each page of the copy. Note that
   the text can be coded in both character and hexadecimal format.

x) The name of the copy modification module is RTO1; it is stored as a
   member of the SYS1.IMAGELIB data set.

>< ADD NAME=IMAGE$09 0100-07003-07003-2113-00058-00058-00000-SC26UTL

Example 9: Build a New Copy Modification Module from an Existing
Copy

3800 Model 3

In this example, a copy of an existing copy modification module, RTO1,
is used as the basis for a new copy modification module. The new module
is added to the SYS1.IMAGELIB data set as a new member. The existing
module, RTO1, remains unchanged and available for use.

//COPMOD2 JOB ...
//STEP1   EXEC PGM=IEBIMAGE
//SYSUT1   DD  DISP=(OLD),DSN=SYS1.IMAGELIB
//SYSPRINT DD  SYSOUT=*
//SYSIN    DD  *
         INCLUDE RTO1,DELSEG=1
         OPTION OVERRUN=8,DEVICE=3800M3
         COPYMOD COPIES=(2,3),LINES=(52,6),POS=100,                    X
               TEXT=(X,'40404040404040405C5C')
         NAME  AP
/*

The control statements are discussed below:

x) The SYSUT1 DD statement includes DISP=OLD to ensure that no other
   job can modify the data set while this job is executing.

x) The INCLUDE statement specifies that a copy of the copy modification
   module named RTO1 is used as a basis for the new module, and that
   the first modification segment of RTO1 is to be deleted from the
   copy.

x) OVERRUN=8 in the OPTION statement specifies that the IEBIMAGE
   program is to print a warning message if the copy modification could
   cause a line overrun condition when printing at 6 and 8 lines per
   inch. The program is also to suppress any warning messages that
   apply to printing at 10 and 12 lines per inch. DEVICE=3800M3 in the
   OPTION statement specifies 3800 Model 3 compatibility mode
   processing.

x) The COPYMOD statement specifies text that applies to each page of
   the second, third, and fourth copies of the output data set:
   LINES=(52,6) and POS=100 specify that the text is to be on the 52nd
   line and repeated for the 53rd through 57th lines of each page,
   starting at the 100th print position from the left.


   The TEXT statement specifies the text in hexadecimal form: eight
   blanks followed by two asterisks (in this example, the assumption is
   made that X'40' prints as a blank and that X'5C' prints as an
   asterisk; in actual practice, the character arrangement table used
   with the copy modification module might translate X'40' and X'5C' to
   other printable characters).

x) The name of the new copy modification module is AP; it is stored as
   a member of the SYS1.IMAGELIB data set.

>< ADD NAME=IMAGE$10 0100-07003-07003-2113-00046-00046-00000-SC26UTL

Example 10: Add a New Character to a Character Arrangement Table
Module

3800 Model 3

In this example, an IBM-supplied character arrangement table module is
modified to include another character, and then added to the
SYS1.IMAGELIB data set as a replacement for the IBM-supplied module.

//CHARMOD1 JOB ...
//STEP1   EXEC PGM=IEBIMAGE
//SYSUT1   DD  DISP=(OLD),DSN=SYS1.IMAGELIB
//SYSPRINT DD  SYSOUT=*
//SYSIN    DD  *
         INCLUDE GF10
         OPTION DEVICE=3800M3
         TABLE LOC=((2A,2A),(6A,2A),(AA,2A),(EA,2A))
         NAME GF10(R)
/*

The control statements are discussed below:

x) The SYSUT1 DD statement includes DISP=OLD to ensure that no other
   job can modify the data set while this job is executing.

x) The INCLUDE statement specifies that a copy of the character
   arrangement table named GF10 is to be used as a basis for the new
   module.

x) The OPTION statement with the DEVICE parameter specifies 3800 Model
   3 compatibility mode processing.

x) The TABLE statement specifies updated information for four
   translation table entries: X'2A', X'6A', X'AA', and X'EA'. (These
   four locations are unused in the IBM-supplied GF10 table.) Each of
   the four translation table entries is to point to the '2A' (43rd
   character) position in the first WCGM, which contains the scan
   pattern for a lozenge.

x) The name of the character arrangement table is GF10, and it is
   stored as a new module in the SYS1.IMAGELIB data set. The data set's
   directory is updated so that the name GF10 points to the new module;
   the old GF10 module can no longer be accessed through the data set's
   directory.

>< ADD NAME=IMAGE$11 0100-07003-07003-2113-00043-00043-00000-SC26UTL

Example 11: Build a New Character Arrangement Table Module from an
Existing Copy

3800 Model 3

In this example, an existing character arrangement table module is
copied and used as a basis for a new module. The new character
arrangement table is identical to the old one, except that it uses the
Gothic 15-pitch character set instead of Gothic 10-pitch.

//CHARMOD2 JOB ...
//STEP1   EXEC PGM=IEBIMAGE
//SYSUT1   DD  DISP=(OLD),DSN=SYS1.IMAGELIB
//SYSPRINT DD  SYSOUT=*
//SYSIN    DD  *
         INCLUDE A11
         OPTION  DEVICE=3800M3
         TABLE   CGMID=87
         NAME    A115
/*

The control statements are discussed below:

x) The SYSUT1 DD statement includes DISP=OLD to ensure that no other
   job can modify the data set while this job is executing.

x) The INCLUDE statement specifies that a copy of the character
   arrangement table named A11 is to be used as a basis for the new
   module. The A11 character arrangement table translates 8-bit data
   codes to printable characters in the Gothic 10-pitch character set.

x) The OPTION statement with the DEVICE parameter specifies 3800 Model
   3 compatibility mode processing.

x) The TABLE statement specifies a new character set identifier, X'87',
   which is the identifier for the Gothic 15-pitch character set. No
   other changes are made to the character arrangement table. The new
   table calls for characters in the Gothic 15-pitch character set.

x) The name of the new character arrangement table is A115; it is
   stored as a member of the SYS1.IMAGELIB data set.

>< ADD NAME=IMAGE$12 0100-07003-07003-2113-00054-00054-00000-SC26UTL

Example 12: Build Graphic Characters in a Character Arrangement
Table Module

3800 Model 1

In this example, an existing character arrangement table module is
copied and used as the basis for a new module that will include
user-designed characters of a graphic character modification module.
The new module is then added to the SYS1.IMAGELIB data set.

//CHARMOD3 JOB ...
//STEP1   EXEC PGM=IEBIMAGE
//SYSUT1   DD  DISP=(OLD),DSN=SYS1.IMAGELIB
//SYSPRINT DD  SYSOUT=*
//SYSIN    DD  *
         INCLUDE ONB
         TABLE   GCMLIST=ONB1,LOC=((6F,2F,1),(7C,3C,1),(6A,2A,0))
         NAME    ONBZ
/*

The control statements are discussed below:

x) The SYSUT1 DD statement includes DISP=OLD to ensure that no other
   job can modify the data set while this job is executing.

x) The INCLUDE statement specifies that a copy of the character
   arrangement table named ONB is to be used as a basis for the new
   module. ONB refers to two WCGMs.

x) The TABLE statement identifies a graphic character modification
   module and stipulates the translation table entries for each of its
   segments:

   GCMLIST=ONB1 identifies the graphic character modification module
   named ONB1. The LOC parameter specifies the translate table entry
   location, character position, and WCGM number for each segment of
   the module:

     The first segment corresponds to the 8-bit data code X'6F'. The
     segments' scan pattern is to be loaded at character position X'2F'
     (that is, the 48th character position) in the second WCGM.

     The second segment corresponds to the 8-bit data code X'7C'. The
     segment's scan pattern is to be loaded at character position X'3C'
     (that is, the 61st character position) in the second WCGM.

     The third segment corresponds to the 8-bit data code X'6A'. The
     segment's scan pattern is to be loaded at character position X'2A'
     (that is, the 43rd character position) in the first WCGM.

x) The name of the new character arrangement table is ONBZ; it is
   stored as a new module in the SYS1.IMAGELIB data set.

>< ADD NAME=IMAGE$13 0100-07003-07003-2113-00051-00051-00000-SC26UTL

Example 13: Delete Graphic References From a Character
Arrangement Table Module

3800 Model 3

In this example, an existing character arrangement table module is
copied and used as a basis for a new one. The new character arrangement
table deletes references to all graphic character modification modules
and resets the translate table entries that were used to point to
character positions for the segments of a graphic character
modification module.

//CHARMOD4 JOB ...
//STEP1   EXEC PGM=IEBIMAGE
//SYSUT1   DD  DISP=(OLD),DSN=SYS1.IMAGELIB
//SYSPRINT DD  SYSOUT=*
//SYSIN    DD  *
         INCLUDE ZYL
         OPTION  DEVICE=3800M3
         TABLE   GCMLIST=DELETE,LOC=((6A),(6B))
         NAME    ZYLA
/*

The control statements are discussed below:

x) The SYSUT1 DD statement includes DISP=OLD to ensure that no other
   job can modify the data set while this job is executing.

x) The INCLUDE statement specifies that a copy of the character
   arrangement table named ZYL is to be used as a basis for the new
   module.

x) The OPTION statement with the DEVICE parameter specifies 3800 Model
   3 compatibility mode processing.

x) The TABLE statement deletes references to graphic character
   modification modules and resets two translation table entries:

     GCMLIST=DELETE specifies that all names of graphic character
     modification modules included with the module when the ZYL
     character arrangement table was copied are to be reset to blanks
     (X'40').

     The LOC parameter identifies two locations in the translation
     table, X'6A' and X'6B', that are to be set to X'FF' (the default
     value when no character position or WCGM values are specified).

x) The name of the new character arrangement table is ZYLA; it is
   stored as a member of the SYS1.IMAGELIB data set.

>< ADD NAME=IMAGE$14 0100-07003-07003-2113-00029-00029-00000-SC26UTL

Example 14: List the World Trade National Use Graphics Graphic
Character Modification Module

3800 Model 1

In this example, each segment of the IBM-supplied graphic character
modification module containing the World Trade National Use Graphics is
printed. Each segment is unique, although the scan patterns for some
segments are identical to other segment's scan patterns with only the
8-bit data code being different.

//GRAFMOD1 JOB ...
//STEP1   EXEC PGM=IEBIMAGE
//SYSUT1   DD  DISP=(SHR),DSN=SYS1.IMAGELIB
//SYSPRINT DD  SYSOUT=*
//SYSIN    DD  *
         GRAPHIC
         NAME *
/*

The control statements are discussed below:

x) DISP=SHR is coded because the library is not being updated.

x) The World Trade National Use Graphics graphic character modification
   module is identified with the pseudonym of "*". The scan pattern of
   each of the characters in the module is printed.

>< ADD NAME=IMAGE$15 0100-07003-07003-2113-00039-00039-00000-SC26UTL

Example 15: Build a Graphic Character Modification Module from the
Character Modification Module World Trade GRAFMOD

3800 Model 3

In this example, a graphic character modification module is built. Its
characters are segments copied from the World Trade National Use
Graphics graphic character modification module. (See the IBM 3800
Printing Subsystem Programmer's Guide for the EBCDIC assignments for
the characters.) The new module is stored in the SYS1.IMAGELIB system
data set.

//GRAFMOD2 JOB ...
//STEP1   EXEC PGM=IEBIMAGE
//SYSUT1   DD  DISP=(OLD),DSN=SYS1.IMAGELIB
//SYSPRINT DD  SYSOUT=*
//SYSIN    DD  *
         OPTION DEVICE=3800M3
        GRAPHIC REF=((24),(25),(26),(27),(28),(31),(33),(35),(38),(40))
         NAME CSTW
/*

The control statements are discussed below:

x) The SYSUT1 DD statement includes DISP=OLD to ensure that no other
   job can modify the data set while this job is executing.

x) DEVICE=3800M3 in the OPTION statement specifies 3800 Model 3
   compatibility mode module format.

x) By not specifying the GCM keyword, the GRAPHIC statement identifies
   the World Trade National Use Graphics graphic character modification
   module. Ten of its segments are to be copied and used with the new
   module.

x) The name of the graphic character modification module is CSTW; it is
   stored as a new module in the SYS1.IMAGELIB data set.

>< ADD NAME=IMAGE$16 0100-07003-07003-2113-00085-00085-00000-SC26UTL

Example 16: Build a New Graphic Character Modification Module and
Modify a Character Arrangement Table to Use It

3800 Model 3

In this example, a graphic character modification module is built. The
module contains one user-designed character, a reverse 'E', whose 8-bit
data code is designated as X'E0' and whose pitch is 10. An existing
character arrangement table is then modified to include the reverse E.

//GRAFMOD3 JOB ...
//STEP1   EXEC PGM=IEBIMAGE
//SYSUT1   DD  DISP=(OLD),DSN=SYS1.IMAGELIB
//SYSPRINT DD  SYSOUT=*
//SYSIN    DD  *
         OPTION DEVICE=3800M3
         GRAPHIC ASSIGN=(E0,10)
XXXXXXXXXXXXXXX SEQ=10
XXXXXXXXXXXXXXX SEQ=11
XXXXXXXXXXXXXXX SEQ=12
XXXX SEQ=13
XXXX SEQ=14
XXXX SEQ=15
XXXX SEQ=16
XXXX SEQ=17
XXXX SEQ=18
XXXX SEQ=19
XXXXXXXXXXXXX SEQ=20
XXXXXXXXXXXXX SEQ=21
XXXXXXXXXXXXX SEQ=22
XXXX SEQ=23
XXXX SEQ=24
XXXX SEQ=25
XXXX SEQ=26
XXXX SEQ=27
XXXX SEQ=28
XXXX SEQ=29
XXXXXXXXXXXXXXX SEQ=30
XXXXXXXXXXXXXXX SEQ=31
XXXXXXXXXXXXXXX SEQ=32
         NAME    BODE
         INCLUDE GS10
         OPTION  DEVICE=3800M3
         TABLE   CGMID=(83,FF),GCMLIST=BODE,LOC=(E0,03,1)
         NAME    RE10
/*

The control statements are discussed below:

x) The SYSUT1 DD statement includes DISP=OLD to ensure that no other
   job can modify the data set while this job is executing.

x) DEVICE=3800M3 in the OPTION statement preceding the GRAPHIC
   statement specifies 3800 Model 3 compatibility mode processing.

x) The GRAPHIC statement's ASSIGN parameter establishes the 8-bit data
   code, X'E0', and the width, 10-pitch, for the user-designed
   character. The data statements that follow the GRAPHIC statement
   describe the character's scan pattern.

x) The name of the graphic character modification module is BODE, and
   it is stored as a new module in the SYS1.IMAGELIB data set.

x) The INCLUDE statement specifies that a copy of the GS10 character
   arrangement table is to be used as the basis for the new table.

x) The TABLE statement specifies the addition of the reverse E to that
   copy of the GS10 table.

x) CGMID=(83,FF) specifies the character set identifier X'83' for the
   Gothic-10 set (which is the set already used by the GS10 table) and
   specifies X'FF' as a character set identifier to allow accessing of
   the second WCGM without loading it.

x) GCMLIST=BODE identifies the graphic character modification module
   containing the reverse E for inclusion in the table. LOC=(E0,03,1)
   specifies that the reverse E, which has been assigned the 8-bit data
   code X'E0', is to be loaded into position X'03' in the second WCGM.
   Because this second WCGM is otherwise unused, any position in it
   could have been used for the reverse E.

x) The new character arrangement table is named RE10; it is stored as a
   new module in the SYS1.IMAGELIB data set.

>< ADD NAME=IMAGE$17 0100-07003-07003-2113-00067-00067-00000-SC26UTL

Example 17: Build a Graphic Character Modification Module from
Multiple Sources

3800 Model 1

In this example, a graphic character modification module is created.
Its contents come from three different sources: nine segments are copied
from an existing module with the INCLUDE statement; the GRAPHIC
statement is used to select another segment to be copied; the GRAPHIC
statement is also used to establish characteristics for a user-designed
character. The new graphic character modification module, when built, is
added to the SYS1.IMAGELIB.

//GRAFMOD4 JOB ...
//STEP1   EXEC PGM=IEBIMAGE
//SYSUT1   DD  DISP=(OLD),DSN=SYS1.IMAGELIB
//SYSPRINT DD  SYSOUT=*
//SYSIN    DD  *
         INCLUDE CSTW,DELSEG=3
         GRAPHIC REF=(1,6A),GCM=BODE,ASSIGN=9A
******** SEQ=06
********** SEQ=07
**** **** SEQ=08
*** *** SEQ=09
*** **** SEQ=10
*** ****** SEQ=11
*** ****** SEQ=12
*** **** SEQ=13
*** **** SEQ=14
*** *** SEQ=15
*** *** SEQ=16
*** **** **** SEQ=17
*** ******* SEQ=18
*** ***** SEQ=19
         NAME JPCK
/*

The control statements are discussed below:

x) The SYSUT1 DD statement includes DISP=OLD to ensure that no other
   job can modify the data set while this job is executing.

x) The INCLUDE statement specifies that a copy of the graphic character
   modification module named CSTW is to be included with the new
   module. All segments of CSTW, except the third segment (as a result
   of DELSEG=3), are to be copied into the new module and become the
   module's first through ninth modification segments.

x) The GRAPHIC statement specifies the module's tenth and eleventh
   segments:

   REF=(1,6A) and GCM=BODE specify that the 10th segment of the new
   module is to be obtained by copying the first segment from the
   graphic character modification module named BODE. In addition, the
   segment's 8-bit data code is to be changed so that its character is
   identified with the code X'6A'.

   ASSIGN=9A specifies that the new module's 11th segment is a
   user-designed character whose 8-bit data code is X'9A' and whose
   width is 10-pitch (the default when no pitch value is specified).
   The GRAPHIC statement is followed by data statements that specify the
   character's scan pattern.

x) The name of the graphic character modification module is JPCK, it is
   stored as a new module in the SYS1.IMAGELIB data set.

>< ADD NAME=IMAGE$18 0100-07003-07003-2113-00137-00137-00000-SC26UTL

Example 18: Define and Use a Character in a Graphic Character
Modification Module

3800 Model 3

In this example, a graphic character modification module containing a
user-designed character is built. Next, a format character arrangement
table is modified to include that new character. Then, a copy
modification module is created to print the new character enclosed in a
box of format characters. Finally, the result is tested to allow
comparison of the output with the input.

//CHAR JOB ...
//BUILD   EXEC PGM=IEBIMAGE
//SYSUT1   DD  DISP=(OLD),DSN=SYS1.IMAGELIB
//SYSPRINT DD  SYSOUT=*
//SYSIN    DD  *
         OPTION  DEVICE=3800M3
STEP1    GRAPHIC ASSIGN=5C
XXX XXX SEQ=01
XXX XXX SEQ=02
XXX XXX SEQ=03
XXX XXX SEQ=04
XXXXXXXXXXXXXXXXXXXXXXX SEQ=05
XXXXXXXXXXXXXXXXXXXXXXX SEQ=06
XXXXXXXXXXXXXXXXXXXXXXX SEQ=07
XXX XXX SEQ=08
XXX XXX SEQ=09
XXX XXX SEQ=10
XXX XXX SEQ=11
SEQ=12
SEQ=13
SEQ=14
XXXXXXXXXXXXXXXXXXXXXXX SEQ=15
XXXXXXXXXXXXXXXXXXXXXXX SEQ=16
XXXXXXXXXXXXXXXXXXXXXXX SEQ=17
XXX XXX XXX SEQ=18
XXX XXX XXX SEQ=19
XXX XXX XXX SEQ=20
XXX XXX XXX SEQ=21
XXXX XXXXX XXXX SEQ=22
XXXX XXXXXXX XXXX SEQ=23
XXXXXXXXXXXXXXXXXXX SEQ=24
XXXXX XXXXXX SEQ=25
SEQ=26
SEQ=27
SEQ=28
XXXXXXXXXXXXXXXXXXXXXXX SEQ=29
XXXXXXXXXXXXXXXXXXXXXXX SEQ=30
XXXXXXXXXXXXXXXXXXXXXXX SEQ=31
XXXXXXX SEQ=32
XXXXXXXXXXXXXXXXXX SEQ=33
XXXXXXXXXXXXXXXX SEQ=34
XXXXXXXXXXXXXXXX SEQ=35
XXXXXXXXXXXXXXXXXX SEQ=36
XXXXXXX SEQ=37
XXXXXXXXXXXXXXXXXXXXXXX SEQ=38
XXXXXXXXXXXXXXXXXXXXXXX SEQ=39
XXXXXXXXXXXXXXXXXXXXXXX SEQ=40
         NAME    AIBM
STEP2    OPTION  DEVICE=3800M3
         INCLUDE FM10
         TABLE   GCMLIST=AIBM,LOC=(5C,2C)
         NAME    BIBM
STEP3    OPTION  DEVICE=3800M3
         COPYMOD COPIES=1,LINES=58,POS=5,TEXT=(C,'W6X')
         COPYMOD COPIES=1,LINES=59,POS=5,TEXT=(C,'7*7')
         COPYMOD COPIES=1,LINES=60,POS=5,TEXT=(X,'E9F6E8')
         NAME    CIBM
/*
//TEST   EXEC PGM=IEBIMAGE
//SYSUT1   DD  DISP=(OLD),DSN=SYS1.IMAGELIB
//SYSPRINT DD  SYSOUT=*,CHARS=(GF10,BIBM),MODIFY=(CIBM,1)
//SYSIN    DD  *
         OPTION  DEVICE=3800M3
         GRAPHIC
         NAME    AIBM
/*

The control statements are discussed below:

x) The SYSUT1 DD statement includes DISP=OLD to ensure that no other
   job can modify the data set while this job is executing.

x) The GRAPHIC statement's ASSIGN parameter specifies that the 8-bit
   data code for the user-designed character is X'5C' and the width is
   10-pitch (the default when no pitch is specified). The GRAPHIC
   statement is followed by data statements that specify the
   character's scan pattern for vertical line spacing of 6 lines per
   inch.

x) The name of the graphic character modification module is AIBM, and
   it is stored as a new module in SYS1.IMAGELIB.

x) At STEP2, the INCLUDE statement specifies that a copy of the FM10
   character arrangement table is to be used as a basis for the new
   module.

x) The TABLE statement identifies the graphic character modification
   module named AIBM, created in the previous step. The TABLE
   statement's LOC parameter specifies the translation table entry
   location (the character's 8-bit data code) of X'5C' and the position
   (X'2C') where that character is to be loaded into the WCGM.

x) The name of the new character arrangement table, which is added to
   SYS1.IMAGELIB, is BIBM.

x) At STEP3, the three COPYMOD statements specify text that is to be
   placed on lines 58, 59, and 60 of the first copy of the output data
   set, starting at print position 5 on each line. When used with the
   BIBM character arrangement table, the characters W, 6, and X print as
   a top left corner, horizontal line segment, and top right corner, all
   in line weight 3. The characters 7, *, and 7 print as a weight-3
   vertical line segment on both sides of the user-designed character
   built at STEP1 (the asterisk has the EBCDIC assignment 5C, which
   addresses that character). The hexadecimal E9, F6, and E8 complete
   the line-weight-3 Format box around the character.

x) The name of the copy modification module is CIBM; it is stored as a
   new module on SYS1.IMAGELIB.

x) At TEST, the EXEC statement calls for another execution of the
   IEBIMAGE program to test the modules just created. On the SYSPRINT DD
   statement the BIBM character arrangement table is the second of two
   specified, and the CIBM copy modification module is specified with a
   table reference character of 1, to use that BIBM table.

x) The GRAPHIC statement with no operand specified calls for printing
   of the module, AIBM, specified with the NAME statement that follows
   it. Each page of the output listing for this IEBIMAGE run has a small
   image of the modification printed in the lower left corner.

x) The OPTION statement with the DEVICE parameter at STEP1, STEP2, and
   STEP3 specifies 3800 Model 3 compatibility mode module format and
   processing considerations.

>< ADD NAME=IMAGE$19 0100-07003-07003-2113-00021-00021-00000-SC26UTL

Example 19: List a Library Character Set Module

3800 Model 1

In this example, each segment of a library character set is printed.
The scan pattern of each of the characters in the module is printed.

//LIBMOD1 JOB ...
//STEP1   EXEC PGM=IEBIMAGE
//SYSUT1   DD  DISP=(SHR),DSN=SYS1.IMAGELIB
//SYSPRINT DD  SYSOUT=*
//SYSIN    DD  *
         CHARSET
         NAME    83
/*

The control statements are discussed below:

x) NAME specifies the name of the library character set (83).

>< ADD NAME=IMAGE$20 0100-07003-07003-2113-00042-00042-00000-SC26UTL

Example 20: Build a Library Character Set Module

3800 Model 3

In this example, a library character set module is built. Its
characters are segments copied from the World Trade National Use
Graphics graphic character modification module. For the listing of all
the segments of that module, see IBM 3800 Printing Subsystem
Programmer's Guide. The EBCDIC assignments for the characters are
replaced by WCGM-location codes. The new module is stored in the
SYS1.IMAGELIB system data set.

//LIBMOD2 JOB ...
//STEP1   EXEC PGM=IEBIMAGE
//SYSUT1   DD  DISP=(OLD),DSN=SYS1.IMAGELIB
//SYSPRINT DD  SYSOUT=*
//SYSIN    DD  *
         OPTION DEVICE=3800M3
         CHARSET REF=((24,01),(25,02),(26,03),(27,04),(28,05),         X
               (31,06),(33,07),(35,08),(38,09),(40,0A))
         NAME  73
/*

The control statements are discussed below:

x) The SYSUT1 DD statement includes DISP=OLD to ensure that no other
   job can modify the data set while this job is executing.

x) DEVICE=3800M3 in the OPTION statement specifies 3800 Model 3
   compatibility mode module format.

x) By not specifying the GCM keyword or a library character set ID, the
   CHARSET statement identifies the World Trade National Use Graphics
   graphic character modification module. Ten of its segments are to be
   copied and used with the new module. For example, the 24th segment
   is to be copied and assigned the WCGM location 01. See the REF
   parameter (24,01).

x) The name of the library character set module is 73, and it is stored
   as a new module in the SYS1.IMAGELIB data set.

>< ADD NAME=IMAGE$21 0100-07003-07003-2113-00082-00082-00000-SC26UTL

Example 21: Build a Library Character Set Module and Modify a
Character Arrangement Table to Use It

3800 Model 3

In this example, a library character set module is built. The module
contains one user-designed character, a reverse 'E', whose 6-bit
WCGM-location code is designated as X'03', and whose pitch is 10. An
existing character arrangement table is then modified to include the
reverse E.

//LIBMOD3 JOB ...
//STEP1   EXEC PGM=IEBIMAGE
//SYSUT1   DD  DISP=(OLD),DSN=SYS1.IMAGELIB
//SYSPRINT DD  SYSOUT=*
//SYSIN    DD  *
         OPTION  DEVICE=3800M3
         CHARSET ASSIGN=(03,10)
XXXXXXXXXXXXXXX SEQ=10
XXXXXXXXXXXXXXX SEQ=11
XXXXXXXXXXXXXXX SEQ=12
XXXX SEQ=13
XXXX SEQ=14
XXXX SEQ=15
XXXX SEQ=16
XXXX SEQ=17
XXXX SEQ=18
XXXX SEQ=19
XXXXXXXXXXXXX SEQ=20
XXXXXXXXXXXXX SEQ=21
XXXXXXXXXXXXX SEQ=22
XXXX SEQ=23
XXXX SEQ=24
XXXX SEQ=25
XXXX SEQ=26
XXXX SEQ=27
XXXX SEQ=28
XXXX SEQ=29
XXXXXXXXXXXXXXX SEQ=30
XXXXXXXXXXXXXXX SEQ=31
XXXXXXXXXXXXXXX SEQ=32
         NAME    73
         INCLUDE GS10
         OPTION  DEVICE=3800M3
         TABLE   CGMID=(83,73),LOC=(E0,03,1)
         NAME    RE10
/*

The control statements are discussed below:

x) The SYSUT1 DD statement includes DISP=OLD to ensure that no other
   job can modify the data set while this job is executing.

x) DEVICE=3800M3 in the OPTION statement specifies 3800 Model 3
   compatibility mode module format and processing considerations.

x) The CHARSET statement's ASSIGN parameter establishes the 6-bit
   WCGM-location code, X'03', and the width, 10-pitch, for the
   user-designed character. The data statements that follow the CHARSET
   statement describe the character's scan pattern.

x) The name of the library character set module is 73, and it is stored
   as a new module in the SYS1.IMAGELIB data set.

x) The INCLUDE statement specifies that a copy of the GS10 character
   arrangement table is to be used as the basis for the new table.

x) The TABLE statement specifies the addition of the library character
   set containing the reverse E to that copy of the GS10 table.
   CGMID=(83,73) specifies the character set identifier X'83' for the
   Gothic-10 set (which is the set already used by the GS10 table) and
   specifies X'73' as a character set identifier to allow loading of
   the second WCGM with the library character set 73.

x) LOC=(E0,03,1) specifies that the reverse E, which has been assigned
   the WCGM location 03 in the second WCGM, is to be referenced by the
   EBCDIC code X'E0'.

x) The new character arrangement table is named RE10; it is stored as a
   new module in the SYS1.IMAGELIB data set.

>< ADD NAME=IMAGE$22 0100-07003-07003-2113-00067-00067-00000-SC26UTL

Example 22: Build a Library Character Set Module from Multiple
Sources

3800 Model 1

In this example, a library character set module is created. Its
contents come from three different sources: 62 segments are copied from
an existing module with the INCLUDE statement; the CHARSET statement is
used to select another segment to be copied; a second CHARSET statement
is used to establish characteristics for a user-designed character. The
new library character set module, when built, is added to the
SYS1.IMAGELIB.

//LIBMOD4 JOB ...
//STEP1   EXEC PGM=IEBIMAGE
//SYSUT1   DD  DISP=(OLD),DSN=SYS1.IMAGELIB
//SYSPRINT DD  SYSOUT=*
//SYSIN    DD  *
         INCLUDE 33,DELSEG=(3,4)
         CHARSET REF=(1,02),GCM=BODE,ASSIGN=03
******** SEQ=06
********** SEQ=07
**** **** SEQ=08
*** *** SEQ=09
*** **** SEQ=10
*** ****** SEQ=11
*** ****** SEQ=12
*** **** SEQ=13
*** **** SEQ=14
*** *** SEQ=15
*** *** SEQ=16
*** **** **** SEQ=17
*** ******* SEQ=18
*** ***** SEQ=19
         NAME    53
/*

The control statements are discussed below:

x) The SYSUT1 DD statement includes DISP=OLD to ensure that no other
   job can modify the data set while this job is executing.

x) The INCLUDE statement specifies that a copy of the library character
   set module named 33 is to be included with the new module. All
   segments of 33, except the third and fourth segments (as a result of
   DELSEG=3,4), are to be copied into the new module and become the
   basis for the new module.

x) The CHARSET statement specifies the module's third and fourth
   segments:

   REF=(1,02) and GCM=BODE specify that the third segment of the new
   module is to be obtained by copying the first segment from the
   graphic character modification module named BODE. The segment's
   6-bit WCGM-location code is to be set so that its character is
   identified with the code X'02'.

   ASSIGN=03 specifies that the new module's fourth segment is a
   user-designed character whose 6-bit WCGM-location code is X'03' and
   whose width is 10-pitch (the default when no pitch value is
   specified). The CHARSET statement is followed by data statements
   that specify the character's scan pattern.

x) The name of the library character set module is 53, it is stored as
   a new module in the SYS1.IMAGELIB data set.

./ ADD NAME=IEBPTPCH 0666-07209-07209-1502-00001-00001-00000-DIR2UPDT
>< ADD NAME=PTPCH    0101-07003-07016-2350-00013-00013-00000-KTOMIAK

PTPCH$01  Print Partitioned Data Set
PTPCH$02  Punch Sequential Data Sets
PTPCH$03  Duplicate a Card Deck
PTPCH$04  Print Sequential Data Set According to Default Format
PTPCH$05  Print Sequential Data Set According to User Specifications
PTPCH$06  Print Three Record Groups
PTPCH$07  Print a Pre-Formatted Data Set
PTPCH$08  Print Directory of a Partitioned Data Set
PTPCH$09  Print Selected Records of a Partitioned Data Set
PTPCH$10  Convert to Hexadecimal and Print Partitioned Data
PTPCH$11  Print Member Containing DBCS Data

>< ADD NAME=PTPCH$01 0101-07003-07003-2113-00020-00020-00000-SC26UTL

Example 1: Print Partitioned Data Set

In this example, a member of partitioned data set is printed according
to user specifications.

//PHSEQNO JOB ...
//STEP1   EXEC PGM=IEBPTPCH
//SYSPRINT DD  SYSOUT=*
//SYSUT1   DD  DISP=SHR,DSN=YOUR.PDS.DATASET
//SYSUT2   DD  SYSOUT=B
//SYSIN    DD  *
         PRINT TYPORG=PO,MAXNAME=1,MAXFLDS=1
         MEMBER NAME=UTILUPD8
         RECORD FIELD=(80)
/*

If the member card entry is not used, the entire data cell will be
printed.

>< ADD NAME=PTPCH$02 0100-07003-07003-2113-00047-00047-00000-SC26UTL

Example 2: Punch Sequential Data Sets

In this example, a sequential data set is punched according to user
specifications.

//PHSEQNO JOB ...
//STEP1   EXEC PGM=IEBPTPCH
//SYSPRINT DD  SYSOUT=*
//SYSUT1   DD  DISP=(SHR,KEEP),DSN=MASTER.SEQSET
//SYSUT2   DD  SYSOUT=B
//SYSIN    DD  *
         PUNCH MAXFLDS=1,CDSEQ=0,CDINCR=20
         RECORD FIELD=(72)
         LABELS DATA=YES
/*

The control statements are discussed below:

x) SYSUT1 DD defines the input data set, MASTER.SEQSET, which resides
   on a disk or tape volume. The data set contains 80-byte, fixed
   blocked records.

x) SYSUT2 DD defines the system output class (punch is assumed). That
   portion of each record from the input data set defined by the FIELD
   parameter is represented by one punched card.

x) SYSIN DD defines the control data set, which follows in the input
   stream.

x) PUNCH begins the punch operation, indicates that one FIELD parameter
   is included in a subsequent RECORD statement (MAXFLDS=1), and
   assigns a sequence number for the first punched card (00000000) and
   an increment value for successive sequence numbers (20). Sequence
   numbers are placed in columns 73 through 80 of the output records.

x) RECORD indicates that positions 1 through 72 of the input records
   are to be punched. Bytes 73 through 80 of the input records are
   replaced by the new sequence numbers in the output card deck.

x) LABELS specifies that user header labels and user trailer labels are
   punched.

   Labels cannot be edited; they are always moved to the first 80 bytes
   of the output buffer. No sequence numbers are present on the cards
   containing user header and user trailer records.

>< ADD NAME=PTPCH$03 0100-07003-07003-2113-00028-00028-00000-SC26UTL

Example 3: Duplicate a Card Deck

In this example, a card deck containing valid punch card code or BCD is
duplicated.

//PUNCH JOB ...
//STEP1   EXEC PGM=IEBPTPCH
//SYSPRINT DD  SYSOUT=*
//SYSIN    DD  DISP=(OLD),DSN=PDSLIB(PNCHSTMT)
//SYSUT2   DD  SYSOUT=B
//SYSUT1   DD  DATA

(input card data set including // cards)

/*

The control statements are discussed below:

x) SYSIN DD defines the control data set PDSLIB which contains the
   member PNCHSTMT. (The data set is cataloged.) The record format must
   be FB and the logical record length must be 80.

x) SYSUT2 DD defines the system output class (punch is assumed).

x) SYSUT1 DD defines the input card data set, which follows in the
   input stream.

>< ADD NAME=PTPCH$04 0100-07003-07003-2113-00035-00035-00000-SC26UTL

Example 4: Print Sequential Data Set According to Default Format

In this example, a sequential data set is printed according to the
default format. The printed output is converted to hexadecimal.

//PRINT JOB ...
//STEP1   EXEC PGM=IEBPTPCH
//SYSPRINT DD  SYSOUT=*
//SYSUT1   DD  DISP=(OLD),DSN=INSET,
//             UNIT=tape,LABEL=(,NL),
//             DCB=(RECFM=U,BLKSIZE=2000)
//SYSUT2   DD  SYSOUT=*
//SYSIN    DD  *
         PRINT TOTCONV=XE
         TITLE ITEM=('PRINT SEQ DATA SET WITH CONV TO HEX',10)
/*

The control statements are discussed below:

x) SYSUT1 DD defines the input data set on a tape volume. The data set
   contains undefined records; no record is larger than 2,000 bytes.

x) SYSUT2 DD defines the output data set. The data set is written to
   the system output device (printer assumed).

x) SYSIN DD defines the control data set, which follows in the input
   stream.

x) PRINT begins the print operation and specifies conversion from
   alphanumeric to hexadecimal representation.

x) TITLE specifies a title to be placed beginning in column 10 of the
   printed output. The title is not converted to hexadecimal.

>< ADD NAME=PTPCH$05 0100-07003-07003-2113-00044-00044-00000-SC26UTL

Example 5: Print Sequential Data Set According to User Specifications

In this example, a sequential data set is printed according to user
specifications.

//PTNONSTD JOB ...
//STEP1   EXEC PGM=IEBPTPCH
//SYSPRINT DD  SYSOUT=*
//SYSUT1   DD  DISP=(OLD),DSN=SEQSET
//SYSUT2   DD  SYSOUT=*
//SYSIN    DD  *
         PRINT MAXFLDS=1
         EXITS INHDR=HDRIN,INTLR=TRLIN
         RECORD FIELD=(80)
         LABELS DATA=YES
/*

The control statements are discussed below:

x) SYSUT1 DD defines the input data set, SEQSET, which is the second
   data set on a tape volume.

x) SYSUT2 DD defines the output data set on the system output device
   (printer assumed). Each printed line contains 80 contiguous
   characters (one record) of information.

x) SYSIN DD defines the control data set, which follows in the input
   stream.

x) PRINT begins the print operation and indicates that one FIELD
   parameter is included in a subsequent RECORD statement (MAXFLDS=1).

x) EXITS indicates that exits will be taken to user header label and
   trailer label processing routines when these labels are encountered
   on the SYSUT1 data set.

x) RECORD indicates that each input record is processed in its entirety
   (80 bytes). Each input record is printed in columns 1 through 80 on
   the printer.

x) LABELS specifies that user header and trailer labels are printed
   according to the return code issued by the user exits.

>< ADD NAME=PTPCH$06 0100-07003-07003-2113-00081-00081-00000-SC26UTL

Example 6: Print Three Record Groups

In this example, three record groups are printed. A user routine is
provided to manipulate output records before they are printed.

//PRINT JOB ...
//STEP1   EXEC PGM=IEBPTPCH
//SYSPRINT DD  SYSOUT=*
//SYSUT1   DD  DISP=(OLD),DSN=SEQDS
//SYSUT2   DD  SYSOUT=*
//SYSIN    DD  *
         PRINT MAXFLDS=9,MAXGPS=9,MAXLITS=23,STOPAFT=32767
         TITLE ITEM=('TIMECONV-DEPT D06'),                             X
               ITEM=('JAN10-17',80)
         EXITS OUTREC=NEWTIME,INHDR=HDRS,INTLR=TLRS
         RECORD IDENT=(6,'498414',1),                                  X
               FIELD=(8,1,,10),FIELD=(30,9,XE,20)
         RECORD IDENT=(2,'**',39),                                     X
               FIELD=(8,1,,10),FIELD=(30,9,XE,20)
         RECORD IDENT=(6,'498414',1),                                  X
               FIELD=(8,1,,10),FIELD=(30,9,XE,20)
         LABELS CONV=XE,DATA=ALL
/*

The control statements are discussed below:

x) SYSUT1 DD defines the input data set, called SEQDS. The data set
   resides on a disk volume.

x) SYSUT2 DD defines the output data set on the system output device
   (printer assumed).

x) SYSIN DD defines the control data set, which follows in the input
   stream.

x) The PRINT statement:

   1. Initializes the print operation.
   2. Indicates that not more than nine FIELD parameters are included
      in subsequent RECORD statements (MAXFLDS=9).
   3. Indicates that not more than nine IDENT parameters are included
      in subsequent RECORD statements (MAXGPS=9).
   4. Indicates that not more than 23 literal characters are included
      in subsequent IDENT parameters (MAXLITS=23).
   5. Indicates that processing is ended after 32767 records are
      processed or after the third record group is processed, whichever
      comes first. Because MAXLINE is omitted, 60 lines are printed on
      each page.

x) TITLE specifies two titles, to be printed on one line. The titles
   are not converted to hexadecimal.

x) EXITS specifies the name of a user routine (NEWTIME), which is used
   to manipulate output records before they are printed.

x) The first RECORD statement defines the first record group to be
   processed and indicates where information from the input records is
   placed in the output records. Positions 1 through 8 of the input
   records appear in positions 10 through 17 of the printed output, and
   positions 9 through 38 are printed in hexadecimal representation and
   placed in positions 20 through 79.

x) The second RECORD statement defines the second group to be
   processed. The parameter in the IDENT operand specifies that an
   input record last record edited according to the FIELD operand in
   this RECORD statement. The FIELD operand specifies that positions 1
   through 8 of the input records are placed in positions 10 through 17
   of the printed output, and positions 9 through 38 are printed in
   hexadecimal representation and appear in positions 20 through 79.

x) The third and last RECORD statement is equal to the first RECORD
   statement. An input record that meets the parameter in the IDENT
   operand ends processing, unless the STOPAFT parameter in the PRINT
   statement has not already done so.

x) LABELS specifies that all user header or trailer labels are to be
   printed regardless of any return code, except 16, issued by the
   user's exit routine. It also indicates that the labels are converted
   from alphanumeric to hexadecimal representation (CONV=XE).

>< ADD NAME=PTPCH$07 0100-07003-07003-2113-00033-00033-00000-SC26UTL

Example 7: Print a Pre-Formatted Data Set

In this example, the input is a SYSOUT (sequential) data set, which was
previously written as the second data set of a standard label tape. It
is printed in SYSOUT format.

//PTSYSOUT JOB ...
//STEP1   EXEC PGM=IEBPTPCH
//SYSPRINT DD  SYSOUT=*
//SYSUT1   DD  DISP=(OLD),DSN=LISTING
//SYSUT2   DD  SYSOUT=*
//SYSIN    DD  *
         PRINT PREFORM=A
/*


The control statements are discussed below:

x) SYSUT1 DD defines the input data set, which was previously written
   as the second data set of a standard label tape. The data set has
   been assigned the name LISTING.

x) SYSUT2 DD defines the output data set on the system output device
   (printer assumed).

x) SYSIN DD defines the control data set, which follows in the input
   stream.

x) The PRINT statement begins the print operation and indicates that an
   ASA control character is provided as the first character of each
   record to be printed (PREFORM=A).

>< ADD NAME=PTPCH$08 0100-07003-07003-2113-00051-00051-00000-SC26UTL

Example 8: Print Directory of a Partitioned Data Set

In this example, the directory of a partitioned data set is printed
according to the default format. The printed output is converted to
hexadecimal.

//PRINTDIR JOB ...
//STEP1   EXEC PGM=IEBPTPCH
//SYSPRINT DD  SYSOUT=*
//SYSUT1   DD  DISP=(OLD),DSN=MAIN.PDS,
//             DCB=(RECFM=U,BLKSIZE=256)
//SYSUT2   DD  SYSOUT=*
//SYSIN    DD  *
         PRINT TYPORG=PS,TOTCONV=XE
         TITLE ITEM=('PRINT PARTITIONED DIRECTORY OF PDS',10)
         TITLE ITEM=('FIRST TWO BYTES SHOW NUM OF USED BYTES',10)
         LABELS DATA=NO
/*

The control statements are discussed below:

x) SYSUT1 DD defines the input data set (the partitioned directory),
   which resides on a disk volume. The DCB keywords describe the
   directory, not the member contents.

x) SYSUT2 DD defines the output data set on the system output device
   (printer assumed).

x) SYSIN DD defines the control data set, which follows in the input
   stream.

x) PRINT begins the print operation, indicates that the partitioned
   directory is organized sequentially, and specifies conversion from
   alphanumeric to hexadecimal representation.

x) The first TITLE statement specifies a title, and the second TITLE
   statement specifies a subtitle. Neither title is converted to
   hexadecimal.

x) LABELS specifies that no user labels are printed.

   Note: Not all of the bytes in a directory block need to contain data
   pertaining to the partitioned data set. Unused bytes are sometimes
   used by the operating system as temporary work areas. With
   conversion to hexadecimal representation, the first four characters
   of printed output indicate how many bytes of the 256-byte block
   pertain to the partitioned data set. Any unused bytes occur in the
   latter portion of the directory block. They are not interspersed
   with the used bytes.

>< ADD NAME=PTPCH$09 0100-07003-07003-2113-00036-00036-00000-SC26UTL

Example 9: Print Selected Records of a Partitioned Data Set

In this example, a partitioned data set (ten records from each member)
is printed according to the default format. The printed output is
converted to hexadecimal.

//PRINTPDS JOB ...
//STEP1   EXEC PGM=IEBPTPCH
//SYSPRINT DD  SYSOUT=*
//SYSUT1   DD  DISP=(SHR),DSN=WAYNE.TEST.DATA
//SYSUT2   DD  SYSOUT=*
//SYSIN    DD  *
         PRINT TOTCONV=XE,TYPORG=PO,STOPAFT=10
         TITLE ITEM=('PRINT PDS -10 RECS EACH MEM',20)
/*

The control statements are discussed below:

x) SYSUT1 DD defines the input data set, called WAYNE.TEST.DATA, on a
   disk volume.

x) SYSUT2 DD defines the output data set on the system output device
   (printer assumed).

x) SYSIN DD defines the control data set, which follows in the input
   stream.

x) PRINT begins the print operation, specifies conversion from
   alphanumeric to hexadecimal representation, indicates that the input
   data set is partitioned, and specifies that 10 records from each
   member are to be printed.

x) TITLE specifies a title to be placed beginning in column 20 of the
   printed output. The title is not converted to hexadecimal.

>< ADD NAME=PTPCH$10 0100-07003-07003-2113-00040-00040-00000-SC26UTL

Example 10: Convert to Hexadecimal and Print Partitioned Data

In this example, two partitioned members are printed according to the
default format. The printed output is converted to hexadecimal.

//PRNTMEMS JOB ...
//STEP1   EXEC PGM=IEBPTPCH
//SYSPRINT DD  SYSOUT=*
//SYSUT1   DD  DISP=(SHR),DSN=BROWN.MAIN.LIB
//SYSUT2   DD  SYSOUT=*
//SYSIN    DD  *
         PRINT TYPORG=PO,TOTCONV=XE,MAXNAME=2
         TITLE ITEM=('PRINT TWO MEMBS WITH CONV TO HEX',10)
         MEMBER NAME=MEMBER1
         MEMBER NAME=MEMBER2
/*

The control statements are discussed below:

x) SYSUT1 DD defines the input data set, called BROWN.MAIN.LIB, on a
   disk volume.

x) SYSUT2 DD defines the output data set on the system output device
   (printer assumed).

x) SYSIN DD defines the control data set, which follows in the input
   stream.

x) PRINT begins the print operation, indicates that the input data set
   is partitioned, specifies conversion from alphanumeric to
   hexadecimal representation, and indicates that two MEMBER statements
   appear in the control data set (MAXNAME=2).

x) TITLE specifies a title to be placed beginning in column 10 of the
   printed output. The title is not converted to hexadecimal.

x) MEMBER specifies the member names of the members to be printed
   (MEMBER1 and MEMBER2).

>< ADD NAME=PTPCH$11 0100-07003-07003-2113-00038-00038-00000-SC26UTL

Example 11: Print Member Containing DBCS Data

In this example, a member of a partitioned data set that contains DBCS
data is printed after the DBCS data is checked to ensure that all DBCS
characters are printable.

//DBCS JOB ...
//STEP1   EXEC PGM=IEBPTPCH
//SYSPRINT DD  SYSOUT=*
//SYSUT1   DD  DISP=(OLD),DSN=PDS
//SYSUT2   DD  SYSOUT=*
//SYSIN    DD  *
         PRINT TYPORG=PO,DBCS=YES,MAXFLDS=1,MAXNAME=1
         MEMBER NAME=MEM1
         RECORD FIELD=(,,CV)
/*

The control statements are discussed below:

x) SYSUT1 DD defines the input data set, PDS, on a disk volume.

x) SYSUT2 DD defines the system printer as the output data set.

x) SYSIN DD defines the control data set, which follows in the input
   stream.

x) PRINT begins the print operation, indicates that the input data set
   is partitioned, and indicates that double-byte character set data
   will be printed. The statement also indicates that one MEMBER
   statement appears in the control data set, and that one FIELD
   parameter appears on a subsequent RECORD statement.

x) MEMBER specifies the member, MEM1, that is to be printed.

x) RECORD specifies that the DBCS data is to be checked to ensure that
   it is printable.

./ ADD NAME=IEBUPDTE 0666-07210-07210-1544-00001-00001-00000-DIR2UPDT
>< ADD NAME=UPDTE    0102-07003-07166-1102-00014-00015-00000-KTOMIAK

UPDTE$01  Place Two Procedures in SYS1.PROCLIB
UPDTE$02  Create a Three-Member Library
UPDTE$03  Create New Library Using SYS1.MACLIB as a Source
UPDTE$04  Update a Library Member
UPDTE$05  Create New Master Data Set and Delete Selected Records
UPDTE$06  Create and Update a Library Member
UPDTE$07  Insert Records into a Library Member
UPDTE$08  Renumber and Insert Records into a Library Member
UPDTE$09  Create a Sequential Data Set from Card Input
UPDTE$10  Copy Sequential Data Set from One Volume to Another
UPDTE$11  Create a New Partitioned Data Set
UPDTE$12  Erase it?
UPDTE$13  Add a member with an alias

>< ADD NAME=UPDTE$01 0101-07003-07003-2113-00069-00069-00000-SC26UTL

Example 1: Place Two Procedures in SYS1.PROCLIB

In this example, two procedures are to be placed in the cataloged
procedure library, SYS1.PROCLIB. The example assumes that the two
procedures can be accommodated within the space originally allocated to
the procedure library.

//UPDATEJOB ...
//STEP1   EXEC PGM=IEBUPDTE,PARM=MOD
//SYSPRINT DD  SYSOUT=*
//SYSUT1   DD  DISP=(OLD),DSN=SYS1.PROCLIB
//SYSUT2   DD  DISP=(OLD),DSN=SYS1.PROCLIB
//*                                          <==== SHIFT THE DATA LEFT
//SYSIN    DD  DATA
  ./       ADD    LIST=ALL,NAME=ERASE,LEVEL=01,SOURCE=0
  ./       NUMBER NEW1=10,INCR=10
  //ERASE   EXEC PGM=IEBUPDTE
  //DD1      DD  DISP=(OLD),UNIT=disk,VOL=SER=111111
  //SYSPRINT DD  SYSOUT=*
  ./       REPL   LIST=ALL,NAME=LISTPROC
  ./       NUMBER NEW1=10,INCR=10
  //LIST    EXEC PGM=IEBGENER
  //SYSPRINT DD  SYSOUT=*
  //SYSUT1   DD  DISP=SHR,DSN=SYS1.PROCLIB(&MEMBER)
  //SYSUT2   DD  SYSOUT=*,DCB=(RECFM=F,BLKSIZE=80)
  //SYSIN    DD  DATA
  ./ ENDUP
/*
//                                           <==== SHIFT THE DATA LEFT

The control statements are discussed below:

x) SYSUT1 and SYSUT2 DD define the SYS1.PROCLIB data set, which is
   assumed to be cataloged.

x) SYSIN DD defines the control data set, which follows in the input
   stream. The data set contains the utility control statements and the
   data to be placed in the procedure library.

x) The ADD function statement indicates that records (data statements)
   in the control data set are to be placed in the output. The newly
   created procedure, ERASE, is listed in the message data set.

   The ADD function will not take place if a member named ERASE already
   exists in the new master data set referenced by SYSUT2.

x) The first NUMBER detail statement indicates that the new and
   replacement procedures are to be assigned sequence numbers. The
   first record of each procedure is assigned sequence number 10; the
   next record is assigned sequence number 20, and so on.

x) The ERASE EXEC statement marks the beginning of the first new
   procedure.

x) The REPL function statement indicates that records (data statements)
   in the control data set are to replace an already existing member.
   The member is stored in the new master data set referenced by
   SYSUT2. The REPL function will only take place if a member named
   LISTPROC already exists in the old master data set referenced by
   SYSUT1.

x) The second NUMBER detail statement is a duplicate of the first.

x) The LIST EXEC statement marks the beginning of the second new
   procedure.

x) The ENDUP statement marks the end of the SYSIN DD input data.

>< ADD NAME=UPDTE$02 0101-07003-07003-2113-00057-00057-00000-SC26UTL

Example 2: Create a Three-Member Library

In this example, a three-member partitioned library is created. The
input data is contained solely in the control data set.

//UPDATEJOB ...
//STEP1   EXEC PGM=IEBUPDTE,PARM=NEW
//SYSPRINT DD  SYSOUT=*
//SYSUT2   DD  DISP=(NEW,CATLG),DSN=OUTLIB,
//             UNIT=disk,
//             SPACE=(TRK,(50,,10)),
//             DCB=(RECFM=FB,BLKSIZE=0,LRECL=80)
//*                                          <==== SHIFT THE DATA LEFT
//SYSIN DD  DATA
  ./ ADD NAME=MEMB1,LEVEL=00,SOURCE=0,LIST=ALL

  (Data statements, sequence numbers in columns 73 through 80)

  ./ ADD NAME=MEMB2,LEVEL=00,SOURCE=0,LIST=ALL

  (Data statements, sequence numbers in columns 73 through 80)

  ./ ADD NAME=MEMB3,LEVEL=00,SOURCE=0,LIST=ALL

  (Data statements, sequence numbers in columns 73 through 80)

  ./ ENDUP
/*
//                                           <==== SHIFT THE DATA LEFT

The control statements are discussed below:

x) SYSUT2 DD defines the new partitioned master, OUTLIB. Enough space
   is allocated to allow for subsequent modifications without creating a
   new master data set.

x) SYSIN DD defines the control data set, which follows in the input
   stream. The data set contains the utility control statements and the
   data to be placed as three members in the output partitioned data
   set.

x) The ADD function statements indicate that subsequent data statements
   are to be placed as members in the output partitioned data set. Each
   ADD function statement specifies a member name for subsequent data
   and indicates that the member and control statement is listed in the
   message data set.

x) The data statements contain the data to be placed in each member of
   the output partitioned data set.

x) ENDUP signals the end of control data set input.

Because sequence numbers (other than blank numbers) are included within
the data statements, no NUMBER detail statements are included in the
example.

>< ADD NAME=UPDTE$03 0101-07003-07003-2113-00063-00063-00000-SC26UTL

Example 3: Create New Library Using SYS1.MACLIB as a Source

In this example, a three-member partitioned data set (NEWMCLIB) is
created. The data set will contain two members, ATTACH and DETACH,
copied from an existing partitioned data set (SYS1.MACLIB), and a new
member, EXIT, which is contained in the control data set.

//UPDATEJOB ...
//STEP1   EXEC PGM=IEBUPDTE,PARM=MOD
//SYSPRINT DD  SYSOUT=*
//SYSUT1   DD  DISP=(SHR,KEEP),DSN=SYS1.MACLIB,DISP=SHR
//SYSUT2   DD  DISP=(NEW,CATLG),DSN=DEV.DRIVER3.NEWMCLIB,
//             UNIT=disk,
//             SPACE=(TRK,(100,,10)),
//             DCB=(RECFM=FB,BLKSIZE=0,,LRECL=80)
//*                                          <==== SHIFT THE DATA LEFT
//SYSIN DD  DATA
  ./        REPRO  NAME=ATTACH,LEVEL=00,SOURCE=1,LIST=ALL
  ./        REPRO  NAME=DETACH,LEVEL=00,SOURCE=1,LIST=ALL
  ./        ADD    NAME=EXIT,LEVEL=00,SOURCE=1,LIST=ALL
  ./        NUMBER NEW1=10,INCR=100

  (Data records for EXIT member)

  ./ ENDUP
/*
//                                           <==== SHIFT THE DATA LEFT

The control statements are discussed below:

x) SYSUT1 DD defines the input partitioned data set SYS1.MACLIB, which
   is assumed to be cataloged.

x) SYSUT2 DD defines the output partitioned data set
   DEV.DRIVER3.NEWMCLIB. Enough space is allocated to allow for
   subsequent modifications without creating a new master data set.

x) SYSIN DD defines the control data set, which follows in the input
   stream.

x) The REPRO function statements identify the existing input members
   (ATTACH and DETACH) to be copied onto the output data set. These
   members are also listed in the message data set (because LIST=ALL is
   specified).

x) The ADD function statement indicates that records (subsequent data
   statements) are to be placed as members in the output partitioned
   data set, called EXIT. The data statements are to be listed in the
   message data set.

x) The NUMBER detail statement assigns sequence numbers to the data
   statements. (The data statements contain blank sequence numbers in
   columns 73 through 80.) The first record of the output member is
   assigned sequence number 10; subsequent record numbers are increased
   by 100.

x) ENDUP signals the end of SYSIN data.

   Note that the three named input members (ATTACH, DETACH, and EXIT)
   do not have to be specified in the order of their collating sequence
   in the old master.

>< ADD NAME=UPDTE$04 0101-07003-07003-2113-00045-00045-00000-SC26UTL

Example 4: Update a Library Member

In this example, a member (MODMEMB) is updated within the space it
actually occupies. Two existing logical records are replaced, and the
entire member is renumbered.

//UPDATEJOB ...
//STEP1    EXEC PGM=IEBUPDTE,PARM=MOD
//SYSPRINT DD  SYSOUT=*
//SYSUT1   DD  DISP=(OLD),DSN=PDS
//*                                          <==== SHIFT THE DATA LEFT
//SYSIN    DD  *
  ./       CHANGE NAME=MODMEMB,LIST=ALL,UPDATE=INPLACE
  ./       NUMBER SEQ1=ALL,NEW1=10,INCR=5

  (Data statement 1, sequence number 00000020)
  (Data statement 2, sequence number 00000035)

/*
//                                           <==== SHIFT THE DATA LEFT

The control statements are discussed below:

x) SYSUT1 DD defines the partitioned data set that is updated in place.
   (Note that the member name need not be specified in the DD
   statement.)

x) SYSIN DD defines the control data set, which follows in the input
   stream.

x) The CHANGE function statement indicates the name of the member to be
   updated (MODMEMB) and specifies the UPDATE=INPLACE operation. The
   entire member is listed in the message data set. Note that, as
   renumbering is being done, and since UPDATE=INPLACE was specified,
   the listing would have been provided even if the LIST=ALL parameter
   had not been specified. See the LIST parameter for more information.

x) The NUMBER detail statement indicates that the entire member is to
   be renumbered, and specifies the first sequence number to be assigned
   and the increment value (5) for successive sequence numbers.

x) The data statements replace existing logical records having sequence
   numbers of 20 and 35.

>< ADD NAME=UPDTE$05 0101-07003-07003-2113-00055-00055-00000-SC26UTL

Example 5: Create New Master Data Set and Delete Selected Records

In this example, a new master sequential data set is created from
partitioned input and selected logical records are deleted.

//UPDATEJOB ...
//STEP1   EXEC PGM=IEBUPDTE,PARM=MOD
//SYSPRINT DD  SYSOUT=*
//SYSUT1   DD  DISP=(OLD),DSN=DCB.PARTDS
//SYSUT2   DD  DISP=(NEW,CATLG),DSN=SEQDS,
//             UNIT=tape,LABEL=(2,SL),
//             DCB=(RECFM=FB,BLKSIZE=0,LRECL=80)
//*                                          <==== SHIFT THE DATA LEFT
//SYSIN    DD  *
  ./       CHANGE NEW=PS,NAME=OLDMEMB1

  (Data statement 1, sequence number 00000123)

  ./       DELETE SEQ1=223,SEQ2=246

  (Data statement 2, sequence number 00000224)

/*
//                                           <==== SHIFT THE DATA LEFT

The control statements are discussed below:

x) SYSUT1 DD defines the input partitioned data set DCB.PARTDS, which
   resides on a disk volume.

x) SYSUT2 DD defines the output sequential data set, SEQDS. The data
   set is written as the second data set on a tape volume.

x) SYSIN DD defines the control data set, which follows in the input
   stream.

x) CHANGE identifies the input member (OLDMEMB1) and indicates that the
   output is a sequential data set (NEW=PS).

x) The first data statement replaces the logical record whose sequence
   number is identical to the sequence number in the data statement
   (00000123). If no such logical record exists, the data statement is
   incorporated in the proper sequence within the output data set.

x) The DELETE detail statement deletes logical records having sequence
   numbers from 223 through 246, inclusive.

x) The second data statement is inserted in the proper sequence in the
   output data set, because no logical record with the sequence number
   224 exists (it was deleted in the previous statement).

   Note that only one member can be used as input when converting to
   sequential organization.

>< ADD NAME=UPDTE$06 0101-07003-07003-2113-00070-00070-00000-SC26UTL

Example 6: Create and Update a Library Member

In this example, a member of a partitioned data set is created from
sequential input and existing logical records are updated.

//UPDATEJOB ...
//STEP1   EXEC PGM=IEBUPDTE,PARM=MOD
//SYSPRINT DD  SYSOUT=*
//SYSUT1   DD  DISP=(OLD),DSN=BROWN.OLDSEQDS
//SYSUT2   DD  DISP=(NEW,CATLG),DSN=BROWN.NEWPART,
//             UNIT=disk,
//             SPACE=(TRK,(10,5,5)),
//             DCB=(RECFM=FB,BLKSIZE=0,LRECL=80)
//*                                          <==== SHIFT THE DATA LEFT
//SYSIN    DD  *
  ./       CHANGE NEW=PO,MEMBER=PARMEM1,LEVEL=01,
  ./       SEQFLD=605,COLUMN=40,SOURCE=0

  (Data statement 1, sequence number 00020)

  ./ DELETE SEQ1=220,SEQ2=250

  (Data statement 2, sequence number 00230)
  (Data statement 3, sequence number 00260)

  ./       ALIAS NAME=MEMB1
/*
//                                           <==== SHIFT THE DATA LEFT

The control statements are discussed below:

x) SYSUT1 DD defines the input sequential data set (BROWN.OLDSEQDS).
   The data set resides on a tape volume.

x) SYSUT2 DD defines the output partitioned data set (BROWN.NEWPART).
   Enough space is allocated to provide for members that may be added
   in the future.

x) SYSIN DD defines the control data set, which follows in the input
   stream.

x) The CHANGE function statement identifies the output member (PARMEM1)
   and indicates that a conversion from sequential input to partitioned
   output is made. The SEQFLD parameter indicates that a 5-byte
   sequence number is located in columns 60 through 64 of each data
   statement. The COLUMN=40 parameter specifies the starting column of
   a field (within subsequent data statements) from which replacement
   information is obtained. SOURCE=0 indicates that the replacement
   information is provided by you.

x) The first data statement is used as replacement data. Columns 40
   through 80 of the statement replace columns 40 through 80 of the
   corresponding logical record. If no such logical record exists, the
   entire card image is inserted in the output data set member.

x) The DELETE detail statement deletes all of the logical records
   having sequence numbers from 220 through 250.

x) The second data statement, whose sequence number falls within the
   range specified in the DELETE detail statement above, is
   incorporated in its entirety in the output data set member.

x) The third data statement, which is beyond the range of the DELETE
   detail statement, is treated in the same manner as the first data
   statement.

x) ALIAS assigns the alias name MEMB1 to the output data set member
   PARMEM1.

>< ADD NAME=UPDTE$07 0101-07003-07003-2113-00052-00052-00000-SC26UTL

Example 7: Insert Records into a Library Member

In this example, a block of three logical records is inserted into an
existing member, and the updated member is placed in the existing
partitioned data set.

//UPDATEJOB ...
//STEP1   EXEC PGM=IEBUPDTE,PARM=MOD
//SYSPRINT DD  SYSOUT=*
//SYSUT1   DD  DISP=(OLD),DSN=PDS
//SYSUT2   DD  DISP=(OLD),DSN=PDS
//*                                          <==== SHIFT THE DATA LEFT
//SYSIN    DD  *
  ./       CHANGE NAME=RENUM,LIST=ALL,LEVEL=01,SOURCE=0
  ./       NUMBER SEQ1=15,NEW1=20,INCR=5,INSERT=YES

  (Data statement 1)
  (Data statement 2)
  (Data statement 3)

/*
//                                           <==== SHIFT THE DATA LEFT

The control statements are discussed below:

x) SYSUT1 and SYSUT2 DD define the partitioned data set (PDS).

x) SYSIN DD defines the control data set, which follows in the input
   stream.

x) The CHANGE function statement identifies the input member RENUM. The
   entire member is listed in the message data set.

x) The NUMBER detail statement specifies the insert operation and
   controls the renumbering operation as described below.

x) The data statements are the logical records to be inserted.
   (Sequence numbers are assigned when the data statements are
   inserted.)

   In this example, the existing logical records have sequence numbers
   10, 15, 20, 25, and 30. Sequence numbers are assigned by the NUMBER
   detail statement, as follows:

   1. Data statement 1 is assigned sequence number 20 (NEW1=20) and
      inserted after existing logical record 15 (SEQ1=15).
   2. Data statements 2 and 3 are assigned sequence numbers 25 and 30
      (INCR=5) and are inserted after data statement 1.
   3. Existing logical records 20, 25, and 30 are assigned sequence
      numbers 35, 40, and 45, respectively.

>< ADD NAME=UPDTE$08 0101-07003-07003-2113-00080-00080-00000-SC26UTL

Example 8: Renumber and Insert Records into a Library Member

In this example, two blocks (three logical records per block) are
inserted into an existing member, and the member is placed in the
existing partitioned data set. A portion of the output member is also
renumbered.

//UPDATEJOB ...
//STEP1   EXEC PGM=IEBUPDTE,PARM=MOD
//SYSPRINT DD  SYSOUT=*
//SYSUT1   DD  DISP=(OLD),DSN=PDS
//SYSUT2   DD  DISP=(OLD),DSN=PDS
//*                                          <==== SHIFT THE DATA LEFT
//SYSIN    DD  *
  ./       CHANGE NAME=RENUM,LIST=ALL,LEVEL=01,SOURCE=0,SEQFLD=(765,783)
  ./       NUMBER SEQ1=AA015,NEW1=AA020,INCR=5,INSERT=YES

  (Data statement 1)
  (Data statement 2)
  (Data statement 3)

  ./       NUMBER SEQ1=AA030,INSERT=YES

  (Data statement 4)
  (Data statement 5)
  (Data statement 6)
  (Data statement 7, sequence number AA035)

/*
//                                           <==== SHIFT THE DATA LEFT

The control statements are discussed below:

x) SYSUT1 and SYSUT2 DD define the partitioned data set PDS.

x) SYSIN DD defines the control data set, which follows in the input
   stream.

x) The CHANGE function statement identifies the input member RENUM. The
   entire member is listed in the message data set.

x) The NUMBER detail statements specify the insert operations
   (INSERT=YES) and control the renumbering operation as described
   below.

x) Data statements 1, 2, 3, and 4, 5, 6 are the blocks of logical
   records to be inserted. Because they contain blank sequence numbers,
   sequence numbers are assigned when the data statements are inserted.

x) Data statement 7, because it contains a sequence number, stops the
   insert operation. The sequence number is identical to the number on
   the next record in the old master data set; consequently, data
   statement 7 will replace the equally numbered old master record in
   the output data set.

   The existing logical records in this example have sequence numbers
   AA010, AA015, AA020, AA025, AA030, AA035, AA040, AA045, AA050, BB010,
   and BB015. The insertion and renumbering operations are performed as
   follows:

   1. Data statement 1 is assigned sequence number AA020 (NEW1=AA020)
      and inserted after existing logical record AA015 (SEQ1=AA015).
   2. Data statements 2 and 3 are assigned sequence numbers AA025 and
      AA030 (INCR=5) and are inserted after data statement 1.
   3. Existing logical records AA020, AA025, and AA030 are assigned
      sequence numbers AA035, AA040, and AA045, respectively.
   4. Data statement 4 is assigned sequence number AA050 and inserted.
      (The SEQ1=AA030 specification in the second NUMBER statement
      places this data statement after existing logical record AA030,
      which has become logical record AA045.)
   5. Data statements 5 and 6 are assigned sequence numbers AA055 and
      AA060 and are inserted after data statement 4.
   6. Existing logical record AA035 is replaced by data statement 7,
      which is assigned sequence number AA065.
   7. The remaining logical records in the member are renumbered until
      logical record BB010 is encountered. Because this record has a
      sequence number higher than the next number to be assigned, the
      renumbering operation is ended.

>< ADD NAME=UPDTE$09 0101-07003-07003-2113-00058-00058-00000-SC26UTL

Example 9: Create a Sequential Data Set from Card Input

In this example, IEBUPDTE is used to create a sequential data set from
card input. User header and trailer labels, also from the input stream,
are placed on this sequential data set.

//LABEL JOB ...
//CREATION EXEC PGM=IEBUPDTE,PARM=NEW
//SYSPRINT DD  SYSOUT=*
//SYSUT2   DD  DISP=(NEW,CATLG),DSN=LABEL,
//             UNIT=disk,
//             SPACE=(TRK,(15,3))
//*                                          <==== SHIFT THE DATA LEFT
//SYSIN    DD  *
  ./       LABEL

  (Header labels)

  ./       ADD LIST=ALL,OUTHDR=ROUTINE1,OUTTLR=ROUTINE2

  (Data records)

  ./       LABEL

  (Trailer labels)

  ./ ENDUP
/*
//                                           <==== SHIFT THE DATA LEFT

The control statements are discussed below:

x) SYSUT2 DD defines and allocates space for the output sequential data
   set, called LABEL, which resides on a disk volume.

x) SYSIN DD defines the control data set, which follows in the input
   stream. (This control data set includes the sequential input data
   set and the user labels, which are on cards.)

x) The first LABEL statement identifies the 80-byte card images in the
   input stream which will become user header labels. (They can be
   modified by the user's header-label processing routine specified on
   the ADD function statement.)

x) The ADD function statement indicates that the data statements that
   follow are placed in the output data set. The newly created data set
   is listed in the message data set. User output header and output
   trailer routines are to be given control before the writing of header
   and trailer labels.

x) The second LABEL statement identifies the 80-byte card images in the
   input stream which will become user trailer labels. (They can be
   modified by the user's trailer-label processing routine specified on
   the ADD function statement.)

x) ENDUP signals the end of the control data set.

>< ADD NAME=UPDTE$10 0101-07003-07003-2113-00042-00042-00000-SC26UTL

Example 10: Copy Sequential Data Set from One Volume to Another

In this example, IEBUPDTE is used to copy a sequential data set from
one DASD volume to another. User labels are processed by user exit
routines.

//LABELS JOB ...
//STEP1   EXEC PGM=IEBUPDTE,PARM=(MOD,,INTLRTN)
//SYSPRINT DD  SYSOUT=*
//SYSUT1   DD  DISP=(OLD),DSN=OLDMAST
//SYSUT2   DD  DISP=(NEW,CATLG),DSN=NEWMAST,
//             UNIT=disk,
//             SPACE=(TRK,(5,10))
//SYSIN    DD  DISP=(SHR),DSN=INPUT


The control statements are discussed below:

x) SYSUT1 DD defines the input sequential data set, called OLDMAST,
   which resides on a disk volume.

x) SYSUT2 DD defines the output sequential data set, called NEWMAST,
   which will reside on a disk volume.

x) SYSIN DD defines the control data set. The contents of this
   disk-resident data set in this example are:

//*                                          <==== SHIFT THE DATA LEFT
  ./       REPRO LIST=ALL,INHDR=INHRTN,INTLR=INTRTN,                     C
  ./       OUTHDR=OUTHRTN,OUTTLR=OUTTRN
  ./       ENDUP
//                                           <==== SHIFT THE DATA LEFT

x) The REPRO function statement indicates that the existing input
   sequential data set is copied to the output data set. This output
   data set is listed on the message data set. The user's label
   processing routines are to be given control when header or trailer
   labels are encountered on either the input or the output data set.

x) ENDUP indicates the end of the control data set.

>< ADD NAME=UPDTE$11 0101-07003-07003-2113-00056-00056-00000-SC26UTL

Example 11: Create a New Partitioned Data Set

In this example, a partitioned generation data set consisting of three
members is used as source data in the creation of a new partitioned
data set. IEBUPDTE is also used to add a fourth member to the three
source members and to number the new member. The resultant data set is
cataloged as a new partitioned data set.

//NEWGDS JOB ...
//STEP1   EXEC PGM=IEBUPDTE,PARM=MOD
//SYSPRINT DD  SYSOUT=*
//SYSUT1   DD  DISP=(OLD),DSN=A.B.C
//SYSUT2   DD  DISP=(NEW,CATLG),DSN=A.B.D,
//             UNIT=disk,
//             SPACE=(TRK,(100,10,10)),
//             DCB=(RECFM=FB,BLKSIZE=0,LRECL=80)
//*                                          <==== SHIFT THE DATA LEFT
//SYSIN    DD  DATA
  ./       REPRO  NAME=MEM1,LEVEL=00,SOURCE=0,LIST=ALL
  ./       REPRO  NAME=MEM2,LEVEL=00,SOURCE=0,LIST=ALL
  ./       REPRO  NAME=MEM3,LEVEL=00,SOURCE=0,LIST=ALL
  ./       ADD    NAME=MEM4,LEVEL=00,SOURCE=0,LIST=ALL
  ./       NUMBER NEW1=10,INCR=5

  (Data records comprising MEM4)

  ./       ENDUP
/*
//                                           <==== SHIFT THE DATA LEFT

The control statements are discussed below:

x) SYSUT1 DD defines the partitioned data set, which is used as source
   data. It can be a PDSE.

x) SYSUT2 DD defines the new partitioned data set, which is created
   from the source partitioned data set and from an additional member
   included as input and data. It can be a PDSE.

x) SYSIN DD defines the control data set, which follows in the input
   stream.

x) The REPRO function statements reproduce the named source members in
   the output partitioned data set.

x) The ADD function statement specifies that the data records following
   the input stream be included as MEM4.

x) The NUMBER detail statement indicates that the new member is to have
   sequence numbers assigned in columns 73 through 80. The first record
   is assigned sequence number 10. The sequence number of each
   successive record is increased by 5.

x) ENDUP signals the end of input card data.

>< ADD NAME=UPDTE$12 0100-07003-07003-2113-00005-00005-00000-SC26UTL

//ERASE   EXEC PGM=IEBUPDTE
//DD1      DD  DISP=(OLD),UNIT=disk,VOL=SER=111111
//SYSPRINT DD  SYSOUT=*

>< ADD NAME=UPDTE$13 0100-07166-07166-1103-00016-00016-00000-KTOMIAK
//*
//* IEBUPDTE - Update Data Set
//*
//UPDTE01 EXEC PGM=IEBUPDTE,REGION=6M,PARM='MOD'
//SYSPRINT DD  SYSOUT=*
//*SYSUT1  DD  NOT USED WHEN PARM=NEW
//SYSUT1   DD  DISP=SHR,DSN=SOME.PDS.DSNAME
//SYSUT2   DD  DISP=OLD,DSN=SOME.PDS.DSNAME
//SYSIN    DD  *        <== Shift the data over to column 1
  ./ ADD NAME=KEN
  THIS IS MEMBER KEN, ALIAS TOMIAK
  ./ ALIAS NAME=TOMIAK
>< ENDUP
/*
//*
//
./ ADD NAME=IEFBR14  0666-07209-07209-1451-00001-00001-00000-DIR2UPDT
>< ADD NAME=BR14     0102-07016-07051-2314-00006-00008-00000-KTOMIAK

BR14$01   BR14 DOING NOTHING
BR14$02   BR14 ALLOCATING A NEW DATASET
BR14$03   DELETING A DATASET
BR14$04   MOD,DELETE BECAUSE YOU WEE TOO LAZY TO DELETE IT
BR14$05   CARRY ALONG A CANCEL COMMAND
BR14$06   BR14 ALLOCATING A NEW DATASET WITH LARGEST CONTIGUOUS AREA

>< ADD NAME=BR14$01  0100-07010-07010-2253-00004-00004-00000-KTOMIAK

//*
//BR14    EXEC PGM=IEFBR14,PARM='&ALLSYMBOLICS'

>< ADD NAME=BR14$02  0101-07010-07010-2256-00007-00016-00000-KTOMIAK

IEFBR14 has been used for years as a way to run a program that
should not abend. It allowed people to allocate new datasets,
conditionally managing a dataset, and even delete a dataset.

It makes more sense to me to allocate the new dataset
in the step you use it in. There you can code RLSE:
//     space=(typ,(pri,sec),RLSE)
which frees unused space when you close/free the data set.

//*
//BR14    EXEC PGM=IEFBR14
//OKUSE    DD  DISP=(NEW,CATLG),DSN=SOME.DSN,
//             UNIT=disk,SPACE=(TRK,(20,20))


>< ADD NAME=BR14$03  0100-07010-07010-2309-00020-00020-00000-KTOMIAK

IEFBR14 has been used for years as a way to run a program that
should not abend. It allowed people to allocate new datasets,
conditionally managing a dataset, and even delete a dataset.

//*
//STEP1   EXEC PGM=IEFBR14
//OKUSE    DD  DISP=(NEW,PASS),DSN=SHARE##.DSN,
//             UNIT=SYSDA,SPACE=(TRK,(10,0))
//*
//S1       IF (STEP1.RC = 0) THEN
//STEP2   EXEC PGM=IEFBR14
//OKUSE    DD  DISP=(OLD,DELETE),DSN=SHARE##.DSN,
//             UNIT=SYSDA,VOL=REF=*.STEP1.OKUSE
//        ELSE
//STEP3   EXEC PGM=IEFBR14
//OKUSE    DD  DISP=(OLD,CATLG),DSN=SHARE##.DSN,
//             UNIT=SYSDA,VOL=REF=*.STEP1.OKUSE
//        ENDIF
//
>< ADD NAME=BR14$04  0101-07010-07010-2254-00006-00019-00000-KTOMIAK

With the advent of System Managed Storage as a discipline in the 1980's
there came better and safer ways of managing datasets. Since there is
no good reason to use IEFBR14 to allocate a dataset with a
DISP=(MOD,DELETE) just to delete it if it did exist, you should go look
at the AMS* members for the better way.

Stop complaining about slow performance if you are using this method.
You are forcing the system to do I/O on a disk volume to allocate a
dataset and then turn around and do I/O to delete the dataset.
That is not efficient.

See the AMS# members for a cleaner way to delete a data set.

//*
//BR14    EXEC PGM=IEFBR14,PARM='&ALLSYMBOLICS'
//POORUSE  DD  DISP=(MOD,DELETE),DSN=SOME.DSN,
//             UNIT=disk,SPACE=(400,(20,20))

>< ADD NAME=BR14$05  0100-07021-07021-2308-00023-00023-00000-KTOMIAK

From time to time I end up running a rexx exec I amdeveloping and
it gets hung up where I can't cancel out of it. I keep a member in
my pds named cancelme that I can submit using ftp.

//jobname job (),'',....
//*
//        COMMAND 'C U=MYUSERID'
//*
//BR14    EXEC PGM=IEFBR14
//

From another system or your desktop:

ftp mainframe.hostname.or.ip.address
your_userid
your_password
quote set filetype=jes
put cancelme
quit

Of course if your installation does not allow you to submit commands
in this fashion then you call someone who can cancel you.
>< ADD NAME=BR14$06  0100-07051-07051-2318-00013-00013-00000-KTOMIAK

IEFBR14 has been used for years as a way to run a program that
should not abend. It allowed people to allocate new datasets,
conditionally managing a dataset, and even delete a dataset.

//*
//STEP1   EXEC PGM=IEFBR14
//HASPACE  DD  DISP=(NEW,KEEP),DSN=SYS1.HASPACE,
//             DSNTYPE=LARGE,                        <=== THE TRICK #1
//             UNIT=SYSALLDA,vol=ser=spool#,
//             SPACE=(CYL,1,,MXIG)                   <=== THE TRICK #2
//*

./ ADD NAME=IEHATLAS 0666-07209-07209-1450-00001-00001-00000-DIR2UPDT
>< ADD NAME=ATLAS    0100-07003-07003-2113-00004-00004-00000-SC26UTL

The IEHATLAS program is no longer distributed. Use Device Support
Facilities (ICKDSF) instead.

./ ADD NAME=IEHINITT 0666-07209-07209-1458-00001-00001-00000-DIR2UPDT
>< ADD NAME=INITT    0101-07003-07016-2346-00025-00025-00000-KTOMIAK

The EDGINERS utility of DFSMSrmm is recommended instead of IEHINITT for
labeling tapes that reside both inside and outside IBM TotalStorage
Enterprise Automated Tape Library (3495)s for the following reasons:

1. You can label a set of volumes with DFSMSrmm.
2. DFSMSrmm ensures that the data sets on the volume have expired.
3. DFSMSrmm validates that the correct volume is mounted before
   creating the volume label.
4. DFSMSrmm can track that a volume needs to be labelled and can
   automate tape labeling using the information in its control data set.
5. DFSMSrmm also provides facilities for erasing the data on a tape
   when it expires.
6. For more information about the EDGINERS utility, see z/OS DFSMSrmm
   Implementation and Customization Guide. Input and Output

INITT$01  Write EBCDIC Labels on Three Tapes
INITT$02  Write an ISO/ANSI Label on a Tape
INITT$03  Place Two Groups of Serial Numbers on Six Tape Volumes
INITT$04  Place Serial Number on Eight Tape Volumes
INITT$05  Write EBCDIC Labels in Different Densities
INITT$06  Write Serial Numbers on Tape Volumes at Two Densities
INITT$07  Write an ISO/ANSI Label with an Access Code
INITT$08  Write on a tape following labeling without demounting and

>< ADD NAME=INITT$01 0100-07003-07003-2113-00028-00028-00000-SC26UTL

Example 1: Write EBCDIC Labels on Three Tapes

In this example, serial numbers 001234, 001235 and 001236 are placed on
three tape volumes. The labels are written in EBCDIC at 800 bits per
inch. Each volume labeled is mounted, when it is required, on a single
9-track tape unit.

//LABEL1 JOB ...
//STEP1   EXEC PGM=IEHINITT
//SYSPRINT DD  SYSOUT=*
//LABEL    DD  UNIT=(tape,1,DEFER),
//             DCB=DEN=2
//SYSIN    DD  *
LABEL    INITT SER=001234,NUMBTAPE=3
/*


The control statements are discussed below:

x) LABEL DD defines the tape unit used in the labeling operation.

x) SYSIN DD defines the control data set, which follows in the input
   stream.

x) LABEL INITT specifies the number of tapes to be labeled (3),
   beginning with 001234.

>< ADD NAME=INITT$02 0100-07003-07003-2113-00029-00029-00000-SC26UTL

Example 2: Write an ISO/ANSI Label on a Tape

In this example, serial number 001001 is placed on one ISO/ANSI tape
volume; the label is written at 800 bits per inch. The volume labeled
is mounted, when it is required, on a 9-track tape unit.

//LABEL2 JOB ...
//STEP1   EXEC PGM=IEHINITT
//SYSPRINT DD  SYSOUT=*
//ASCIILAB DD  UNIT=(tape,1,DEFER),
//             DCB=DEN=2
//SYSIN    DD  *
ASCIILAB INITT SER=001001,OWNER='SAM A. BROWN',LABTYPE=AL
/*

The control statements are discussed below:

x) ASCIILAB DD defines the tape volume to be used in the labeling
   operation.

x) SYSIN DD defines the control data set, which follows in the input
   stream.

x) ASCIILAB INITT specifies the serial number, owner ID and label type
   for the volume.Because the VERSION keyword was not specified, the
   ISO/ANSI tape will be created based on what is specified in the
   DEVSUPxx parmlib member or as a version 3 by default.

>< ADD NAME=INITT$03 0100-07003-07003-2113-00028-00028-00000-SC26UTL

Example 3: Place Two Groups of Serial Numbers on Six Tape Volumes

In this example, two groups of serial numbers (001234, 001235, 001236,
and 001334, 001335, 001336) are placed on six tape volumes. The labels
are written in EBCDIC at 800 bits per inch. Each volume labeled is
mounted, when it is required, on a single 9-track tape unit.

//LABEL3 JOB ...
//STEP1   EXEC PGM=IEHINITT
//SYSPRINT DD  SYSOUT=*
//LABEL    DD  UNIT=(tape,1,DEFER),
//             DCB=DEN=2
//SYSIN    DD  *
LABEL    INITT SER=001234,NUMBTAPE=3
LABEL    INITT SER=001334,NUMBTAPE=3
/*

The control statements are discussed below:

x) LABEL DD defines the tape unit to be used in the labeling operation.

x) SYSIN DD defines the control data set, which follows in the input
   stream.

x) LABEL INITT defines the two groups of serial numbers to be put on
   six tape volumes.

>< ADD NAME=INITT$04 0100-07003-07003-2113-00034-00034-00000-SC26UTL

Example 4: Place Serial Number on Eight Tape Volumes

In this example, serial numbers 001234, 001244, 001254, 001264, 001274,
and so forth, are placed on eight tape volumes. The labels are written
in EBCDIC at 800 bits per inch. Each volume labeled is mounted, when it
is required, on one of four 9-track tape units.

//LABEL4 JOB ...
//STEP1   EXEC PGM=IEHINITT
//SYSPRINT DD  SYSOUT=*
//LABEL    DD  UNIT=(tape,4,DEFER),
//             DCB=DEN=2
//SYSIN    DD  *
LABEL    INITT SER=001234
LABEL    INITT SER=001244
LABEL    INITT SER=001254
LABEL    INITT SER=001264
LABEL    INITT SER=001274
LABEL    INITT SER=001284
LABEL    INITT SER=001294
LABEL    INITT SER=001304
/*

The control statements are discussed below:

x) LABEL DD defines the tape unit used in the labeling operation.

x) SYSIN DD defines the control data set, which follows in the input
   stream.

x) The LABEL INITT statements define the tapes to be labeled by volume
   serial number.

>< ADD NAME=INITT$05 0100-07003-07003-2113-00032-00032-00000-SC26UTL

Example 5: Write EBCDIC Labels in Different Densities

In this example, serial number TAPE1 is placed on a tape volume, and
serial numbers 001234 and 001235 are placed on two tape volumes. The
labels are written in EBCDIC at 800 and 1600 bits per inch,
respectively.

//LABEL5 JOB ...
//STEP1   EXEC PGM=IEHINITT
//SYSPRINT DD  SYSOUT=*
//LABEL1   DD  UNIT=(tape,1,DEFER),
//             DCB=DEN=2
//LABEL2   DD  UNIT=(tape,1,DEFER),
//             DCB=DEN=3
//SYSIN    DD  *
LABEL1    INITT SER=TAPE1
LABEL2    INITT SER=001234,NUMBTAPE=2
/*

The control statements are discussed below:

x) LABEL1 DD and LABEL2 DD  define two tape volumes to be used in the
   labeling operation.

x) SYSIN DD defines the control data set, which follows in the input
   stream.

x) LABEL1 INITT places the serial number TAPE1 on the tape volume
   defined in LABEL1 DD. LABEL2 INITT places the serial numbers 001234
   and 001235 on the tape volume defined in LABEL2 DD.

>< ADD NAME=INITT$06 0100-07003-07003-2113-00032-00032-00000-SC26UTL

Example 6: Write Serial Numbers on Tape Volumes at Two Densities

In this example, the serial number 006250 is written in EBCDIC on a tape
volume at a density of 6250 bpi, and the serial number 001600 is written
in EBCDIC on a second volume at a density of 1600 bpi.

//LABEL6 JOB ...
//STEP1   EXEC PGM=IEHINITT
//SYSPRINT DD  SYSOUT=*
//DDFIRST  DD  UNIT=(tape,1,DEFER),
//             DCB=DEN=4
//DDSECOND DD  UNIT=(tape,1,DEFER),
//             DCB=DEN=3
//SYSIN    DD  *
DDFIRST  INITT SER=006250
DDSECOND INITT SER=001600
/*

The control statements are discussed below:

x) DDFIRST DD defines the first tape volume to be used.

x) DDSECOND DD defines the second tape volume to be used.

x) SYSIN DD defines the control data set, which follows in the input
   stream.

x) DDFIRST INITT writes the serial number 006250 on the volume defined
   in DDFIRST DD. DDSECOND INITT writes the serial number 001600 on the
   volume defined in DDSECOND DD.

>< ADD NAME=INITT$07 0100-07003-07003-2113-00028-00028-00000-SC26UTL

Example 7: Write an ISO/ANSI Label with an Access Code

In this example, a version 4 ISO/ANSI (AL) labeled tape is created with
a nonblank access code. The volume serial number is TAPE01.

//LABEL7 JOB ...
//STEP1   EXEC PGM=IEHINITT
//SYSPRINT DD  SYSOUT=*
//LABEL    DD  UNIT=(tape,1,DEFER),
//             DCB=DEN=4
//SYSIN    DD  *
LABEL    INITT SER=TAPE01,OWNER=TAPOWNER,LABTYPE=AL,ACCESS=A,VERSION=4
/*

The control statements are discussed below:

x) LABEL DD defines the device on which the tape is mounted.

x) SYSIN DD defines the control data set, which follows in the input
   stream.

x) The INITT statement creates a Version 4 ISO/ANSI label for the tape
   with volume serial number TAPE01, owned by TAPOWNER. The ACCESS code
   is specified as "A", and the operating system that receives this
   volume must be able to recognize the "A" in order for the volume to
   be accepted.

>< ADD NAME=INITT$08 0100-07003-07003-2113-00028-00028-00000-SC26UTL

Example 8: Write on a tape following labeling without demounting and
remounting

In this example, you can label a tape in one step of a job, and then,
without the system demounting and remounting that tape between steps,
write to the tape in a subsequent step of the same job. The necessary
JCL code follows:

//STEP1  EXEC PGM=IEHINITT
//SYSPRINT DD  SYSOUT=*
//LABEL    DD  DISP=(,PASS),UNIT=(tape,1,DEFER)     (*1)
//SYSIN    DD  *
LABEL    INITT SER=serial,DISP=REWIND               (*2)
//*
//STEP2   EXEC PGM=user_program
//INPUT    DD  DSN=input_dsn,DISP=SHR
//OUTPUT   DD  DSN=dsname,DISP=(NEW,CATLG),
//             UNIT=tape,
//             VOL=(,RETAIN,SER=serial),            (*3)
//             DCB=(dcbinfo)

   Notes:
   (1) Either DISP=(NEW,PASS) or VOL=(,RETAIN) must be specified.
   (2) DISP=REWIND must be specified on the INITT statement.
   (3) VOL=SER=serial must be specified. VOL=REF=*.STEP1.LABEL will not
       work.

./ ADD NAME=IEHLIST  0666-07209-07209-1500-00001-00001-00000-DIR2UPDT
>< ADD NAME=LIST     0101-07003-07016-2348-00004-00004-00000-KTOMIAK

LIST$01  List Partitioned Directories Using DUMP and FORMAT
LIST$02  List Non-indexed Volume Table of Contents

>< ADD NAME=LIST$01  0100-07003-07003-2113-00039-00039-00000-SC26UTL

Example 1: List Partitioned Directories Using DUMP and FORMAT

In this example, the directory of a PDSE is listed. In addition, the
directories of two partitioned data sets that reside on the system
residence volume are listed.

//LISTPDIR JOB ...
//STEP1   EXEC PGM=IEHLIST
//SYSPRINT DD  SYSOUT=*
//DD1      DD  DISP=OLD,
//             UNIT=diskA,
//             VOL=SER=222222
//DD2      DD  DISP=OLD,
//             UNIT=diskB,
//             VOL=REF=SYS1.NUCLEUS
//SYSIN    DD  *
LISTPDS  DSNAME=D42.PDSE1,VOL=diskA=222222
LISTPDS  DSNAME=(D55.PART1,D55.PART2),FORMAT
/*

The control statements are discussed below:

x) DD1 DD defines the system residence device.

x) DD2 DD defines a device on which a disk volume (222222) is mounted.

x) SYSIN DD defines the control data set, which follows in the input
   stream.

x) The first LISTPDS statement indicates that the PDSE directory
   belonging to data set D42.PDSE1 is to be listed. The listing is in
   unedited (dump) format. This data set resides on volume 222222.

x) The second LISTPDS statement indicates that partitioned data set
   directories belonging to data sets D55.PART1 and D55.PART2 are to be
   listed. The listing is in edited format. These data sets exist on
   the system residence volume.

>< ADD NAME=LIST$02  0100-07003-07003-2113-00034-00034-00000-SC26UTL

Example 2: List Non-indexed Volume Table of Contents

In this example, a non-indexed volume table of contents is listed in
the first edited format. The edited listing is supplemented by an
unedited listing of selected data set control blocks.

//VTOCLIST JOB ...
//STEP1   EXEC PGM=IEHLIST
//SYSPRINT DD  SYSOUT=*
//DD2      DD  DISP=OLD,
//             UNIT=disk,
//             VOL=SER=111111
//SYSIN    DD  *
LISTVTOC FORMAT,VOL=disk=111111
LISTVTOC DUMP,VOL=disk=111111,DSNAME=(SET1,SET2,SET3)
/*

The control statements are discussed below:

x) DD2 DD defines a device containing the specified volume table of
   contents.

x) SYSIN DD defines the control data set, which follows in the input
   stream.

x) The first LISTVTOC statement indicates that the volume table of
   contents on the specified disk volume is to be listed in edited
   form.

x) The second LISTVTOC statement indicates that the data set control
   blocks representing data sets SET1, SET2, and SET3 are to be listed
   in unedited form.

./ ADD NAME=IEHMOVE  0666-07209-07209-1501-00001-00001-00000-DIR2UPDT
>< ADD NAME=MOVE     0101-07003-07016-2349-00028-00028-00000-KTOMIAK

The information given on IEHMOVE is provided for the sake of
compatibility only. DFSMSdss should be used instead of IEHMOVE to move
or copy data to volumes managed by the Storage Management Subsystem.
DFSMSdss or IEBCOPY should be used to process PDSEs. You cannot use
IEHMOVE with PDSEs or ISAM or VSAM data sets.


If you do use IEHMOVE to move or copy data sets to SMS-managed volumes,
you must preallocate all the target data sets. If the data set you are
copying or moving is cataloged, and you are moving or copying it to an
SMS-managed volume, you must rename the data set.


See z/OS DFSMS: Using Data Sets for more information on allocating
SMS-managed data sets and z/OS DFSMS Access Method Services for
information on the ALLOCATE command.

MOVE$01  Move Sequential Data Sets from Disk Volume to Separate
         Volumes
MOVE$02  Move Partitioned Data Set to Disk Volume and Merge
MOVE$03  Move Volume of Data Sets to Disk Volume
MOVE$04  Move Partitioned Data Set to Allocated Space
MOVE$05  Move and Unload Partitioned Data Sets Volume
MOVE$06  Unload Sequential Data Set onto Unlabeled Tape Volume
MOVE$07  Load Unloaded Sequential Data Sets from Labeled Tape
MOVE$08  Move Cataloged Data Set Group

>< ADD NAME=MOVE$01  0100-07003-07003-2113-00051-00051-00000-SC26UTL

DFSMSdss should be used instead of IEHMOVE to move or copy data to
volumes managed by the Storage Management Subsystem. DFSMSdss or
IEBCOPY should be used to process PDSEs. You cannot use IEHMOVE with
PDSEs or ISAM or VSAM data sets.

Example 1: Move Sequential Data Sets from Disk Volume to Separate
Volumes

In this example, three sequential data sets (SEQSET1, SEQSET2, and
SEQSET3) are moved from a disk volume to three separate disk volumes.
Each of the three receiving volumes is mounted when it is required by
IEHMOVE. The source data sets are not cataloged. Space is allocated by
IEHMOVE.

//MOVEDS JOB ...
//STEP1   EXEC PGM=IEHMOVE
//SYSPRINT DD  SYSOUT=*
//SYSUT1   DD  DISP=(OLD),UNIT=disk,VOL=SER=333333
//DD1      DD  DISP=(OLD),UNIT=(disk,,DEFER),
//             VOL=(PRIVATE,,SER=(222222))
//DD2      DD  DISP=(OLD),UNIT=(disk,,DEFER),
//             VOL=(PRIVATE,,SER=(222333))
//DD3      DD  DISP=(OLD),UNIT=(disk,,DEFER),
//             VOL=(PRIVATE,,SER=(222444))
//DD4      DD  DISP=(OLD),UNIT=(disk,,DEFER),
//             VOL=(PRIVATE,RETAIN,SER=(444444))
//SYSIN    DD  *
MOVE     DSNAME=SEQSET1,TO=disk=222222,FROM=disk=444444
MOVE     DSNAME=SEQSET2,TO=disk=222333,FROM=disk=444444
MOVE     DSNAME=SEQSET3,TO=disk=222444,FROM=disk=444444

/*

The control statements are discussed below:

x) SYSUT1 DD defines the disk device that is to contain the work data
set.

x) DD1, DD2, and DD3 DD define the receiving volumes.

x) DD4 DD defines a device on which the source volume is mounted.
   Because the RETAIN subparameter is included, the volume remains
   mounted until the job has completed.

x) SYSIN DD defines the control data set, which follows in the input
   stream.

x) MOVE moves the source data sets to volumes 222222, 222333, and
   222444, respectively. The source data sets are scratched.

>< ADD NAME=MOVE$02  0100-07003-07003-2113-00046-00046-00000-SC26UTL

DFSMSdss should be used instead of IEHMOVE to move or copy data to
volumes managed by the Storage Management Subsystem. DFSMSdss or
IEBCOPY should be used to process PDSEs. You cannot use IEHMOVE with
PDSEs or ISAM or VSAM data sets.

Example 2: Move Partitioned Data Set to Disk Volume and Merge

In this example, a partitioned data set (PARTSET1) is moved to a disk
volume. In addition, a member (PARMEM3) from another partitioned data
set (PARTSET2) is merged with the source members on the receiving
volume. The source partitioned data set (PARTSET1) is scratched. Space
is allocated by IEHMOVE.

//MOVEPDS JOB ...
//STEP1   EXEC PGM=IEHMOVE
//SYSPRINT DD  SYSOUT=*
//SYSUT1   DD  DISP=(OLD),UNIT=disk,VOL=SER=333000
//DD1      DD  DISP=(OLD),UNIT=disk,VOL=SER=111111
//DD2      DD  DISP=(OLD),UNIT=disk,VOL=SER=222111
//DD3      DD  DISP=(OLD),UNIT=disk,VOL=SER=222222
//DD4      DD  DISP=(OLD),UNIT=disk,VOL=SER=222333
//SYSIN    DD  *
         MOVE    PDS=PARTSET1,TO=disk=222333,FROM=disk=222111
         INCLUDE DSNAME=PARTSET2,MEMBER=PARMEM3,FROM=disk=222222
/*

The control statements are discussed below:

x) SYSUT1 DD defines the disk volume that is to contain the work data
   set.

x) DD1 DD defines the system residence device.

x) The DD2, DD3, and DD4 DD statements define devices that are to
   contain the two source volumes and the receiving volume.

x) SYSIN DD defines the control data set, which follows in the input
   stream.

x) MOVE defines the source partitioned data set, the volume that
   contains it, and its receiving volume.

x) INCLUDE includes a member from a second partitioned data set in the
   operation.

>< ADD NAME=MOVE$03  0100-07003-07003-2113-00044-00044-00000-SC26UTL

DFSMSdss should be used instead of IEHMOVE to move or copy data to
volumes managed by the Storage Management Subsystem. DFSMSdss or
IEBCOPY should be used to process PDSEs. You cannot use IEHMOVE with
PDSEs or ISAM or VSAM data sets.

A SECURITY PACKAGE IS A BETTER WAY TO PROTECT ACCESS THAN PASSWORDS.

Example 3: Move Volume of Data Sets to Disk Volume

In this example, a volume of data sets is moved to a disk volume. All
data sets that are successfully moved are scratched from the source
volume; however, any catalog entries pertaining to those data sets are
not changed. Space is allocated by IEHMOVE.

//MOVEVOL JOB ...
//STEP1   EXEC PGM=IEHMOVE
//SYSPRINT DD  SYSOUT=*
//SYSUT1   DD  DISP=(OLD),UNIT=disk,VOL=SER=222222
//DD1      DD  DISP=(OLD),UNIT=disk,VOL=SER=111111
//DD2      DD  DISP=(OLD),UNIT=disk,VOL=SER=222222
//DD3      DD  DISP=(OLD),UNIT=disk,VOL=SER=333333
//SYSIN    DD  *
         MOVE     VOLUME=disk=333333,TO=disk=222222,PASSWORD
/*

The control statements are discussed below:

x) SYSUT1 DD defines the device that is to contain the work data set.

x) DD1 DD defines the system residence device.

x) DD2 DD defines the device on which the receiving volume is mounted.

x) DD3 DD defines a device on which the source volume is mounted.

x) SYSIN DD defines the control data set, which follows in the input
   stream.

x) MOVE specifies a move operation for a volume of data sets and
   defines the source and receiving volumes. This statement also
   indicates that password-protected data sets are included in the
   operation.

>< ADD NAME=MOVE$04  0100-07003-07003-2113-00040-00040-00000-SC26UTL

DFSMSdss should be used instead of IEHMOVE to move or copy data to
volumes managed by the Storage Management Subsystem. DFSMSdss or
IEBCOPY should be used to process PDSEs. You cannot use IEHMOVE with
PDSEs or ISAM or VSAM data sets.

Example 4: Move Partitioned Data Set to Allocated Space

In this example, a partitioned data set is moved to a disk volume on
which space has been previously allocated for the data set. The source
data set is scratched.

//MOVEPDS JOB ...
//STEP1   EXEC PGM=IEHMOVE
//SYSPRINT DD  SYSOUT=*
//SYSUT1   DD  DISP=(OLD),UNIT=disk,VOL=SER=222222
//DD1      DD  DISP=(OLD),UNIT=disk,VOL=SER=111111
//DD2      DD  DISP=(OLD),UNIT=disk,VOL=SER=222222
//DD3      DD  DISP=(OLD),UNIT=disk,VOL=SER=333333
//SYSIN    DD  *
         MOVE PDS=PDSSET1,TO=disk=222222,FROM=disk=333333
/*

The control statements are discussed below:

x) SYSUT1 DD defines the device that is to contain the work data set.

x) DD1 DD defines the system residence device.

x) DD2 DD defines the device on which the receiving volume is to be
   mounted.

x) DD3 DD defines a device on which the source volume is mounted.

x) SYSIN DD defines the control data set, which follows in the input
   stream.

x) MOVE specifies a move operation for the partitioned data set PDSSET1
   and defines the source and receiving volumes.

>< ADD NAME=MOVE$05  0100-07003-07003-2113-00062-00062-00000-SC26UTL

DFSMSdss should be used instead of IEHMOVE to move or copy data to
volumes managed by the Storage Management Subsystem. DFSMSdss or
IEBCOPY should be used to process PDSEs. You cannot use IEHMOVE with
PDSEs or ISAM or VSAM data sets.

Example 5: Move and Unload Partitioned Data Sets Volume

In this example, three partitioned data sets are moved from three
separate source volumes to a disk volume. The source data set PDSSET3
is unloaded. (The record size exceeds the track capacity of the
receiving volume.)

//MOVEPDS JOB ...
//STEP1   EXEC PGM=IEHMOVE
//SYSPRINT DD  SYSOUT=*
//SYSUT1   DD  DISP=(OLD),UNIT=disk,VOL=SER=222222
//DD1      DD  DISP=(OLD),UNIT=disk,VOL=SER=111111
//DD2      DD  DISP=(OLD),UNIT=(disk,,DEFER)
//             VOL=(PRIVATE,,SER=(333333))
//DD3      DD  DISP=(OLD),UNIT=disk,VOL=SER=222222
//SYSIN    DD  *
         MOVE PDS=PDSSET1,TO=disk=222222,FROM=disk=333333
         MOVE PDS=PDSSET2,TO=disk=222222,FROM=disk=222222
         MOVE PDS=PDSSET3,TO=disk=222222,FROM=disk=444444,UNLOAD
/*

NOTE:

   PDSSET1, PDSSET2, and PDSSET3 are already allocated on the receiving
   volume. PDSSET3 is allocated as a sequential data set; PDSSET1 and
   PDSSET2 are allocated as partitioned data sets. Since PDSSET3 is
   moved to a sequential data set, it is unloaded.

   For a discussion of estimating space allocations, see
   z/OS DFSMS: Using Data Sets.

   The DCB attributes of PDSSET3 are:

   DCB=(RECFM=U,BLKSIZE=5000)

   The unloaded attributes are:

   DCB=(RECFM=FB,LRECL=80,BLKSIZE=800)

The control statements are discussed below:

x) SYSUT1 DD defines the device that is to contain the work data set.

x) DD1 DD defines the system residence device.

x) DD2 DD defines a device on which the source volumes are mounted as
   they are required.

x) DD3 DD defines a device on which the receiving volume is mounted.

x) SYSIN DD defines the control data set, which follows in the input
   stream.

x) MOVE specifies move operations for the partitioned data sets and
   defines the source and receiving volumes for each data set.

>< ADD NAME=MOVE$06  0100-07003-07003-2113-00045-00045-00000-SC26UTL

DFSMSdss should be used instead of IEHMOVE to move or copy data to
volumes managed by the Storage Management Subsystem. DFSMSdss or
IEBCOPY should be used to process PDSEs. You cannot use IEHMOVE with
PDSEs or ISAM or VSAM data sets.

Example 6: Unload Sequential Data Set onto Unlabeled Tape Volume

In this example, a sequential data set is unloaded onto a 9-track,
unlabeled tape volume (800 bits per inch).

//UNLOAD JOB ...
//STEP1   EXEC PGM=IEHMOVE
//SYSPRINT DD  SYSOUT=*
//SYSUT1   DD  DISP=(OLD),UNIT=disk,VOL=SER=222222
//DD1      DD  DISP=(OLD),UNIT=disk,VOL=SER=111111
//DD2      DD  DISP=(OLD),UNIT=disk,VOL=SER=222222
//TAPEOUT  DD  DISP=(NEW,CATLG),DSN=NEW.TAPE,
//             UNIT=tape,
//             VOL=SER=SCRCH2,
//             DCB=(RECFM=FB,BLKSIZE=0,LRECL=80)
//SYSIN    DD  *
         MOVE  DSNAME=SEQSET1,TO=tape=SCRCH2,FROM=disk=222222,         X
               TODD=TAPEOUT
/*

The control statements are discussed below:

x) SYSUT1 DD defines the device that is to contain the work data set.

x) DD1 DD defines the system residence device.

x) DD2 DD defines a device on which the source volume is mounted.

x) TAPEOUT DD defines a device on which the receiving tape volume is
   mounted. This statement also provides label and mode information.

x) SYSIN DD defines the control data set, which follows in the input
   stream.

x) MOVE moves the sequential data set SEQSET1 from a disk volume to the
   receiving tape volume. The data set is unloaded. The TODD parameter
   in this statement refers to the TAPEOUT DD statement for label and
   mode information.

>< ADD NAME=MOVE$07  0100-07003-07003-2113-00052-00052-00000-SC26UTL

DFSMSdss should be used instead of IEHMOVE to move or copy data to
volumes managed by the Storage Management Subsystem. DFSMSdss or
IEBCOPY should be used to process PDSEs. You cannot use IEHMOVE with
PDSEs or ISAM or VSAM data sets.

Example 7: Load Unloaded Sequential Data Sets from Labeled Tape

In this example, three unloaded sequential data sets are loaded from a
labeled, 7-track tape volume (556 bits per inch) to a disk volume.
Space is allocated by IEHMOVE. The example assumes that the disk volume
is capable of supporting the data sets in their original forms.

//LOAD JOB ...
//STEP1   EXEC PGM=IEHMOVE
//SYSPRINT DD  SYSOUT=*
//SYSUT1   DD  DISP=(OLD),UNIT=disk,VOL=SER=222222
//DD1      DD  DISP=(OLD),UNIT=disk,VOL=SER=111111
//DD2      DD  DISP=(OLD),UNIT=disk,VOL=SER=222222
//TAPESETS DD  DISP=(OLD),
//             UNIT=tape,LABEL=(1,SL),
//             VOL=SER=001234,
//             DCB=(DEN=1,TRTCH=C)
//SYSIN    DD  *
         MOVE DSNAME=UNLDSET1,T0=disk=222222,                          X
               FROM=tape=(001234,1),FROMDD=TAPESETS
         MOVE DSNAME=UNLDSET2,TO=disk=222222,                          X
               FROM=tape=(001234,2),FROMDD=TAPESETS
         MOVE DSNAME=UNLDSET3,TO=disk=222222,                          X
               FROM=tape=(001234,3),FROMDD=TAPESETS
/*

The control statements are discussed below:

x) SYSUT1 DD defines the device that is to contain the work data set.

x) DD1 DD defines the system residence device.

x) DD2 DD defines a device on which the receiving volume is mounted.

x) TAPESETS DD defines a device on which the source tape volume is
   mounted. DCB information is provided in this statement.

x) SYSIN DD defines the control data set, which follows in the input
   stream.

x) MOVE moves the unloaded data sets to the receiving volume.

To move a data set from a tape volume that contains more than one data
set, you must specify the sequence number of the data set in the list
field of the FROM parameter on the utility control statement.

>< ADD NAME=MOVE$08  0100-07003-07003-2113-00057-00057-00000-SC26UTL

DFSMSdss should be used instead of IEHMOVE to move or copy data to
volumes managed by the Storage Management Subsystem. DFSMSdss or
IEBCOPY should be used to process PDSEs. You cannot use IEHMOVE with
PDSEs or ISAM or VSAM data sets.

Example 8: Move Cataloged Data Set Group

In this example, the cataloged data set group A.B.C, which comprises
data set A.B.C.X, A.B.C.Y, and A.B.C.Z, ,is moved from two disk volumes
onto a third volume. Space is allocated by IEHMOVE. The catalog is
updated to refer to the receiving volume. The source data sets are
scratched.

//MOVEDSG JOB ...
//STEP1   EXEC PGM=IEHMOVE
//SYSPRINT DD  SYSOUT=*
//SYSUT1   DD  DISP=(OLD),UNIT=disk,VOL=SER=222222
//DD1      DD  DISP=(OLD),UNIT=disk,VOL=SER=111111
//DD2      DD  DISP=(OLD),UNIT=disk,VOL=SER=222222
//DD3      DD  DISP=(OLD),UNIT=disk,VOL=SER=333333
//DD4      DD  DISP=(OLD),UNIT=disk,VOL=SER=444444
//SYSIN    DD  *
         MOVE DSGROUP=A.B.C,TO=disk=222222
/*

The control statements are discussed below:

x) SYSUT1 DD defines the device that is to contain the work data set.

x) DD1 DD defines the system residence device.

x) DD2 DD defines a device on which the receiving volume is mounted.

x) DD3 DD defines a device on which one of the source volumes is
   mounted.

x) DD4 DD defines a device on which one of the source volumes is
   mounted.

x) SYSIN DD defines the control data set, which follows in the input
   stream.

x) MOVE moves the specified data sets to volume 222222.

This example can be used to produce the same result without the use of
the DD4 DD statement, using one less mountable disk device. With DD3
and DD4, both of the source volumes are mounted at the start of the
job. With DD3 only, the 333333 volume is mounted at the start of the
job. After the 333333 volume is processed, the utility requests that
the operator mount the 444444 volume. In this case, the DD3 statement
is coded:


//DD3      DD  DISP=(OLD),UNIT=(disk,,DEFER),
//             VOL=(PRIVATE,,SER=(333333))

./ ADD NAME=IEHPROGM 0666-07209-07209-1502-00001-00001-00000-DIR2UPDT
>< ADD NAME=PROGM    0101-07003-07016-2349-00044-00044-00000-KTOMIAK

Yes, it still works but more people create a mess than fix one.
Which is probably why you are looking to use this. Stop digging
yourself into a deeper hole and find a better way.


IEHPROGM is a system utility that is used to modify system control data
and to maintain data sets at an organizational level. IEHPROGM should
only be used by those programmers who are locally authorized to do so.

IEHPROGM does not support dynamic UCBs while processing data sets that
are password-protected.

You can use IEHPROGM to perform the following tasks:

x) Scratch (delete) a data set or a member of a partitioned data set.
x) Rename a data set or a member of a partitioned data set.
x) Maintain data set passwords.

   A SECURITY PACKAGE IS A BETTER WAY TO PROTECT ACCESS THAN PASSWORDS.


You must have RACF authority in order to use IEHPROGM. For information
on RACF requirements for the Storage Management Subsystem, see z/OS
DFSMSdfp Storage Administration Reference.


IDCAMS is recommended for use with SMS managed data sets. For
information on IDCAMS, see z/OS DFSMS Access Method Services.


You can write an assembler program to perform any of the IEHPROGM
functions. See z/OS DFSMSdfp Advanced Services and z/OS DFSMS: Using
Data Sets.


PROGM$01  Scratch Temporary System Data Sets
PROGM$02  Scratch and Uncatalog Two Data Sets
PROGM$03  Rename a Multi-Volume Data Set Catalog
PROGM$04  Uncatalog Three Data Sets
PROGM$05  Rename a Data Set and Define New Passwords
PROGM$06  List and Replace Password Information
PROGM$07  Rename a Partitioned Data Set Member

>< ADD NAME=PROGM$01 0100-07003-07003-2113-00026-00026-00000-SC26UTL

IDCAMS is recommended for use with SMS managed data sets. For
information on IDCAMS, see z/OS DFSMS Access Method Services.

Example 1: Scratch Temporary System Data Sets

In this example, all temporary system data sets are scratched from the
volume table of contents.

//SCRVTOC JOB ...
//STEP1   EXEC PGM=IEHPROGM
//SYSPRINT DD  SYSOUT=*
//DD2      DD  DISP=(OLD),UNIT=disk,VOL=SER=222222
//SYSIN    DD  *
         SCRATCH VTOC,VOL=disk=222222,SYS
/*

The control statements are discussed below:

x) The DD2 statement defines a volume. Because the system residence
   volume is not referred to, a DD statement is needed to define it.

x) The SCRATCH statement, with SYS specified, indicates that all
   temporary system data sets whose expiration dates have expired are
   scratched from the specified volume.

>< ADD NAME=PROGM$02 0100-07003-07003-2113-00034-00034-00000-SC26UTL

IDCAMS is recommended for use with SMS managed data sets. For
information on IDCAMS, see z/OS DFSMS Access Method Services.

Example 2: Scratch and Uncatalog Two Data Sets

In this example, two data sets are scratched: SET1 and A.B.C.D.E are
scratched from volume 222222. Both data sets are uncataloged.

//SCRDSETS JOB ...
//STEP1   EXEC PGM=IEHPROGM
//SYSPRINT DD  SYSOUT=*
//DD1 DD  DISP=(OLD),UNIT=disk,VOL=SER=111111
//DD2 DD  DISP=(OLD),UNIT=disk,VOL=SER=222222
//SYSIN DD  *
         SCRATCH DSNAME=SET1,VOL=disk=222222
         UNCATLG DSNAME=SET1
         SCRATCH DSNAME=A.B.C.D.E,VOL=disk=222222
         UNCATLG DSNAME=A.B.C.D.E
/*

The utility control statements are discussed below:

x) The first SCRATCH statement specifies that SET1, which resides on
   volume 222222, is scratched.

x) The first UNCATLG statement specifies that SET1 is uncataloged.

x) The second SCRATCH statement specifies that A.B.C.D.E, which resides
   on volume 222222, is scratched.

x) The second UNCATLG statement specifies that A.B.C.D.E is
   uncataloged.

>< ADD NAME=PROGM$03 0100-07003-07003-2113-00032-00032-00000-SC26UTL

IDCAMS is recommended for use with SMS managed data sets. For
information on IDCAMS, see z/OS DFSMS Access Method Services.

Example 3: Rename a Multi-Volume Data Set Catalog

In this example, the name of a data set is changed on two mountable
volumes. The old data set name is removed and the data set is cataloged
under its new data set name.

//RENAMEDS JOB ...
//STEP1   EXEC PGM=IEHPROGM
//SYSPRINT DD  SYSOUT=*
//DD1      DD  VOL=SER=111111,DISP=(OLD),UNIT=disk
//DD2      DD  DISP=(OLD),UNIT=(disk,,DEFER),
//             VOL=(PRIVATE,SER=(222222,333333))
//SYSIN    DD  *
         RENAME  DSNAME=A.B.C,NEWNAME=NEWSET,VOL=disk=(222222,333333)
         UNCATLG DSNAME=A.B.C
         CATLG   DSNAME=NEWSET,VOL=disk=(222222,333333)
/*

The control statements are discussed below:

x) RENAME specifies that data set A.B.C, which resides on volumes
   222222 and 333333, is to be renamed NEWSET.

x) UNCATLG specifies that data set A.B.C is uncataloged.

x) CATLG specifies that NEWSET, which resides on volumes 222222 and
   333333, is cataloged.

>< ADD NAME=PROGM$04 0100-07003-07003-2113-00024-00024-00000-SC26UTL

IDCAMS is recommended for use with SMS managed data sets. For
information on IDCAMS, see z/OS DFSMS Access Method Services.

Example 4: Uncatalog Three Data Sets

In this example, three data sets, A.B.C.D.E.F.SET1, A.B.C.G.H.SET2, and
A.B.I.J.K.SET3, are uncataloged.

//DLTSTRUC JOB ...
//STEP1   EXEC PGM=IEHPROGM
//SYSPRINT DD  SYSOUT=*
//DD1      DD  DISP=(OLD),UNIT=disk,VOL=SER=111111
//SYSIN    DD  *
         UNCATLG DSNAME=A.B.C.D.E.F.SET1
         UNCATLG DSNAME=A.B.C.G.H.SET2
         UNCATLG DSNAME=A.B.I.J.K.SET3
/*

The control statements are discussed below:

x) The UNCATLG statements specify that data sets A.B.C.D.E.F.SET1,
   A.B.C.G.H.SET2, and A.B.I.J.K.SET3 are uncataloged.

>< ADD NAME=PROGM$05 0100-07003-07003-2113-00047-00047-00000-SC26UTL

IDCAMS is recommended for use with SMS managed data sets. For
information on IDCAMS, see z/OS DFSMS Access Method Services.

A SECURITY PACKAGE IS A BETTER WAY TO PROTECT ACCESS THAN PASSWORDS.

Example 5: Rename a Data Set and Define New Passwords

In this example, a data set is renamed. The data set passwords assigned
to the old data set name are deleted. Then two passwords are assigned
to the new data set name. If the data set is not cataloged, a message
is issued indicating that the LOCATE macro instruction ended
unsuccessfully.

//ADDPASS JOB ...
//STEP1   EXEC PGM=IEHPROGM,PARM='NOPRINT'
//SYSPRINT DD  SYSOUT=*
//DD1      DD  DISP=(OLD),UNIT=disk,VOL=SER=222222
//SYSIN    DD  *
         RENAME  DSNAME=OLD,VOL=disk=222222,NEWNAME=NEW
         DELETEP DSNAME=OLD,PASWORD1=KEY
         ADD     DSNAME=NEW,PASWORD2=KEY,TYPE=1,                       X
               DATA='SECONDARY IS READ'
         ADD     DSNAME=NEW,PASWORD2=READ,CPASWORD=KEY,TYPE=2,         X
               DATA='ASSIGNED TO J. DOE'
/*

The utility control statements are discussed below:

x) RENAME specifies that the data set called OLD is renamed NEW. The
   operator is required to supply a password to rename the old data set.

x) DELETEP specifies that the entry for the password KEY is deleted.
   Because KEY is a control password in this example, all the password
   entries for the data set name are deleted. The VOL parameter is not
   needed because the protection status of the data set as set in the
   DSCB is not to be changed; read/write protection is presently set in
   the DSCB, and read/write protection is desired when the passwords are
   reassigned under the new data set name.

x) The ADD statements specify that entries are added for passwords KEY
   and READ. KEY becomes the control password and allows both read and
   write access to the data set. READ becomes a secondary password and
   allows only read access to the data set. The VOL parameter is not
   needed, because the protection status of the data set is still set in
   the DSCB.

>< ADD NAME=PROGM$06 0100-07003-07003-2113-00040-00040-00000-SC26UTL

IDCAMS is recommended for use with SMS managed data sets. For
information on IDCAMS, see z/OS DFSMS Access Method Services.

A SECURITY PACKAGE IS A BETTER WAY TO PROTECT ACCESS THAN PASSWORDS.

Example 6: List and Replace Password Information

In this example, information from a password entry is listed. Then the
protection mode of the password, the protection status of the data set,
and the user data are changed.

//REPLPASS JOB ...
//STEP1   EXEC PGM=IEHPROGM,PARM='NOPRINT'
//SYSPRINT DD  SYSOUT=*
//DD1      DD  DISP=(OLD),UNIT=disk,VOL=SER=111111
//DD2      DD  DISP=(OLD),UNIT=(disk,,DEFER)
//             VOL=(PRIVATE,SER=(222222,333333))
//SYSIN    DD  *
         LIST    DSNAME=A.B.C,PASWORD1=ABLE
         REPLACE DSNAME=A.B.C,PASWORD1=ABLE,PASWORD2=ABLE,TYPE=3,      X
               VOL=disk=(222222,333333),                               X
               DATA='NO SECONDARIES; ASSIGNED TO DEPT 31'
/*

The utility control statements are discussed below:

x) LIST specifies that the access counter, protection mode, and user
   data from the entry for password ABLE are listed. Listing the entry
   permits the content of the access counter to be recorded before the
   counter is reset to zero by the REPLACE statement.

x) REPLACE specifies that the protection mode of password ABLE is to be
   changed to allow both read and write access and that the protection
   status of the data set is changed to write-only protection. The VOL
   parameter is required because the protection status of the data set
   is changed and the data set, in this example, is not cataloged.
   Because this is a control password, the CPASWORD parameter is not
   required.

>< ADD NAME=PROGM$07 0100-07003-07003-2113-00026-00026-00000-SC26UTL

IDCAMS is recommended for use with SMS managed data sets. For
information on IDCAMS, see z/OS DFSMS Access Method Services.

Example 7: Rename a Partitioned Data Set Member

In this example, a member of a partitioned data set is renamed.

//REN JOB ...
//STEP1   EXEC PGM=IEHPROGM
//SYSPRINT DD  SYSOUT=*
//DD1      DD  DISP=(OLD),UNIT=disk,VOL=SER=222222
//SYSIN    DD  *
         RENAME VOL=disk=222222,DSNAME=DATASET,NEWNAME=BC,MEMBER=ABC
/*

The control statements are discussed below:

x) DD1 DD defines a permanently mounted volume.

x) SYSIN DD defines the input data set, which follows in the input
   stream.

x) RENAME specifies that member ABC in the partitioned data set
   DATASET, which resides on a disk volume, is renamed BC.

./ ADD NAME=IEWBLINK 0666-07209-07209-1459-00001-00001-00000-DIR2UPDT
>< ADD NAME=LINK     0101-07007-07016-2348-00005-00005-00000-KTOMIAK

LINK$01   Link from passed input
LINK$02   Link from object library
LINK$03   ReLink from load library

>< ADD NAME=LINK$01  0100-07007-07007-0031-00017-00017-00000-KTOMIAK
//LINKOBJ PROC                                                          00010000
//L       EXEC PGM=HEWL,PARM='MAP,LET,LIST,NCAL'                        00020000
//SYSLIN   DD  DSN=&&OBJ,DISP=(OLD,DELETE)                              00030000
//         DD  DDNAME=SYSIN                                             00040000
//SYSLMOD  DD  DISP=(,PASS),UNIT=SYSALLDA,SPACE=(CYL,(1,1,1)),          00050000
//             DSN=&&GOSET(GO)                                          00060000
//SYSUT1   DD  DSN=&&SYSUT1,SPACE=(1024,(120,120),,,ROUND),             00070000
//             UNIT=SYSALLDA,DCB=BUFNO=1                                00080000
//SYSPRINT DD  SYSOUT=*                                                 00090000
//LINKOBJ PEND                                                          00100000
//*                                                                     00110000
//STEP001 EXEC PROC=LINKOBJ                                             00120000
//SYSIN    DD  *                                                        00130000
 NAME  PDSUPDTE(R)                                                      00140000
/*                                                                      00150000
//SYSLMOD  DD  DISP=SHR,DSN=SHARE##.SHR.LOADLIB                         00160000
//                                                                      00170000
>< ADD NAME=LINK$02  0100-07007-07007-0026-00012-00012-00000-KTOMIAK
//*
//RELINK  EXEC PGM=IEWBLINK,REGION=1024K,
//             PARM='NCAL,LET,LIST,MAP'    ,AMODE=31,RMODE=ANY'
//LOADLIB  DD  DISP=SHR,DSN=SHARE##.SHR.LOADLIB
//SYSLIN   DD  *
 INCLUDE LOADLIB(PDSUPDTE)
 ENTRY PDSUPDTE
 NAME  PDSUPDTE(R)
/*
//SYSLMOD  DD  DISP=SHR,DSN=SHARE##.SHR.LOADLIB
//SYSPRINT DD  SYSOUT=*
//
>< ADD NAME=LINK$03  0101-07007-07007-0032-00012-00012-00012-KTOMIAK
//*                                                                     00010001
//LINKLMD EXEC PGM=IEWBLINK,REGION=1024K,                               00020001
//             PARM='NCAL,LET,LIST,MAP'                                 00030001
//LOADLIB  DD  DISP=SHR,DSN=SHARE##.SHR.LOADLIB                         00040001
//SYSLIN   DD  *                                                        00050001
 INCLUDE LOADLIB(PDSUPDTE)                                              00060001
 ENTRY PDSUPDTE                                                         00070001
 NAME  PDSUPDTE(R)                                                      00080001
/*                                                                      00090001
//SYSLMOD  DD  DISP=SHR,DSN=SHARE##.SHR.LOADLIB                         00100001
//SYSPRINT DD  SYSOUT=*                                                 00110001
//                                                                      00120001
./ ADD NAME=IFASMFDP 0666-07209-07209-1503-00001-00001-00000-DIR2UPDT
>< ADD NAME=SMF      0101-07010-07016-2350-00004-00004-00002-KTOMIAK
                                                                        00010000
SMF$01  IFASMFDP TO DUMP ONE SMF DATA SET (COPY)                        00020001
SMF$02  IFASMFDP TO DUMP AND CLEAR ONE SMF DATA SET (MOVE)              00021001
                                                                        00030000
>< ADD NAME=SMF$01   0100-07010-07010-2323-00015-00015-00000-KTOMIAK

//SMF14   EXEC PGM=IFASMFDP,COND=(4,LT),REGION=512K
//INDD1    DD  DISP=SHR,DSN=SYS1.MAN1
//INDD2    DD  DISP=SHR,DSN=SYS1.MAN2
//INDD3    DD  DISP=SHR,DSN=SYS1.MAN3
//SYSPRINT DD  SYSOUT=*
//DUMPOUT  DD  DISP=(,PASS,DELETE),DSN=&&SMFDATA,
//             UNIT=SYSALLDA,SPACE=(CYL,(40),,,ROUND),
//             DCB=(RECFM=VBS,LRECL=32756,BLKSIZE=4096)
//SYSIN    DD  *
               INDD(INDD1,OPTIONS(DUMP))
               INDD(INDD2,OPTIONS(DUMP))
               INDD(INDD3,OPTIONS(DUMP))
/*

>< ADD NAME=SMF$02   0100-07010-07010-2330-00022-00022-00000-KTOMIAK

 MAKE SURE YOU DUMPED AND SAVED THE DATA FIRST

//CLEAR   EXEC PGM=IFASMFDP,REGION=4096K
//SYSPRINT DD  SYSOUT=*
//DUMPIN   DD  DISP=SHR,DSN=SYS1.MAN1
//DUMPOUT  DD  DISP=(NEW,CATLG),DSN=SYS2.SAVED.SMF(+1),
//             UNIT=SYSDA,SPACE=(TRK,(PRI,SEC),RLSE)
//             DCB=(DSORG=PS,RECFM=VBS,BLKSIZE=32760,LRECL=X)
//SYSIN    DD  *
     INDD(DUMPIN,OPTIONS(DUMPR))
/*
//DMPIF    IF  (RC = 0) THEN
//CLEAR   EXEC PGM=IFASMFDP,REGION=4096K
//SYSPRINT DD  SYSOUT=*
//DUMPIN   DD  DISP=SHR,DSN=SYS1.MAN1
//DUMPOUT  DD  DUMMY
//SYSIN    DD  *
     INDD(DUMPIN,OPTIONS(CLEAR))
/*
//DMPIF   ENDIF
//
./ ADD NAME=IFHSTATR 0666-07209-07209-1505-00001-00001-00000-DIR2UPDT
>< ADD NAME=STATR    0101-07010-07017-0015-00003-00003-00000-KTOMIAK

STATR$01  IFHSTATR is used to print out Type 21 SMF records.

>< ADD NAME=STATR$01 0100-07010-07010-2330-00009-00009-00000-SC26UTL

In this example, IFHSTATR is used to print out Type 21 SMF records.

//REPORT JOB ...
//STEP1   EXEC PGM=IFHSTATR
//SYSUT1   DD  DISP=(OLD),DSN=SMF.UNLOAD
//SYSUT2   DD  SYSOUT=*
/*

./ ADD NAME=IPCS     0666-07200-07200-1906-00001-00001-00000-DIR2UPDT
//* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
//* PRODUCE A COMPONENT TCPIP REPORT OF PACKET TRACE DATA.
//* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//TCPIP   EXEC PGM=IKJEFT01,PARM='',TIME=1200,REGION=6M
//SYSPROC  DD  DISP=SHR,DSN=SYS1.SBLSCLI0
//         DD  DISP=SHR,DSN=SYS1.TCPIP.SEZAINST
//SYSHELP  DD  DISP=SHR,DSN=SYS1.TCPIP.SEZAHELP
//SYSEXEC  DD  DISP=SHR,DSN=SYS1.TCPIP.SEZAINST
//ISPLLIB  DD  DISP=SHR,DSN=SYS1.TCPIP.SEZAMIG
//STEPLIB  DD  DISP=SHR,DSN=SYS1.TCPIP.SEZAMIG
//         DD  DISP=SHR,DSN=SYS1.TCPIP.SEZALINK
//ISPMLIB  DD  DISP=SHR,DSN=SYS1.TCPIP.SEZAMENU
//ISPPLIB  DD  DISP=SHR,DSN=SYS1.TCPIP.SEZAPENU
//ISPTLIB  DD  DISP=SHR,DSN=SYS1.SBLSPNL0
//SYSPRINT DD  SYSOUT=*
//IPCSTOC  DD  SYSOUT=*
//IPCSPRNT DD  SYSOUT=*
//DFHSNAP  DD  SYSOUT=*
//IPCSDDIR DD  DISP=SHR,DSN=&SYSUID..DDIR
//DUMP     DD  DISP=SHR,DSN=&SYSUID..PKTFMT.EBC
//SYSTSPRT DD  SYSOUT=*
//SYSTSIN  DD  *
 IPCS
  DROPDUMP DDNAME(DUMP)
  SETDEF DSNAME(PKTFMT.EBC) NOCONFIRM
  CTRACE COMP(SYSTCPDA) FULL
 END
/*
//*
./ ADD NAME=ISRSUPC  0666-07209-07209-1505-00001-00001-00000-DIR2UPDT
>< ADD NAME=SUPC     0102-07003-07017-0016-00159-00159-00000-KTOMIAK

SUPC$01  Line compare
SUPC$02  File compare
SUPC$03  Line compare with edit statement and selected members


//SUPERC EXEC PGM=ISRSUPC,
//            PARM=(listing-type,compare-type,
//            'process-options-part-1-of-2',
//            'process-options-part-2-of-2')

LISTING TYPE:
-------------
       OVSUML  DELTAL  CHNGL  LONGL  NOLISTL

OVSUM  Lists only the overall summary of the data set or PDS comparison.

       If partitioned data sets are compared, the listing includes a
       summary line for each member selected from the PDS.

Delta  Lists the differences between the source data sets, followed by
       the overall summary results.  Differences are flagged to the left
       of each output line.

CHNG   Lists the differences between the source data sets, plus up to 10
       matching output lines before and after the differences.  This
       listing is like the delta listing, but includes surrounding
       matched lines as an aid in recognizing changed areas of the
       source data sets.

Long   Lists the complete new data set with the old data set deleted
       data interspersed in the output listing.  Both inserted and
       deleted output data is flagged. The format is the same as the
       DELTA with all matching data shown.

Nolist No listing output is produced.  A ISPF message displayed after
       the SuperC program execution is the sole method to determine the
       results of the compare operation.  You may wish to use the NOLIST
       option when you use one of the UPDATE comparison options to
       generate an update data set and the listing is unimportant.

NOTE:  The listing type default for Line, Word, and Byte compare is
       DELTA.  The listing type is ignored for File compare as other
       File compare process options are used to determine the listing
       requirements.

COMPARE TYPE:
-------------
       FILECMP   LINECMP  WORDCMP  BYTECMP
File   Checks source data sets and determines if they are different.
       This is the simplest and fastest method with the least amount of
       processing overhead. It produces a 32 bit hashsum for each
       DS/member processed.

Line   Compares source data sets at the line level for differences.
       Reformatted lines (that is, lines with blanks inserted or
       deleted) are automatically detected for lines <= 256 characters.
       Line compare is the most frequently used level of compare and is
       the compare type default.

Word   Compares source data sets for word differences. A word is a group
       of characters separated by a blank or line delimiter. The XWDCMP
       process option extends the delimiters to all non-alphameric
       characters.

Byte   Compares source data sets for differences at the byte level. The
       output listing data set consists of a hex printout with character
       equivalents listed on the right (as in a dump listing).


PROCESS OPTIONS BY COMPARE TYPE:
--------------------------------
Line-Compare:

    ALLMEMS ANYC    APNDLST APNDUPD CKPACKL
    CNPML   COBOL   COVSUM  DLMDUP
    DLREFM  DPACMT  DPADCMT DPBLKCL DPCBCMT
    DPCPCMT DPFTCMT DPMACMT DPPLCMT
    DPPSCMT FMVLNS  GWCBL   LOCS    LONGLN
    MIXED   NARROW  NOPRTCC NOSEQ
    NOSUMS  REFMOVR SEQ     UPDCMS8 UPDCNTL
    UPDLDEL UPDMVS8 UPDPDEL UPDREV
    UPDREV2 UPDSEQ0 UPDSUMO WIDE    Y2DTONLY

Word-Compare:

    ALLMEMS ANYC    APNDLST APNDUPD CKPACKL
    COBOL   COVSUM
    DPACMT  DPADCMT DPBLKCL DPCBCMT DPCPCMT
    DPFTCMT DPMACMT DPPLCMT DPPSCMT
    GWCBL   LOCS    MIXED   NOPRTCC NOSEQ
    NOSUMS  SEQ
    UPDCNTL UPDREV  UPDREV2 UPDSUMO XWDCMP

Byte-Compare:

    ALLMEMS APNDLST APNDUPD COVSUM
    NOPRTCC NOSUMS  LOCS
    UPDCNTL UPDSUMO

File-Compare:

    ALLMEMS APNDLST COVSUM FMSTOP
    LMCSFC  LOCS    NOPRTCC


PROCESS OPTIONS:
----------------
                     Input Process Control Options
SEQ      - Ignore FB 80/VB 255 standard sequence number columns or
NOSEQ    - Process FB 80/VB 255 standard sequence number columns as data
COBOL    - Ignore sequence number columns 1-6 in FB 80 records.
ANYC     - Process lower case as upper case input characters.
MIXED    - Data may contain DBCS strings delimited by SO/SI characters.
CKPACKL  - Check and unpack data before comparing data sets or members.
Y2DTONLY - Process only data defined by Year 2000 Date Definitions.
ALLMEMS  - Compare all members including alias entries.

                     Do Not Process Control Options
DPPLCMT  - Do not process /* ... */ comments and blank compare lines.
DPPSCMT  - Do not process (* ... *) comments and blank compare lines.
DPADCMT  - Do not process "--" comments and blank compare lines.
DPACMT   - Do not process "assembler" lines with "*" in column 1.
DPFTCMT  - Do not process lines with "C" in column 1.
DPCBCMT  - Do not process lines with "*" in column 7.
DPBLKCL  - Do not process blank compare lines.
DPCPCMT  - Do not process "//" comments and blank compare lines.
DPMACMT  - Do not process PC assembly comments ("*" in column 1).

                     Output Process Control Options
REFMOVR  - Reformat override.  Do not flag reformatted lines in listing.
DLREFM   - Do not list reformatted old DS lines. Only new DS reformats.
DLMDUP   - Do not list matched old DS lines in side-by-side listing.
FMVLNS   - Flag Insert/Delete moved lines.
LOCS     - List only changed and non-paired members in PDS summary list.
CNPML    - Count all lines including non-paired members in PDS summary.
NOSUMS   - Exclude listing summary sections.
COVSUM   - List final summary section only if there are differences.

                        Listing Control Options
WIDE     - Up to 80 columns side-by-side. Line length = 202/203 or
NARROW   - Up to 55 columns side-by-side. Line length = 132/133 or
LONGLN   - Lists up to 176 columns. Line length = 202/203.
GWCBL    - Generate LINE Change Bar Listing.
NOPRTCC  - No print control column and page separators.
APNDLST  - Append listing report to listing data set.

                        Update Data Set Options
APNDUPD  - Append update report to update data set.
UPDSUMO  - Overall summary statistics listed in a single line format or
UPDCMS8  - Cntl and new DS source using cols 73-80 (for CMS UPDATE) or
UPDMVS8  - Cntl and new DS source using cols 73-80 (for MVS IEBUPDTE) or
UPDSEQ0  - Cntl and new DS source using relative line numbers or
UPDCNTL  - Ins, del and mat control records using relative line numbers
UPDPDEL  - Prefixed delta lines (maximum 32K columns in output line) or
UPDLDEL  - Generate long delta - full source with inserts and deletes or
UPDREV   - Update Revision   - new DS copy with revision code tags or
UPDREV2  - Update Revision 2 - new DS copy with revision code tags.

>< ADD NAME=SUPC$01  0100-07003-07003-2114-00010-00010-00000-KTOMIAK

//* ISRSUPC   - SuperC Compare
//SUPERC  EXEC PGM=ISRSUPC,
//             PARM=(DELTAL,LINECMP,
//             '',
//             '')
//OLDDD    DD  DISP=SHR,DSN=<==your.older.pds.dataset
//NEWDD    DD  DISP=SHR,DSN=<==your.newer.pds.dataset
//OUTDD    DD  SYSOUT=(*)

>< ADD NAME=SUPC$02  0100-07003-07003-2114-00006-00006-00000-KTOMIAK
//SUPERC EXEC PGM=ISRSUPC,
//            PARM=(DELTAL,FILECMP,'','')
//NEWDD   DD  DISP=SHR,DSN=KTOMIAK.S2820LAB.CNTL
//OLDDD   DD  DISP=SHR,DSN=KTOMIAK.S2820.CNTL
//OUTDD   DD  SYSOUT=(*)
//
>< ADD NAME=SUPC$03  0100-07003-07003-2114-00013-00013-00000-KTOMIAK
//SUPERC  EXEC PGM=ISRSUPC,                                            *
//            PARM=(DELTAL,LINECMP,
//            'SEQ DPPLCMT DPPSCMT FMVLNS LOCS ANYC WIDE',
//            'ALLMEMS')
//NEWDD  DD DSN=KTOMIAK.SHR.CNTL,
//          DISP=SHR
//OLDDD  DD DSN=KTOMIAK.S2820.CNTL,
//          DISP=SHR
//OUTDD  DD SYSOUT=(A)
//SYSIN  DD *
LSTCOLM 1:55
SELECT $ASMAC,$ASMACL,$IGYWCL,$S8324E,$S8325,ADRDSSU
/*
./ ADD NAME=IXCMIAPU 0666-07209-07209-1458-00001-00001-00000-DIR2UPDT
>< ADD NAME=IXC      0103-07011-07021-2324-00003-00005-00000-KTOMIAK

IXC$01  Report contents
IXC$02  Define a logger couple data set
IXC$03  Delete some logstream entries

>< ADD NAME=IXC$01   0100-07011-07011-2114-00011-00011-00000-KTOMIAK

//*
//STEP001 EXEC PGM=IXCMIAPU
//SYSPRINT DD  SYSOUT=*
//SYSABEND DD  SYSOUT=*
//SYSIN    DD  *
 DATA TYPE(LOGR) REPORT(YES)
/*
//

 DATA TYPE(LOGR) REPORT(NO)
>< ADD NAME=IXC$02   0100-07021-07021-2319-00018-00018-00000-KTOMIAK

//STEP1    EXEC PGM=IXCL1DSU
//SYSPRINT DD   SYSOUT=*
//SYSIN    DD   *
  DEFINEDS SYSPLEX(plex_name)
           DSN(SYS1.plex_name.SLC.CDS0A) VOLSER(vlser2)
       DATA TYPE(LOGR)
            ITEM NAME(LSR) NUMBER(400)
            ITEM NAME(LSTRR) NUMBER(40)
            ITEM NAME(DSEXTENT) NUMBER(80)
  DEFINEDS SYSPLEX(plex_name)
           DSN(SYS1.plex_name.SLC.CDS0B) VOLSER(vlser1)
       DATA TYPE(LOGR)
            ITEM NAME(LSR) NUMBER(400)
            ITEM NAME(LSTRR) NUMBER(40)
            ITEM NAME(DSEXTENT) NUMBER(80)
/*

>< ADD NAME=IXC$03   0100-07021-07021-2324-00010-00010-00000-KTOMIAK

//*
//STEP001 EXEC PGM=IXCMIAPU
//SYSPRINT DD SYSOUT=*
//SYSIN    DD *
  DATA TYPE(LOGR) REPORT(YES)
  DELETE LOGSTREAM NAME(kixappl.DFHLOG.MODEL)
  DELETE LOGSTREAM NAME(kixappl.DFHSHUNT.MODEL)
/*

./ ADD NAME=JOBCARD  0666-07209-07209-1459-00001-00001-00000-DIR2UPDT
>< ADD NAME=JOBC     0101-07010-07016-2347-00004-00004-00000-KTOMIAK

JOBC$01  Basic jobcard
JOBC$02  with an output statement

>< ADD NAME=JOBC$01  0100-07010-07010-2317-00008-00008-00000-KTOMIAK
//SHARE##H JOB (0700,MID),'SHARE-MVS SCP',                              00010001
//             CLASS=A,MSGCLASS=T,MSGLEVEL=(1,1),                       00020000
//             NOTIFY=&SYSUID,REGION=6M,TIME=400                        00030000
//*                                                                     00040000
//* SOURCE: DSN=SHARE##.S2820.CNTL(JOBC4SHR)                            00040000
//* AUTHOR: YOUR NAME <YOUREMAIL@YOURDOMAIN>                            00060000
//* REMARK: THIS JOB ....................................               00070003
//*                                                                     00040000
>< ADD NAME=JOBC$02  0100-07010-07010-2320-00015-00015-00000-KTOMIAK
//SHARE##H JOB (0700,MID),'SHARE-MVS SCP',                              00010000
//             CLASS=A,MSGCLASS=T,MSGLEVEL=(1,1),                       00020000
//             NOTIFY=&SYSUID,REGION=6M,TIME=400                        00030000
//*                                                                     00040000
//* SOURCE: DSN=SHARE##.S2820.CNTL(JOBC4SHR)                            00050000
//* AUTHOR: YOUR NAME <YOUREMAIL@YOURDOMAIN>                            00060000
//* REMARK: THIS JOB ....................................               00070000
//*                                                                     00080000
//MYPROCS JCLLIB ORDER=(DSN1,DSN2,...)                                  00090000
//*                                                                     00100000
//JESDS OUTPUT DEFAULT=YES,                                             00110000
//             JESDS=ALL,                                               00120000
//             OUTDISP=(HOLD,HOLD),                                     00130000
//             NAME='KENNETH E. TOMIAK'                                 00140000
//*                                                                     00150000
./ ADD NAME=RACF     0666-07209-07209-1458-00001-00001-00000-DIR2UPDT
>< ADD NAME=IRR      0102-07011-07107-2050-00003-00005-00000-KTOMIAK

IRR$01   RACF DB Unload
IRR$02   RACF DB Cleanup
IRR$03   RACF DB Unload

>< ADD NAME=IRR$01   0100-07011-07011-2117-00009-00009-00000-KTOMIAK

//*
//UNLOAD  EXEC PGM=IRRDBU00,PARM='NOLOCK'
//SYSPRINT DD  SYSOUT=*
//INDD1    DD  DISP=OLD,DSN=SYS1.RACF.ISYSPRIM
//OUTDD    DD  DISP=(NEW,CATLG),DSN=SHARE##.RACF.&SSID..UNLD,
//             UNIT=SYSDA,SPACE=(CYL,(20,5)),
//             DCB=(RECFM=VB,BLKSIZE=0,LRECL=4096)

>< ADD NAME=IRR$02   0100-07107-07107-2048-00017-00017-00000-KTOMIAK

This utility should find all the unrelated crud and create
delete commands to help cleanup your data base.

//STEP1    EXEC PGM=IRRRID00
//SYSPRINT DD   SYSOUT=*
//SYSOUT   DD   SYSOUT=*
//SORTOUT  DD   UNIT=SYSALLDA,SPACE=(CYL,(5,5))
//SORTWK01 DD   UNIT=SYSALLDA,SPACE=(CYL,(5,5))
//SYSUT1   DD   UNIT=SYSALLDA,SPACE=(CYL,(3,5))
//INDD     DD   DISP=OLD,DSN=USER01.IRRDBU00.DATA
//OUTDD    DD   DISP=(NEW,CATLG),DSN=USER01.IRRRID00.CLIST,
//              UNIT=SYSALLDA,
//              SPACE=(TRK,(10,10),RLSE),
//              DCB=(DSORG=PS,RECFM=FB,BLKSIZE=0,LRECL=80)
//SYSIN    DD   DUMMY    NO SYSIN REQUESTS A RESIDUAL SEARCH

>< ADD NAME=IRR$03   0100-07107-07107-2050-00018-00018-00000-KTOMIAK

This utility will map your data base. This might help you if you
need to create multiple data sets to spread out the load.


//UT200   EXEC PGM=IRRUT200
//SYSRACF  DD  DISP=SHR,DSN=SYS1.RACF.PRIMARY
//SYSUT1   DD  UNIT=SYSALLDA,SPACE=(CYL,(10)),
//             DCB=(LRECL=4096,RECFM=F)
//SYSUT2   DD  SYSOUT=*
//SYSPRINT DD  SYSOUT=*
//SYSIN    DD  *
    INDEX FORMAT
    MAP ALL
    END
/*
//

./ ADD NAME=SDSF     0666-07209-07209-1502-00001-00001-00000-DIR2UPDT
>< ADD NAME=SDSF     0101-07003-07016-2350-00003-00003-00000-KTOMIAK

SDSF$01 Capture job output to a file

>< ADD NAME=SDSF$01  0100-07003-07003-2114-00020-00020-00000-KTOMIAK
//*
//*  CAPTURE SPOOL OUTPUT TO SEQUENTIAL DATA SET
//*
//CAPTURE EXEC PGM=SDSF,PARM=''
//ISFIN    DD  *
PREFIX MYJBNM*
H
FILTER JOBID EQ JOB02785
FIND MYJBNMP
++S
PRINT FILE OUTDD01
PRINT
PRINT CLOSE
/*
//ISFOUT   DD  SYSOUT=*
//OUTDD01  DD  DISP=(NEW,CATLG),DSN=MYJBNM.JOB02785,
//             UNIT=SYSALLDA,SPACE=(TRK,(20,2)),
//             DCB=(DSORG=PS,RECFM=VBA,BLKSIZE=0,LRECL=247)
//*
//
./ ADD NAME=SMPE     0666-07209-07209-1504-00001-00001-00000-DIR2UPDT
>< ADD NAME=SMPE     0104-07016-07017-0021-00006-00013-00000-KTOMIAK

SMPE$01   RSU Philosophy
SMPE$02   Receive from network
SMPE$03   - control card for ORDRSRVR
SMPE$04   - control card for MYCLIENT
SMPE$05   Apply check
SMPE$06   Apply
SMPE$07   Accept check
SMPE$08   Accept
SMPE$09   Report errsysmods
SMPE$10   Compare zones
SMPE$11   Reject purge

>< ADD NAME=SMPE$01  0100-07016-07016-2158-00098-00098-00000-KTOMIAK
http://www-03.ibm.com/servers/eserver/zseries/zos/servicetst/getserv.html

Consolidated Service Test and the RSU

Getting an RSU

Do the following to obtain and install the service we're recommending:

1) Order a current preventive service deliverable that supports RSU.
   IBM recommends that you use ShopzSeries to place your service order
   for the z/OS and OS/390 platforms.  Effective with SMP/E V3.4, you
   can also use SMP/E Internet Service Retrieval to order preventive
   service, with options to specify:

  .) Critical service
  .) Recommended service, which includes Recommended Service Update
     SOURCEID (RSUyynn) and all PTFs that resolve HIPER problems or PTFs
     in error (critical service)
  .) All service includes all currently available PTFs.

2) SMP/E RECEIVE the PTFs and RSU assign statements into the global
   zone.

3) Get and receive the latest Enhanced HOLDDATA . Use the instructions
   on the Enhanced HOLDDATA for z/OS and OS/390 for instructions on
   getting the Enhanced HOLDDATA.

   For a list of PTFs included in the service package, see one of the
   following:

  .) When you order a current preventive service deliverable, the list
     of PTFs will be included in the order.
  .) Find the PTFs included in an RSU package by selecting the
     RSUyymm.txt file for the RSU you're interested in. For complete
     information on ++ASSIGN statements and Enhanced HOLDDATA, see the
     Enhanced HOLDDATA for z/OS and OS/390.

   For a list of PTFs that we could not include in CST testing because
   of unresolved PE fixes, see:

  .) Excluded service for sourceid RSU0612, which includes all service
     through the end of September 2006 and PE resolution and
     HIPER/Security/Integrity/Pervasive PTFs and their associated
     requisites and supersedes through the end of November 2006, is
     included in our CST quarterly report.

   Some of these excluded PTFs have an RSU sourceid assigned to them.
   You must evaluate whether these PTFs should be applied in your
   environment.  If you choose to exclude these PTFs, then your SMP/E
   APPLY must specify EXCLUDE for each of these PTFs.

4) Run an SMP/E APPLY CHECK as follows to identify any requisite
   service and additional holds, such as HOLDSYS(DOC), that may need to
   be resolved before APPLY processing:

   APPLY CHECK XZREQ
     GROUPEXTEND(NOAPARS,NOUSERMODS)
     SOURCEID(RSU*)
     BYPASS(HOLDSYSTEM,HOLDUSER).

   Resolve any holds and RECEIVE any requisite service identified by
   this APPLY CHECK before proceeding to the next step. Be sure to
   specify the GROUPEXTEND option to include any requisite PTFs required
   by the maintenance being installed.

5) Run an SMP/E APPLY as follows:

   APPLY XZREQ
     GROUPEXTEND(NOAPARS,NOUSERMODS)
     SOURCEID(RSU*)
     BYPASS(HOLDSYSTEM,HOLDUSER).

   Be sure to specify the GROUPEXTEND option to include any requisite
   PTFs required by the maintenance being installed.

6) Run the following SMP/E REPORT ERRSYSMODS command to identify any
   missing HIPER or PE fixes:

   REPORT ERRSYSMODS ZONES(tgtzone1, tgtzone2) NOPUNCH.

   SMP/E checks the target zones, tgtzone1 and tgtzone2, to see if any
   APPLYed SYSMODs are now being held due to error. This includes PTFs
   that are PE and product FMIDs that are held due to missing fixes to
   HIPER APARs. Because NOPUNCH is specified, this command generates
   only the Exception SYSMOD Report.

7) Analyze any missing HIPER and PE-fixing service identified in the
   REPORT ERRSYSMODS output to determine the likelihood of your hitting
   the problem based on your workloads and environment.

8) Install (RECEIVE and APPLY) any missing HIPER and PRP PTFs that
   you've determined to be critical in your environment. Note that
   applying additional HIPER and PRP service will result in a service
   level which has not been completely CST tested.

9) SMP/E ACCEPT CHECK and ACCEPT the PTFs to add them to the
   distribution libraries.

>< ADD NAME=SMPE$02  0103-07016-07017-0013-00043-00035-00000-KTOMIAK

//*
//RECEIVE EXEC PGM=GIMSMP
//SMPCSI   DD  DISP=SHR,DSN=your.global.zone.csi
//SMPNTS   DD  PATHDISP=KEEP,PATH='/u/smpe/smpnts/'
//ORDRSRVR DD  DISP=SHR,DSN=SHARE.MVSSCP.UTL.CNTL(SMPE$03)
//MYCLIENT DD  DISP=SHR,DSN=SHARE.MVSSCP.UTL.CNTL(SMPE$04)
//SMPCNTL  DD  *
SET
  BOUNDARY(GLOBAL)
.
  RECEIVE
    SYSMODS
    HOLDDATA
    ORDER(                   /* Place an order for service */
      ORDERSERVER(ORDRSRVR)
      CLIENT(MYCLIENT)
      FORTGTZONES(tgtzne)   /* ..for this target zone      */
      CONTENT(
        /* see below                                       */
      )
    )
  .
/*
//

   CONTENT(           /* use one of the four options below */
     ALL
     CRITICAL
     RECOMMENDED
     PTFS(        /* Get these PTFs, and any pre-reqs      */
       UK17765
       UK17372
     )

>< ADD NAME=SMPE$03  0101-07016-07016-2204-00006-00005-00000-KTOMIAK
  <ORDERSERVER
    url="https://eccgw01.boulder.ibm.com/services/projects/ecc/ws/"
    keyring="key_owners_userid/RCVPTFS"
    certificate="SMPE Client Certificate">
  </ORDERSERVER>
>< ADD NAME=SMPE$04  0100-07016-07016-2159-00004-00004-00000-KTOMIAK
  <CLIENT
    javahome="/usr/lpp/java/J1.4"
    classpath="/usr/lpp/smp/classes">
  </CLIENT>
>< ADD NAME=SMPE$05  0103-07017-07056-1912-00020-00018-00000-KTOMIAK

//*
//APPCK   EXEC PGM=GIMSMP
//SMPCSI   DD  DISP=SHR,DSN=your.global.zone.csi
//SMPLOG   DD  DUMMY
//SMPLOGA  DD  DUMMY
//SMPCNTL  DD  *
SET
  BOUNDARY(tgtzne)
.
  APPLY CHECK
    GROUPEXTEND(NOAPARS,NOUSERMODS)
    BYPASS(HOLDSYSTEM,HOLDUSER)
    sourceid(rsu*,hiper,smccor,smcrec)
  .
/*
//

>< ADD NAME=SMPE$06  0104-07017-07056-1912-00018-00016-00000-KTOMIAK

//*
//APPLY   EXEC PGM=GIMSMP
//SMPCSI   DD  DISP=SHR,DSN=your.global.zone.csi
//SMPCNTL  DD  *
SET
  BOUNDARY(tgtzne)
.
  APPLY
    GROUPEXTEND(NOAPARS,NOUSERMODS)
    BYPASS(HOLDSYSTEM,HOLDUSER)
    sourceid(rsu*,hiper,smccor,smcrec)
  .
/*
//

>< ADD NAME=SMPE$07  0104-07017-07056-1912-00020-00018-00000-KTOMIAK

//*
//ACCCK   EXEC PGM=GIMSMP
//SMPCSI   DD  DISP=SHR,DSN=your.global.zone.csi
//SMPLOG   DD  DUMMY
//SMPLOGA  DD  DUMMY
//SMPCNTL  DD  *
SET
  BOUNDARY(dlibzne)
.
  ACCEPT CHECK
    GROUPEXTEND(NOAPARS,NOUSERMODS)
    BYPASS(HOLDSYSTEM,HOLDUSER)
    sourceid(rsu*,hiper,smccor,smcrec)
  .
/*
//

>< ADD NAME=SMPE$08  0103-07017-07056-1912-00020-00016-00000-KTOMIAK

//*
//ACCEPT  EXEC PGM=GIMSMP
//SMPCSI   DD  DISP=SHR,DSN=your.global.zone.csi
//SMPCNTL  DD  *
SET
  BOUNDARY(dlibzne)
.
  ACCEPT
    GROUPEXTEND(NOAPARS,NOUSERMODS)
    BYPASS(HOLDSYSTEM,HOLDUSER)
    sourceid(rsu*,hiper,smccor,smcrec)
  .
/*
//

>< ADD NAME=SMPE$09  0103-07017-07056-1912-00020-00016-00000-KTOMIAK

//*
//ERRSYSM EXEC PGM=GIMSMP
//SMPCSI   DD  DISP=SHR,DSN=your.global.zone.csi
//SMPCNTL  DD  *
SET
  BOUNDARY(GLOBAL)
.
  REPORT
    ERRSYSMODS
    ZONES(tgtzone1, tgtzone2)
    NOPUNCH
  .
/*
//

>< ADD NAME=SMPE$10  0101-07017-07056-1911-00026-00024-00000-KTOMIAK

//*
//XZNCMPR EXEC PGM=GIMSMP
//SMPCSI   DD  DISP=SHR,DSN=your.global.zone.csi
//SMPLOG   DD  DUMMY            <== No reason to log this
//SMPCNTL  DD  *
SET
  BOUNDARY (GLOBAL)
.
  REPORT                    /* First zone 1 to zone 2  */
    SYSMODS
    INZONE(DB4TT)
    COMPAREDTO(DB4ZT)
    NOPUNCH
  .
  REPORT                    /* Next, zone 2 to zone 1  */
    SYSMODS
    INZONE(DB4ZT)
    COMPAREDTO(DB4tT)
    NOPUNCH
  .
/*
//

>< ADD NAME=SMPE$11  0101-07017-07056-1911-00025-00022-00000-KTOMIAK

//*
//RJCTPRG EXEC PGM=GIMSMP
//SMPCSI   DD  DISP=SHR,DSN=your.global.zone.csi
//SMPCNTL  DD  *
SET
  BOUNDARY (GLOBAL)
.
  REJECT
    PURGE
    PTFS
    TARGETZONE(DB4ZT)
  .
  REJECT
    PURGE(dlibzne)
  .
  REJECT
    FUNCTIONS
  .
/*
//

./ ADD NAME=SORT     0666-07209-07209-1504-00001-00001-00000-DIR2UPDT
>< ADD NAME=SORT     0103-07003-07017-0015-00004-00006-00000-KTOMIAK

SORT$01 simple sort
SORT$02 icetool
SORT$03 icetool to show sort defaults
SORT$04 SYNCLIST to show sort defaults

>< ADD NAME=SORT$01  0100-07003-07003-2141-00032-00032-00000-KTOMIAK
//*                                                                     00200000
//GENDATA EXEC PGM=IEBDG,REGION=2048K                                   00210000
//SYSPRINT DD  SYSOUT=*                                                 00220000
//SEQOUT   DD  DSN=&&DATA,DISP=(NEW,PASS),UNIT=3390,                    00230000
//             DCB=(BLKSIZE=6050,LRECL=121,RECFM=FB),                   00240000
//             SPACE=(6050,(4000,40))                                   00250000
//SYSIN    DD  *                                                        00260000
  DSD OUTPUT=(SEQOUT)                                                   00270000
  FD  NAME=R1,STARTLOC=5,LENGTH=4,FORMAT=RA                             00280000
  REPEAT QUANTITY=4,CREATE=1                                            00290000
  CREATE QUANTITY=50000,NAME=R1                                         00300000
  END                                                                   00310000
/*                                                                      00311000
//SORT    EXEC PGM=SORT,REGION=2048K,                                   00320000
//             PARM='BMSG,DIAG,LIST'                                    00321000
//SYSOUT   DD  SYSOUT=*                                                 00330000
//STATOUT  DD  SYSOUT=*                                                 00340000
//DFSMSG   DD  SYSOUT=*                                                 00341000
//SYSIN    DD  *                                                        00350000
  SORT     FIELDS=(5,4,BI,A)                                            00360000
/*                                                                      00361000
//DFSPARM  DD  *             DFSORT PARAMETERS                          00363000
/*                                                                      00364000
//$ORTPARM DD  *             SYNCSORT PARAMETERS                        00365000
/*                                                                      00366000
//SORTIN   DD  DISP=(OLD,DELETE),DSN=&&DATA                             00370000
//SORTOUT  DD  UNIT=3390,SPACE=(6050,(4000,40)),                        00380000
//             DISP=(,DELETE),DCB=BLKSIZE=6050                          00390000
//SORTWK01 DD  UNIT=3390,SPACE=(6050,(2000,20))                         00400000
//SORTWK02 DD  UNIT=3390,SPACE=(6050,(2000,20))                         00410000
//SORTWK03 DD  UNIT=3390,SPACE=(6050,(2000,20))                         00420000
//                                                                      00430000
>< ADD NAME=SORT$02  0100-07003-07003-2139-00125-00125-00000-KTOMIAK
//*****************************************************************
//*
//* ICETOOLJ - Invokes ICETOOL
//*
//*****************************************************************
//*
//* Instructions:
//*
//*   1. Change the job card to meet your system requirements.
//*
//*   2. If the DFSORT libraries are not in the link list or not in
//*      the LPA list, then uncomment the JOBLIB and change hhh
//*      to the high level qualifier used to install DFSORT.
//*
//* Return code 0 is expected for all steps.
//*
//******************************************************************
//*JOBLIB  DD DSN=hhh.SICELINK,DISP=SHR
//*        DD DSN=hhh.SORTLPA,DISP=SHR
//GEN      EXEC  PGM=IEBDG
//SYSPRINT DD SYSOUT=*
//INPUT1   DD  *
WU                  HILDA                   L92
WARREN              WILLIAM                 J82
MEAD                JANICE                  J69
YAEGER              FRANK                   J69
JAQUET              STEFAN                  L92
MADRID              MIGUEL                  J69
GELLAI              ANDY                    J82
LEE                 PAUL                    J69
TOWNSEND            LEE                     J82
BURT                JOHN                    J69
MEHTA               NEELA                   L92
KIRCHHOFER          RICHARD                 L92
YAMAMOTO-SMITH      HOLLY                   J69
BANH                PAUL                    L92
JONES               MARGARET                J62
//GENOUT1  DD DSN=&&DS1,DISP=(NEW,PASS),
//            DCB=(LRECL=80,BLKSIZE=6000,RECFM=FB),
//            UNIT=SYSALLDA,SPACE=(TRK,(5,2))
//GENOUT2  DD DSN=&&DS2,DISP=(NEW,PASS),
//            DCB=(LRECL=80,BLKSIZE=8004,RECFM=VB),
//            UNIT=SYSALLDA,SPACE=(TRK,(5,2))
//SYSIN    DD  *
 DSD  OUTPUT=(GENOUT1),INPUT=(INPUT1)
 CREATE INPUT=INPUT1
 END
 DSD  OUTPUT=(GENOUT2)
 FD NAME=SORT,LENGTH=10,STARTLOC=1,PICTURE=10,'XYZ123ABCD',ACTION=RP
 FD NAME=SUM1,LENGTH=6,STARTLOC=18,PICTURE=6,P'001125',INDEX=92,       C
               SIGN=-
 FD NAME=SUM2,LENGTH=3,STARTLOC=26,FORMAT=ZD,INDEX=12
 FD NAME=LAST,LENGTH=12,STARTLOC=46,FORMAT=AN,ACTION=SL
 REPEAT QUANTITY=3,CREATE=2
 CREATE QUANTITY=3,NAME=(SORT,SUM1,SUM2,LAST)
 CREATE QUANTITY=6,NAME=(SORT,SUM1,SUM2)
 END
//*
//* DO MULTIPLE OPERATIONS WITH ICETOOL
//*
//TOOLRUN EXEC PGM=ICETOOL
//TOOLMSG  DD SYSOUT=*
//DFSMSG   DD SYSOUT=*
//TOOLIN   DD  *
* LIST ICEMAC DEFAULTS
   DEFAULTS LIST(DFLTS)
* COPY AND REFORMAT SELECTED RECORDS
   COPY USING(CJ69) FROM(IN1) TO(OUTJ69D)
   COPY USING(CJ82) FROM(IN1) TO(OUTJ82D)
* SORT/SAVE/PRINT THE RESULTING COMBINED DATA SETS
   SORT FROM(CONCAT) TO(DEPTSD,DEPTSP) USING(ABCD)
* DO FOLLOWING OPERATORS EVEN IF A PREVIOUS OPERATOR FAILED,
* BUT STOP PROCESSING IF A SUBSEQUENT OPERATOR FAILS
 MODE STOP
* VERIFY DECIMAL FIELDS
   VERIFY FROM(IN2) ON(22,6,PD) ON(30,3,ZD)
* PRINT STATISTICS FOR RECORD LENGTH AND NUMERIC FIELDS
   STATS FROM(IN2) ON(VLEN) ON(22,6,PD) ON(30,3,ZD)
* SORT AND PRODUCE TOTALS FOR EACH UNIQUE KEY
   SORT FROM(IN2) TO(OUT4) USING(CTL1)
* PRINT KEY AND TOTALS FOR EACH UNIQUE KEY AND MINIMUM
* VALUE FOR EACH SET OF TOTALS
   DISPLAY FROM(OUT4) LIST(LIST1) -
      TITLE('KEYS AND TOTALS') PAGE -
      HEADER('KEY') HEADER('PD_TOTAL') HEADER('ZD_TOTAL') -
      ON(5,10,CH) ON(22,6,PD) ON(30,3,ZD) -
      BLANK MINIMUM('MINIMUM')
* PRINT NUMBER OF EMPLOYEES IN EACH DEPARTMENT
   OCCUR FROM(IN1) LIST(DEPTOT) ON(45,3,CH) ON(VALCNT)
//CJ69CNTL DD  *
* SELECT J69 EMPLOYEES, REFORMAT FIELDS, AND INSERT TEXT
  INCLUDE COND=(45,3,CH,EQ,C'J69')
  OUTREC FIELDS=(21,10,X,1,15,C'IS IN DEPARTMENT J69',34X)
/*
//CJ82CNTL DD  *
* SELECT J82 EMPLOYEES, REFORMAT FIELDS, AND INSERT TEXT
  INCLUDE COND=(45,3,CH,EQ,C'J82')
  OUTREC FIELDS=(21,10,X,1,15,C'IS IN DEPARTMENT J82',34X)
/*
//IN1 DD DSN=&&DS1,DISP=(OLD,PASS)
//OUTJ69D DD DSN=&&OUTJ69D,DISP=(,PASS),SPACE=(TRK,(10,10)),
//        UNIT=SYSALLDA
//OUTJ82D DD DSN=&&OUTJ82D,DISP=(,PASS),SPACE=(TRK,(10,10)),
//        UNIT=SYSALLDA
//CONCAT DD DSN=*.OUTJ69D,VOL=REF=*.OUTJ69D,DISP=(OLD,PASS)
//       DD DSN=*.OUTJ82D,VOL=REF=*.OUTJ82D,DISP=(OLD,PASS)
//ABCDCNTL DD  *
* SORT BY LAST NAME, FIRST NAME
   SORT FIELDS=(12,15,CH,A,1,10,CH,A)
//DEPTSD   DD DSN=&&DEPTSD,DISP=(,PASS),SPACE=(TRK,(10,10)),
//         UNIT=SYSALLDA
//DEPTSP   DD SYSOUT=*
//IN2      DD DSN=&&DS2,DISP=(OLD,PASS)
//OUT4     DD DSN=&&OUTPUT2,DISP=(,PASS),SPACE=(TRK,(10,10)),
//         UNIT=SYSALLDA
//CTL1CNTL DD  *
* SORT AND PRODUCE TOTALS IN ONE RECORD FOR EACH UNIQUE KEY
  SORT FIELDS=(5,10,CH,A)
  SUM FIELDS=(22,6,PD,30,3,ZD)
/*
//DFLTS    DD SYSOUT=*
//LIST1    DD SYSOUT=*
//DEPTOT   DD SYSOUT=*
//*
//*    =====> END OF JOB ICETOOLJ <=====
>< ADD NAME=SORT$03  0100-07006-07006-2136-00010-00010-00000-KTOMIAK
//*
//ICETOOL EXEC PGM=ICETOOL
//TOOLMSG  DD  SYSOUT=*
//DFLTS    DD  SYSOUT=*
//DFSMSG   DD  SYSOUT=*
//TOOLIN   DD  *
* LIST ICEMAC DEFAULTS
   DEFAULTS LIST(DFLTS)
/*
//
>< ADD NAME=SORT$04  0101-07010-07011-2111-00005-00007-00000-DDENVER
//*
//SYNLST  EXEC PGM=SYNCLIST
//SYSPRINT DD  SYSOUT=*,COPIES=1
//SYSLIB   DD  DISP=SHR,DSN=SYS3.SYNCSORT.R12.SYNCLINK
//         DD  DISP=SHR,DSN=SYS0.SYNCSORT.R12.SYNCLPA
//         DD  DISP=SHR,DSN=SYS0.SYNCSORT.R12.SYNCRENT
//*
./ ADD NAME=SRCHFOR  0666-07209-07209-1456-00001-00001-00000-DIR2UPDT
>< ADD NAME=HFOR     0101-07003-07016-2328-00005-00005-00000-KTOMIAK

SEARCHFOR AS A BATCH JOB

HFOR$01 - SEARCHES FOR ONE STRING

>< ADD NAME=HFOR$01  0100-07003-07003-2114-00011-00011-00000-KTOMIAK

//* SRCHFOR
//SEARCH  EXEC PGM=ISRSUPC,
//             PARM=(SRCHCMP,
//             'ANYC')
//NEWDD    DD  DISP=SHR,DSN=<==your.pds.dataset
//OUTDD    DD  SYSOUT=(*)
//SYSIN    DD  *
SRCHFOR  'DSN8S71P'
/*

./ ADD NAME=TRSMAIN  0666-07209-07209-1506-00001-00001-00000-DIR2UPDT
>< ADD NAME=TRS      0101-07010-07017-0017-00005-00005-00000-KTOMIAK

TRS$01  PACK compresses a data set
TRS$02  SPACK does a super pack
TRS$03  UNPACK decompresses a data set

>< ADD NAME=TRS$01   0100-07010-07010-2249-00029-00029-00000-KTOMIAK

//* TRSMAIN
//STEP001 EXEC PGM=TRSMAIN,PARM='PACK'
//STEPLIB  DD  DISP=SHR,DSN=&SYSUID..LOADLIB
//SYSPRINT DD  SYSOUT=*
//INFILE   DD  DISP=SHR,DSN=SYS1.TCPIP.CTRACE,
//             DCB=BUFNO=20
//OUTFILE  DD  DISP=(NEW,CATLG),DSN=&SYSUID..P45316.CTRACE1.TERSED,
//             UNIT=SYSALLDA,
//             SPACE=(TRK,(500,250),RLSE),
//             DCB=BUFNO=20
//*            DCB=(RECFM=FB,BLKSIZE=6144,LRECL=1024,BUFNO=20)
//*
//STEP002 EXEC PGM=FTP,PARM='TESTCASE.SOFTWARE.IBM.COM (EXIT'
//SYSPRINT DD  SYSOUT=*
//FTPDATA  DD  DISP=SHR,DSN=SYS1.TCPPARMS(FTPDATAP)
//SYSTCPD  DD  DISP=SHR,DSN=SYS1.TCPPARMS(TCPDATAP)
//SYSIN    DD  *
anonymous
yourid@your.mail.server
cd s390/toibm/misc
bin
MKDIR p45316
CD   p45316
sendsite
put 'SP1KTOM.P45316.CTRACE1.TERSED' p45316.ctrace1.tersed
quit
/*

>< ADD NAME=TRS$02   0100-07010-07010-2249-00012-00012-00000-KTOMIAK

//* TRSMAIN
//STEP001 EXEC PGM=TRSMAIN,PARM='SPACK' <=Super Pack
//STEPLIB  DD  DISP=SHR,DSN=&SYSUID..LOADLIB
//SYSPRINT DD  SYSOUT=*
//INFILE   DD  DISP=SHR,DSN=SYS1.TCPIP.CTRACE,
//             DCB=BUFNO=20
//OUTFILE  DD  DISP=(NEW,CATLG),DSN=&SYSUID..P45316.CTRACE1.TERSED,
//             UNIT=SYSALLDA,
//             SPACE=(TRK,(500,250),RLSE),
//             DCB=BUFNO=20

>< ADD NAME=TRS$03   0100-07010-07010-2249-00013-00013-00000-KTOMIAK

//* TRSMAIN
//STEP002 EXEC PGM=TRSMAIN,PARM='UNPACK'
//STEPLIB  DD  DISP=SHR,DSN=&SYSUID..LOADLIB
//SYSPRINT DD  SYSOUT=*
//INFILE   DD  DISP=SHR,DSN=&SYSUID..MPTF2032.BIN,
//             DCB=BUFNO=20
//OUTFILE  DD  DISP=(NEW,CATLG),DSN=&SYSUID..MPTF2032.UNPACKED,
//             UNIT=SYSALLDA,
//             SPACE=(TRK,(500,250),RLSE),
//             DCB=BUFNO=20
//*            DCB=(RECFM=FB,BLKSIZE=6144,LRECL=1024,BUFNO=20)

./ ENDUP
